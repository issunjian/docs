import{_ as t,H as p,o as r,c,C as s,a,J as e,E as o,V as l}from"./chunks/framework.c6d8cbec.js";const P=JSON.parse('{"title":"React 模拟面试题 2023 版","description":"","frontmatter":{"author":"HearLing"},"headers":[],"relativePath":"interview/frontend/react-summary/index.md","filePath":"interview/frontend/react-summary/index.md"}'),i={name:"interview/frontend/react-summary/index.md"},y=l("",9),u=s("strong",null,"答案仅供参考",-1),F=s("strong",null,"答案会详略得当，不会面面俱到",-1),d=l("",43),h=l("",11),m=s("ul",null,[s("li",null,[s("p",null,"React 主要使用 diff 队列保存需要更新哪些 DOM，得到 patch 树，再统一操作批量更新 DOM。")]),s("li",null,[s("p",null,"Vue Diff 使用双向链表，边对比，边更新 DOM。")])],-1),b=s("blockquote",null,[s("p",null,"注意两者处于不同赛道，不存在谁取代谁这一说法，别踩一捧一。")],-1),E=s("ul",null,[s("li",null,[s("p",null,"React 只关注底层，上层应用解决方案交给社区，造就了 React 社区繁荣，同时 React 团队有更多时间专注底层。未来 React 的发展依然会在 函数式编程 这个核心思想的下进行升级。")]),s("li",null,[s("p",null,"Vue 提供了一揽子全家桶解决方案，比如 Vuex、Vue-Router、Vue-CLI、Vutur 工具等。减少选择困难症，只需认准官方给出的解决方案即可。Vue 依然会定位简单易上手（渐进式开发），依然是考虑通过依赖收集来实现数据可变。")])],-1),g=l("",6),_=l("",10),f=s("ul",null,[s("li",null,"Store，Store 存放应用程序的状态，并且有帮助函数来访问这些状态。Store 可以用来聆听变化和发送 action。Store 只有一个。"),s("li",null,"Reducers，数据的状态是通过 reducer 函数来改变的。"),s("li",null,"Actions，Actions 代表的是一个对象。有两部分，一个是 action 本身，另一个就是它的 payload。简单说就是对哪些数据进行哪些操作。"),s("li",null,"React-Redux，Redux 本身和 React 没有关系，只是数据处理中心，是 React-Redux 让他们联系在一起。React-rRedux 提供两个方法：connect 和 Provider。")],-1),C=l("",25);function R(k,x,q,D,S,A){const n=p("font");return r(),c("div",null,[y,s("p",null,[a("3、"),e(n,{color:"red"},{default:o(()=>[u]),_:1}),a(),F,a("。我更偏向于告诉你，这个题第一层你可以怎么展开，第二层在你展开的这几点各自下面的重要点又是什么。至于你要不要扩充各个层级的点，以及要不要更深入增加层级，就是需要自己去思考和研究的了。")]),d,s("details",null,[h,s("p",null,[a("6、"),e(n,{color:"gray"},{default:o(()=>[a("diff 算法实现")]),_:1})]),m,s("p",null,[a("7、"),e(n,{color:"gray"},{default:o(()=>[a("社区和未来发展")]),_:1})]),b,E]),g,s("details",null,[_,e(n,{color:"gray"},{default:o(()=>[a("另外一些需要知道的")]),_:1}),f]),C])}const V=t(i,[["render",R]]);export{P as __pageData,V as default};
