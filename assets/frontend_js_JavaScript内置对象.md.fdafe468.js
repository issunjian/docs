import{_ as a,o as e,c as t,V as r}from"./chunks/framework.c6d8cbec.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/js/JavaScript内置对象.md","filePath":"frontend/js/JavaScript内置对象.md"}'),o={name:"frontend/js/JavaScript内置对象.md"},n=r(`<h2 id="内置对象" tabindex="-1">内置对象 <a class="header-anchor" href="#内置对象" aria-label="Permalink to &quot;内置对象&quot;">​</a></h2><h2 id="速览" tabindex="-1">速览 <a class="header-anchor" href="#速览" aria-label="Permalink to &quot;速览&quot;">​</a></h2><p>浏览器中<code>window</code>和<code>self</code>指代全局对象，node环境中用<code>global</code>，webWorker中用<code>self</code>。js中的“全局变量”都是全局对象的属性，在浏览器中是window对象的属性。</p><h3 id="math" tabindex="-1">Math <a class="header-anchor" href="#math" aria-label="Permalink to &quot;Math&quot;">​</a></h3><h4 id="常量" tabindex="-1">常量 <a class="header-anchor" href="#常量" aria-label="Permalink to &quot;常量&quot;">​</a></h4><p>E、PI、LN2（loge2或In2）、LN10、SQRT1_2（2的平方根的倒数）、SQRT2、LOG2E、LOG10E。</p><p>结合<code>with(Math){}</code>就不用在所有方法前加Math了～</p><table><thead><tr><th>方法</th><th>简介</th></tr></thead><tbody><tr><td>Math.pow(x, n)</td><td>幂运算。</td></tr><tr><td>Math.ceil()</td><td>向上取整。</td></tr><tr><td>Math.floor()</td><td>向下取整。</td></tr><tr><td>Math.round()</td><td>四舍五入。</td></tr><tr><td>Math.log()</td><td>以e为底取对数。</td></tr><tr><td>Math.sqrt()</td><td>开方。</td></tr><tr><td>Math.sin()</td><td></td></tr><tr><td>Math.cos()</td><td></td></tr><tr><td>Math.tan()</td><td></td></tr><tr><td>Math.random()</td><td>得到一个0～1之间的随机数。</td></tr><tr><td>Math.exp()</td><td>e做幂运算。</td></tr><tr><td>Math.max()</td><td></td></tr><tr><td>Math.min()</td><td></td></tr><tr><td>Math.acos()</td><td></td></tr><tr><td>Math.asin()</td><td></td></tr><tr><td>Math.atan()</td><td></td></tr><tr><td>Math.atan2()</td><td></td></tr></tbody></table><h3 id="json" tabindex="-1">JSON <a class="header-anchor" href="#json" aria-label="Permalink to &quot;JSON&quot;">​</a></h3><p>JSON不是JS，也用在很多其他语言中，作为一种简单的传递对象数据的格式。</p><h4 id="json-parse" tabindex="-1">JSON.parse() <a class="header-anchor" href="#json-parse" aria-label="Permalink to &quot;JSON.parse()&quot;">​</a></h4><p>将标准JSON格式的字符串转为JS对象，不符合格式会提示‘unexpected token&#39;，最常见的是&#39;unexpected token u&#39;，也就是undefined，因此写接口一定要注意将未知类型转换成安全类型。</p><h4 id="json-stringify" tabindex="-1">JSON.stringify() <a class="header-anchor" href="#json-stringify" aria-label="Permalink to &quot;JSON.stringify()&quot;">​</a></h4><p>将JS对象转为JSON格式，结合parse可以用于对象深拷贝。</p><h3 id="date" tabindex="-1">Date <a class="header-anchor" href="#date" aria-label="Permalink to &quot;Date&quot;">​</a></h3><h4 id="实例化date对象" tabindex="-1">实例化Date对象 <a class="header-anchor" href="#实例化date对象" aria-label="Permalink to &quot;实例化Date对象&quot;">​</a></h4><p><code>let now = new Date()</code></p><p>返回Date对象，控制台输出如<code>2019-08-16T06:06:36.238Z</code>。</p><h4 id="仅获取表示时间的字符串" tabindex="-1">仅获取表示时间的字符串 <a class="header-anchor" href="#仅获取表示时间的字符串" aria-label="Permalink to &quot;仅获取表示时间的字符串&quot;">​</a></h4><p><code>let now = Date()</code></p><p>如果不作为构造函数，那么Date()仅返回字符串如<code>&#39;Fri Aug 16 2019 13:49:46 GMT+0800 (China Standard Time)&#39;</code>。</p><table><thead><tr><th>方法</th><th>简介</th></tr></thead><tbody><tr><td>set/getFullYear</td><td>从Date对象返回年份（如2019）。</td></tr><tr><td>set/getDate</td><td>从Date对象返回天数（1～31）。</td></tr><tr><td>set/getDay</td><td>从Date对象返回星期（0～6，0是星期天）。</td></tr><tr><td>set/getHours</td><td>从Date对象返回小时（0～23）。</td></tr><tr><td>set/getMinutes</td><td>从Date对象返回分钟（0～59）。</td></tr><tr><td>set/getSeconds</td><td>从Date对象返回秒数（0～59）。</td></tr><tr><td>set/getMiliseconds</td><td>从Date对象返回毫秒数（0～999）。</td></tr><tr><td>set/getTime</td><td>从Date对象返回返回从1970年1月1日0时起的毫秒数。与valueOf方法返回一致。</td></tr></tbody></table><h4 id="todatestring" tabindex="-1">toDateString <a class="header-anchor" href="#todatestring" aria-label="Permalink to &quot;toDateString&quot;">​</a></h4><p>把Date对象的日期部分转化成可读性强的字符串，如<code>Fri Aug 16 2019</code>。</p><h4 id="tostring" tabindex="-1">toString <a class="header-anchor" href="#tostring" aria-label="Permalink to &quot;toString&quot;">​</a></h4><p>把Date转化成可读性强的字符串，如<code>Fri Aug 16 2019 14:06:36 GMT+0800 (China Standard Time)</code>，格式与直接使用Date()一致。</p><h4 id="date-utc" tabindex="-1">Date.UTC <a class="header-anchor" href="#date-utc" aria-label="Permalink to &quot;Date.UTC&quot;">​</a></h4><p><strong>静态方法。</strong> UTC( Universal Coordinated Time )即国际协调时间，与GMT（格林尼治时）相同，此方法接受从年到毫秒的7个参数，返回距1970年1月1日0时的毫秒数。此外，从get/set(UTC)FullYear到get/set(UTC)Miliseconds也都有对应的UTC方法。</p><h3 id="regexp" tabindex="-1"><a href="http://manual.local.guohere.com/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" target="_blank" rel="noreferrer">RegExp</a> <a class="header-anchor" href="#regexp" aria-label="Permalink to &quot;[RegExp](http://manual.local.guohere.com/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html)&quot;">​</a></h3><h3 id="array" tabindex="-1"><a href="#数组-array">Array</a> <a class="header-anchor" href="#array" aria-label="Permalink to &quot;[Array](#%E6%95%B0%E7%BB%84-array)&quot;">​</a></h3><h3 id="string" tabindex="-1"><a href="#字符串-string">String</a> <a class="header-anchor" href="#string" aria-label="Permalink to &quot;[String](#%E5%AD%97%E7%AC%A6%E4%B8%B2-string)&quot;">​</a></h3><h3 id="global" tabindex="-1">Global <a class="header-anchor" href="#global" aria-label="Permalink to &quot;Global&quot;">​</a></h3><h2 id="数组-array" tabindex="-1">数组 Array <a class="header-anchor" href="#数组-array" aria-label="Permalink to &quot;数组 Array&quot;">​</a></h2><h3 id="数组属性" tabindex="-1">数组属性 <a class="header-anchor" href="#数组属性" aria-label="Permalink to &quot;数组属性&quot;">​</a></h3><h4 id="length" tabindex="-1">length <a class="header-anchor" href="#length" aria-label="Permalink to &quot;length&quot;">​</a></h4><p>数组长度/元素个数。</p><h4 id="constructor" tabindex="-1">constructor <a class="header-anchor" href="#constructor" aria-label="Permalink to &quot;constructor&quot;">​</a></h4><p>构造函数。</p><h4 id="prototype" tabindex="-1">prototype <a class="header-anchor" href="#prototype" aria-label="Permalink to &quot;prototype&quot;">​</a></h4><p>通过在原型上定义方法，让所有数组都可以使用自定义的方法。</p><h3 id="数组方法" tabindex="-1">数组方法 <a class="header-anchor" href="#数组方法" aria-label="Permalink to &quot;数组方法&quot;">​</a></h3><h4 id="变异方法与非变异方法-mutation-method-and-non-mutation-method" tabindex="-1">变异方法与非变异方法 mutation method and non-mutation method <a class="header-anchor" href="#变异方法与非变异方法-mutation-method-and-non-mutation-method" aria-label="Permalink to &quot;变异方法与非变异方法 mutation method and non-mutation method&quot;">​</a></h4><p>有些方法改变原数组，称为变异方法；也有些方法返回一个新数组，称为非变异方法；剩下的那些方法不改变数组也不返回数组。下面用M（Mutation）和N（Non-mutation）标记变异与非变异方法。扩展运算符<code>...</code>可以浅拷贝数组，在一些场景下可以将变异方法作为非变异方法使用。</p><h4 id="map-n" tabindex="-1">map N <a class="header-anchor" href="#map-n" aria-label="Permalink to &quot;map N&quot;">​</a></h4><p><code>Array.prototype.map(function(currentValue,index,arr),thisValue)</code></p><p>map的作用是按回调函数的规则从原数组映射出一个新数组（作为返回值）。</p><p>从函数原型可以看出，回调函数可以得到当前元素的值、索引、原数组，处理后的值应作为返回值，还能传入this对象。</p><p>currentValue和index以及arr是只读的，但arr是对象，currentValue也可能是对象，此时可以修改属性或执行方法。</p><h4 id="foreach" tabindex="-1">forEach <a class="header-anchor" href="#foreach" aria-label="Permalink to &quot;forEach&quot;">​</a></h4><p><code>Array.prototype.forEach(function(currentValue, index, arr), thisValue)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>function(currentValue, index, arr)</td><td>必需。currentValue即当前元素（必需），index即索引值，arr即数组对象。</td></tr><tr><td>thisValue</td><td>传入的this值，默认undefined</td></tr></tbody></table><p>无返回值，不能改变数组。如果数组成员是对象，当然可以更改其属性，因为数组只存了对象的指针。</p><h4 id="reduce" tabindex="-1">reduce <a class="header-anchor" href="#reduce" aria-label="Permalink to &quot;reduce&quot;">​</a></h4><p><code>Array.prototype.reduce(function(total, currentValue, index, arr), initialValue)</code></p><p>迭代器，reduce从左到右遍历数组并接受一个函数作为累积器。这个函数接受上次迭代的返回值（total，而初始值可以用initialValue指定），并最终得到一个返回值作为reduce的返回值。</p><p>使用reduce可以组织多个函数作为函数链，称为compose。</p><h4 id="reduceright" tabindex="-1">reduceRight <a class="header-anchor" href="#reduceright" aria-label="Permalink to &quot;reduceRight&quot;">​</a></h4><p>与reduce相似，但从右向左迭代。</p><h4 id="filter-n" tabindex="-1">filter N <a class="header-anchor" href="#filter-n" aria-label="Permalink to &quot;filter N&quot;">​</a></h4><p><code>Array.prototype.filter(function(currentValue, index, arr), thisValue)</code></p><p>过滤器，返回所有符合条件的项（回调函数中返回true）。不能改变数组。</p><h4 id="push、pop-m" tabindex="-1">push、pop M <a class="header-anchor" href="#push、pop-m" aria-label="Permalink to &quot;push、pop M&quot;">​</a></h4><p><code>Array.prototype.push(arg1, arg2, ...)</code></p><p><code>Array.prototype.pop()</code></p><p>栈方法。进栈和出栈。进栈返回新数组长度，出栈返回出栈元素的值。</p><h4 id="shift、unshift-m" tabindex="-1">shift、unshift M <a class="header-anchor" href="#shift、unshift-m" aria-label="Permalink to &quot;shift、unshift M&quot;">​</a></h4><p><code>Array.prototype.shift()</code></p><p><code>Array.prototype.unshift(arg1, arg2 , ...)</code></p><p>shift即出队列，删除数组第一项并将其作为返回值，unshift则是将item塞回队列（成为新数组的第0项、第1项等等）。push和shift方法结合使用则数组可以作为队列使用。</p><h4 id="slice-n" tabindex="-1">slice N <a class="header-anchor" href="#slice-n" aria-label="Permalink to &quot;slice N&quot;">​</a></h4><p><code>Array.prototype.slice(start, end)</code></p><p>切片的意思，即返回数组的一部分。start和end指定了开始和结束的数组下标，他们都接受负数值，-n代表从末尾向前数的第n个元素。</p><h4 id="find-es6" tabindex="-1">find ES6 <a class="header-anchor" href="#find-es6" aria-label="Permalink to &quot;find ES6&quot;">​</a></h4><p><code>Array.prototype.find(function(currentValue, index, arr), thisValue)</code></p><p>接受函数作为条件，返回第一个函数返回true的数组项。</p><h4 id="findindex-es6" tabindex="-1">findIndex ES6 <a class="header-anchor" href="#findindex-es6" aria-label="Permalink to &quot;findIndex ES6&quot;">​</a></h4><p>和find用法一致，返回第一个函数返回true的数组项的索引。如果找不到返回-1。</p><h4 id="indexof" tabindex="-1">indexOf <a class="header-anchor" href="#indexof" aria-label="Permalink to &quot;indexOf&quot;">​</a></h4><p><code>Array.prototype.indexOf(item, start)</code></p><p>indexOf接受一个值直接与数组项进行比较，返回第一次匹配的项的索引，如果找不到返回-1。start可以指定从哪一项开始搜索。</p><h4 id="lastindexof" tabindex="-1">lastIndexOf <a class="header-anchor" href="#lastindexof" aria-label="Permalink to &quot;lastIndexOf&quot;">​</a></h4><p><code>Array.prototype.lastIndexOf(item,start)</code></p><p>与indexOf相似，但返回最后一个匹配项。</p><h4 id="sort-m" tabindex="-1">sort M <a class="header-anchor" href="#sort-m" aria-label="Permalink to &quot;sort M&quot;">​</a></h4><p><code>Array.prototype.sort([compareFunction(firstEl,secondEl)])</code></p><p>排序。修改原数组，返回对原数组的引用（即修改后的数组）。</p><p>比较函数是可选的，接受比较的第一个元素和第二个元素，如果返回结果小于0，a将被排在b前面，如果大于0，b将被排在a前面，如果等于0，顺序不变（遗憾的是浏览器不一定遵守）。</p><p>默认的sort将元素转为字符串并比较编码值大小。</p><p>TIP</p><p>sort方法内部使用对部分场景优化后的快速排序。</p><h4 id="reverse-m" tabindex="-1">reverse M <a class="header-anchor" href="#reverse-m" aria-label="Permalink to &quot;reverse M&quot;">​</a></h4><p><code>Array.prototype.reverse()</code></p><p>翻转数组。改变原数组，返回其引用。</p><h4 id="splice-m" tabindex="-1">splice M <a class="header-anchor" href="#splice-m" aria-label="Permalink to &quot;splice M&quot;">​</a></h4><p><code>Array.prototype.splice(index[, howmany, item1, item2, ...])</code></p><p>Splice的中文意为铰接、粘接，该方法可以自由地从数组添加、删除元素。</p><p>第一个参数index用于确定<strong>位置</strong>，从哪里开始操作；第二个参数决定从下标为index的元素起，<strong>删除</strong>几个元素；后面的参数将会<strong>添加</strong>到数组中从index开始的位置上。</p><h4 id="concat-n" tabindex="-1">concat N <a class="header-anchor" href="#concat-n" aria-label="Permalink to &quot;concat N&quot;">​</a></h4><p><code>Array.prototype.concat([arr1, arr2, ...])</code></p><p>concat意为串联，即将两个或多个数组连接在一起并返回。参数为空时返回原数组拷贝，常用于复制数组。</p><h4 id="join" tabindex="-1">join <a class="header-anchor" href="#join" aria-label="Permalink to &quot;join&quot;">​</a></h4><p><code>Array.prototype.join([separator=&quot;,&quot;])</code></p><p>join返回所有数组元素转换成的一个字符串，默认用半角逗号分隔，和toString表现一致，也可以自己指定分隔符。</p><h4 id="fill-m-es6" tabindex="-1">fill M ES6 <a class="header-anchor" href="#fill-m-es6" aria-label="Permalink to &quot;fill M ES6&quot;">​</a></h4><p><code>Array.prototype.fill(value[, start=0[, end=array.length]])</code></p><p>以固定值填充数组。start和end指定填充区间，array[end]不会被填充。</p><h4 id="copywithin-m" tabindex="-1">copyWithin M <a class="header-anchor" href="#copywithin-m" aria-label="Permalink to &quot;copyWithin M&quot;">​</a></h4><p><code>Array.prototype.copyWithin(targetIndex[, start[, end=array.length]])</code></p><p>targetIndex确定了要复制到的位置，而start与end决定了被复制元素的范围。这种复制不是插入，而是覆盖原有元素，并且不改变数组长度。</p><h4 id="includes-es6" tabindex="-1">includes ES6 <a class="header-anchor" href="#includes-es6" aria-label="Permalink to &quot;includes ES6&quot;">​</a></h4><p><code>Array.prototype.includes(searchElement[, fromIndex])</code></p><p>第一个参数传入值，第二个参数确定从哪开始搜索，-n代表倒数第n项。如果数组包括该值则返回true，否则返回false。</p><h4 id="from-es6" tabindex="-1">from ES6 <a class="header-anchor" href="#from-es6" aria-label="Permalink to &quot;from ES6&quot;">​</a></h4><p><code>Array.prototype.from(object[, mapFunction[, thisValue]])</code></p><p>object如果是拥有length属性或可迭代的对象，通过此方法能够返回一个数组。不符合要求的对象会导致from方法返回空数组。</p><h4 id="every" tabindex="-1">every <a class="header-anchor" href="#every" aria-label="Permalink to &quot;every&quot;">​</a></h4><p><code>Array.prototype.every(function(currentValue,index,arr),thisValue)</code></p><p>返回Boolean值，当且仅当所有元素传入回调函数的返回结果为true时every的结果为true。</p><h4 id="some" tabindex="-1">some <a class="header-anchor" href="#some" aria-label="Permalink to &quot;some&quot;">​</a></h4><p>和every用法一致，有一个元素传入回调的结果为true即返回true并不再检验之后的元素。</p><h4 id="entries-es6" tabindex="-1">entries ES6 <a class="header-anchor" href="#entries-es6" aria-label="Permalink to &quot;entries ES6&quot;">​</a></h4><p><code>Array.prototype.entries()</code></p><p>从数组返回一个可迭代对象(Array Iterator)。如果不明白可以先了解function generator。</p><h4 id="keys-es6" tabindex="-1">keys ES6 <a class="header-anchor" href="#keys-es6" aria-label="Permalink to &quot;keys ES6&quot;">​</a></h4><p><code>Array.prototype.keys()</code></p><p>创建key的可迭代对象，而数组的key是0、1、2、3...</p><h4 id="isarray" tabindex="-1">isArray <a class="header-anchor" href="#isarray" aria-label="Permalink to &quot;isArray&quot;">​</a></h4><p><code>Array.prototype.isArray(obj)</code></p><p>顾名思义，判断是否数组，返回Boolean值。</p><h4 id="tostring-1" tabindex="-1">toString <a class="header-anchor" href="#tostring-1" aria-label="Permalink to &quot;toString&quot;">​</a></h4><p>其实和join类似，返回字符串，不过不带参数，只能以逗号分隔。</p><h4 id="valueof" tabindex="-1">valueOf <a class="header-anchor" href="#valueof" aria-label="Permalink to &quot;valueOf&quot;">​</a></h4><p>数组对象的默认方法，返回数组原始值。不必手动调用。</p><h2 id="对象-object-✏️" tabindex="-1">对象 Object ✏️ <a class="header-anchor" href="#对象-object-✏️" aria-label="Permalink to &quot;对象 Object ✏️&quot;">​</a></h2><h3 id="认识对象" tabindex="-1">认识对象 <a class="header-anchor" href="#认识对象" aria-label="Permalink to &quot;认识对象&quot;">​</a></h3><p>虽然<code>{a:1,b:2}</code>看起来简单，但其后深藏功与名。首先，Object对象具有Object.prototype方法，同时，对象的属性背后还有属性描述符，属性也分可否枚举，属性也可以是对象，甚至可以是自身<code>{ obj: [Circular] }</code>。</p><h3 id="可枚举属性-enumerable-properties" tabindex="-1">可枚举属性 Enumerable Properties <a class="header-anchor" href="#可枚举属性-enumerable-properties" aria-label="Permalink to &quot;可枚举属性 Enumerable Properties&quot;">​</a></h3><p>Object.keys()、for...in、JSON.stringily()都只处理可枚举属性，可以用Object.propertyIsEnumerable()方法判断属性是否可枚举。</p><p>定义一个不可枚举属性：</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">let obj = {}</span></span>
<span class="line"><span style="color:#f6f6f4;">obj.defineProperty(obj,&quot;attr&quot;,{</span></span>
<span class="line"><span style="color:#f6f6f4;">	value:&quot;bread&quot;,</span></span>
<span class="line"><span style="color:#f6f6f4;">	enumerable:false</span></span>
<span class="line"><span style="color:#f6f6f4;">})</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">let obj = {}</span></span>
<span class="line"><span style="color:#24292e;">obj.defineProperty(obj,&quot;attr&quot;,{</span></span>
<span class="line"><span style="color:#24292e;">	value:&quot;bread&quot;,</span></span>
<span class="line"><span style="color:#24292e;">	enumerable:false</span></span>
<span class="line"><span style="color:#24292e;">})</span></span></code></pre></div><p>待填坑</p><p>如果属性存在于原型</p><h3 id="对象拷贝" tabindex="-1">对象拷贝 <a class="header-anchor" href="#对象拷贝" aria-label="Permalink to &quot;对象拷贝&quot;">​</a></h3><p>除了接下来介绍的Object.assign()，还可以用扩展运算符复制对象，以及JSON.parse(JSON.stringify())深拷贝对象（不支持循环引用与方法），对于数组可以用concat()。</p><h3 id="object-assign" tabindex="-1">Object.assign() <a class="header-anchor" href="#object-assign" aria-label="Permalink to &quot;Object.assign()&quot;">​</a></h3><p><code>Object.assign(target, ...source)</code></p><p>（浅）拷贝数组，将所有可枚举属性从一个或多个源对象复制到目标对象，并将其作为返回值。需要注意它调用源对象的Setter和目标对象的Getter，如果合并源包括Getter或目标包括Setter，那么应该使用Object.getOwnPropertyDescriptor()与Object.defineProperty()准确复制属性定义。</p><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h3><h2 id="字符串-string" tabindex="-1">字符串 String <a class="header-anchor" href="#字符串-string" aria-label="Permalink to &quot;字符串 String&quot;">​</a></h2><p>string是JS基础类型之一，String对象为操作string提供了丰富的方法。</p><h3 id="字符串方法特性" tabindex="-1">字符串方法特性 <a class="header-anchor" href="#字符串方法特性" aria-label="Permalink to &quot;字符串方法特性&quot;">​</a></h3><p>字符串方法<strong>均返回新值</strong>，不改变原字符串。</p><h3 id="扩展字符串的方法" tabindex="-1">扩展字符串的方法 <a class="header-anchor" href="#扩展字符串的方法" aria-label="Permalink to &quot;扩展字符串的方法&quot;">​</a></h3><h4 id="concat" tabindex="-1">concat() <a class="header-anchor" href="#concat" aria-label="Permalink to &quot;concat()&quot;">​</a></h4><p><code>String.prototype.concat([str1[, str2[, ...]]])</code></p><p>连接多个字符串并作为结果返回。</p><h4 id="repeat-es6" tabindex="-1">repeat() ES6 <a class="header-anchor" href="#repeat-es6" aria-label="Permalink to &quot;repeat() ES6&quot;">​</a></h4><p><code>String.prototype.repeat(count=0)</code></p><p>将字符串复制指定次数合并成一个字符串返回，默认count=0即返回空字符串。</p><h3 id="获取子串的方法" tabindex="-1">获取子串的方法 <a class="header-anchor" href="#获取子串的方法" aria-label="Permalink to &quot;获取子串的方法&quot;">​</a></h3><h4 id="substring" tabindex="-1">substring() <a class="header-anchor" href="#substring" aria-label="Permalink to &quot;substring()&quot;">​</a></h4><p><code>String.prototype.substring(from[, to=array.length])</code></p><p>给定两个下标，截取部分字符串作为返回值，arr[to]不会被截取。</p><h4 id="substr" tabindex="-1">substr() <a class="header-anchor" href="#substr" aria-label="Permalink to &quot;substr()&quot;">​</a></h4><p><code>String.prototype.substr(start[, length=array.length-start])</code></p><p>截取从arr[start]开始的length个字符作为返回值，不指定length则截取到结尾。</p><h4 id="slice" tabindex="-1">slice() <a class="header-anchor" href="#slice" aria-label="Permalink to &quot;slice()&quot;">​</a></h4><p><code>String.prototype.slice(start[, end=array.length])</code></p><p>截取字符串片段，不包括arr[end]，end可以为负（-n代表倒数第n个）。</p><h4 id="charat" tabindex="-1">charAt() <a class="header-anchor" href="#charat" aria-label="Permalink to &quot;charAt()&quot;">​</a></h4><p><code>String.prototype.charAt(index=0)</code></p><p>接受index并返回str[index]。</p><h3 id="与正则相关的方法" tabindex="-1">与正则相关的方法 <a class="header-anchor" href="#与正则相关的方法" aria-label="Permalink to &quot;与正则相关的方法&quot;">​</a></h3><h4 id="replace" tabindex="-1">replace() <a class="header-anchor" href="#replace" aria-label="Permalink to &quot;replace()&quot;">​</a></h4><p><code>String.prototype.replace(searchValue, newValue)</code></p><p>接受字符串或RegExp进行匹配和替换。如果是字符串只能替换第一次匹配的子字符串，正则表达式可以替换所有的项（<code>/str/g</code>）。</p><h4 id="match" tabindex="-1">match() <a class="header-anchor" href="#match" aria-label="Permalink to &quot;match()&quot;">​</a></h4><p><code>String.prototype.match(RegExp)</code></p><p>接受一个正则表达式，返回结果数组或null。</p><h4 id="matchall-es6" tabindex="-1">matchAll() ES6 <a class="header-anchor" href="#matchall-es6" aria-label="Permalink to &quot;matchAll() ES6&quot;">​</a></h4><p>接受一个正则表达式，返回所有匹配。返回的结果具有Iterator接口，但不是数组（可以转为数组）。</p><h4 id="search" tabindex="-1">search() <a class="header-anchor" href="#search" aria-label="Permalink to &quot;search()&quot;">​</a></h4><p><code>String.prototype.search(searchValue)</code></p><p>接受字符串或正则表达式，返回第一次匹配的子字符串起始位置的下标，找不到返回-1。</p><h4 id="split" tabindex="-1">split() <a class="header-anchor" href="#split" aria-label="Permalink to &quot;split()&quot;">​</a></h4><p><code>String.prototype.split([separator[, limit]])</code></p><p>将字符串按分隔符拆成数组，separator可以是字符串或RegExp，默认不会拆分，传入&quot;&quot;空字符串可拆分每一个字符，limit限制返回子字符串的最大数量（达到limit个子字符串后split即返回）。</p><h3 id="搜索、检验字符串的方法" tabindex="-1">搜索、检验字符串的方法 <a class="header-anchor" href="#搜索、检验字符串的方法" aria-label="Permalink to &quot;搜索、检验字符串的方法&quot;">​</a></h3><h4 id="indexof-1" tabindex="-1">indexOf() <a class="header-anchor" href="#indexof-1" aria-label="Permalink to &quot;indexOf()&quot;">​</a></h4><p><code>String.prototype.indexOf(searchValue[, start])</code></p><p>与search相似，但只接受字符串，可以给一个开始搜索的位置。注意它不会来回找，如果在start到end区间都没有匹配项就返回-1。</p><h4 id="lastindexof-1" tabindex="-1">lastIndexOf() <a class="header-anchor" href="#lastindexof-1" aria-label="Permalink to &quot;lastIndexOf()&quot;">​</a></h4><p><code>String.prototype.lastIndexOf(searchValue[, start])</code></p><p>与indexOf的区别在于，该方法从后往前找，能找到最后一次出现的位置。</p><h4 id="includes-es6-1" tabindex="-1">includes() ES6 <a class="header-anchor" href="#includes-es6-1" aria-label="Permalink to &quot;includes() ES6&quot;">​</a></h4><p><code>String.prototype.includes(searchValue[, start])</code></p><p>与indexOf类似，但不返回子字符串位置，只返回Boolean值。</p><h4 id="startswith-es6" tabindex="-1">startsWith() ES6 <a class="header-anchor" href="#startswith-es6" aria-label="Permalink to &quot;startsWith() ES6&quot;">​</a></h4><p><code>String.prototype.startsWith(value[, start=0])</code></p><p>用于判断字符串是否以value开头。不过start可以自定义，也就是判断字符串start处开始的子串是否匹配字符串value。返回结果为Boolean值。</p><h4 id="endswith-es6" tabindex="-1">endsWith() ES6 <a class="header-anchor" href="#endswith-es6" aria-label="Permalink to &quot;endsWith() ES6&quot;">​</a></h4><p>与startsWith相似，判断字符串尾部是否与参数匹配。但endsWith的第二个参数表示以此处作为结束的位置，例如<code>Apple Computer</code>可以匹配<code>Apple</code>，只需要<code>endsWith(&#39;Apple&#39;,5)</code>。</p><h3 id="修饰字符串的方法" tabindex="-1">修饰字符串的方法 <a class="header-anchor" href="#修饰字符串的方法" aria-label="Permalink to &quot;修饰字符串的方法&quot;">​</a></h3><h4 id="trim" tabindex="-1">trim() <a class="header-anchor" href="#trim" aria-label="Permalink to &quot;trim()&quot;">​</a></h4><p>ES6新增了<code>trimStart() trimEnd() trimLeft() trimRight()</code>方法。</p><p>去除字符串两边的空格作为返回值。trimStart和trimLeft只去除左边的空格，trimEnd和trimRight相反。</p><h4 id="tolowercase" tabindex="-1">toLowerCase() <a class="header-anchor" href="#tolowercase" aria-label="Permalink to &quot;toLowerCase()&quot;">​</a></h4><p>将大写转换成小写字母并返回。</p><h4 id="touppercase" tabindex="-1">toUpperCase() <a class="header-anchor" href="#touppercase" aria-label="Permalink to &quot;toUpperCase()&quot;">​</a></h4><p>将小写转换成大写字母并返回。</p><h4 id="padstart-es6" tabindex="-1">padStart() ES6 <a class="header-anchor" href="#padstart-es6" aria-label="Permalink to &quot;padStart() ES6&quot;">​</a></h4><p>补全字符串。第一个参数是新的字符串长度，第二个参数是用于补全的字符串，该字符串将被填充到新字符串头部。</p><h4 id="padend-es6" tabindex="-1">padEnd() ES6 <a class="header-anchor" href="#padend-es6" aria-label="Permalink to &quot;padEnd() ES6&quot;">​</a></h4><p>与padStart相似，但填充到尾部。</p><h3 id="与码点相关的方法" tabindex="-1">与码点相关的方法 <a class="header-anchor" href="#与码点相关的方法" aria-label="Permalink to &quot;与码点相关的方法&quot;">​</a></h3><h4 id="charcodeat" tabindex="-1">charCodeAt() <a class="header-anchor" href="#charcodeat" aria-label="Permalink to &quot;charCodeAt()&quot;">​</a></h4><p><code>String.prototype.charCodeAt(index=0)</code></p><p>接受index并返回str[index]的Unicode编码。</p><h4 id="codepointat-es6" tabindex="-1">codePointAt() ES6 <a class="header-anchor" href="#codepointat-es6" aria-label="Permalink to &quot;codePointAt() ES6&quot;">​</a></h4><p>取回字符码点，用于弥补charCodeAt不支持大于0xFFFF码点的不足。</p><h4 id="normalize-es6" tabindex="-1">normalize() ES6 <a class="header-anchor" href="#normalize-es6" aria-label="Permalink to &quot;normalize() ES6&quot;">​</a></h4><p>例如欧洲语言有时会用两个码点组合成一个字符，也可以直接表示一个字符，但两者对js而言并不相等，可以通过对两者normalize化使两者相等。</p><h3 id="string对象的方法" tabindex="-1">String对象的方法 <a class="header-anchor" href="#string对象的方法" aria-label="Permalink to &quot;String对象的方法&quot;">​</a></h3><h4 id="string-raw-es6" tabindex="-1">String.raw() ES6 <a class="header-anchor" href="#string-raw-es6" aria-label="Permalink to &quot;String.raw() ES6&quot;">​</a></h4><p>返回转义前的字符串，比如下划线<code>\\</code>会被转成两个下划线<code>\\\\</code>。</p><h4 id="string-fromcharcode" tabindex="-1">String.fromCharCode() <a class="header-anchor" href="#string-fromcharcode" aria-label="Permalink to &quot;String.fromCharCode()&quot;">​</a></h4><p><code>String.fromCharCode([code1[, code2[, ...]]])</code></p><p>接受一个或多个字符编码（0xFFFF内），返回创建的字符串。</p><h4 id="string-fromcodepoint-es6" tabindex="-1">String.fromCodePoint() ES6 <a class="header-anchor" href="#string-fromcodepoint-es6" aria-label="Permalink to &quot;String.fromCodePoint() ES6&quot;">​</a></h4><p>弥补fromCharCode的不足，可以接受大于0xFFFF的码点。</p><h3 id="unicode表示法" tabindex="-1">Unicode表示法 <a class="header-anchor" href="#unicode表示法" aria-label="Permalink to &quot;Unicode表示法&quot;">​</a></h3><p>JS允许以<code>\\uXXXX</code>的形式显示一个字符，但不支持大于0xFFFF的数值，ES6中支持以<code>\\u{XX...}</code>的形式显示码点更大的字符。</p><h3 id="iterator接口-es6" tabindex="-1">Iterator接口 ES6 <a class="header-anchor" href="#iterator接口-es6" aria-label="Permalink to &quot;Iterator接口 ES6&quot;">​</a></h3><p>对于字符串来说，遍历的结果是每一个字符。</p><h3 id="模板字符串-es6" tabindex="-1"><a href="http://manual.local.guohere.com/JS/ES6.html#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F" target="_blank" rel="noreferrer">模板字符串</a> ES6 <a class="header-anchor" href="#模板字符串-es6" aria-label="Permalink to &quot;[模板字符串](http://manual.local.guohere.com/JS/ES6.html#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F) ES6&quot;">​</a></h3><h4 id="基于模板字符串的模板引擎" tabindex="-1">基于模板字符串的模板引擎 <a class="header-anchor" href="#基于模板字符串的模板引擎" aria-label="Permalink to &quot;基于模板字符串的模板引擎&quot;">​</a></h4><p>待填坑</p><h2 id="更多" tabindex="-1">更多 <a class="header-anchor" href="#更多" aria-label="Permalink to &quot;更多&quot;">​</a></h2><h3 id="uri编码" tabindex="-1">URI编码 <a class="header-anchor" href="#uri编码" aria-label="Permalink to &quot;URI编码&quot;">​</a></h3><p>encodeURI()、decodeURI()转义不属于uri本身的字符，比如空格会被转换为<code>%20</code>，但<code>/</code>不会被转换。这两个方法转义URI本身。</p><p>encodeURIComponent()、decodeURIComponent()转义所有特殊字符的编码，像<code>http://</code>会被转换成<code>http%3A%2F%2F</code>。这两个方法用于转义URI中的参数。</p><h3 id="eval" tabindex="-1">eval() <a class="header-anchor" href="#eval" aria-label="Permalink to &quot;eval()&quot;">​</a></h3><p>动态执行javascript代码。eval内执行的代码虽然不会被提升（hoisting），但也能访问当前环境。</p><h3 id="异步" tabindex="-1">异步 <a class="header-anchor" href="#异步" aria-label="Permalink to &quot;异步&quot;">​</a></h3><p>setTimeout(handler: any=&gt;any, delay: number)用于延时执行代码。返回值是一个Timeout对象。</p><p>setInterval(handler: any=&gt;any, interval: number)用于间隔一定时间重复执行代码，第一次执行在一次interval后。返回值是一个Timeout对象。</p><p>clearTimeout()与clearInterval()接受一个Timeout对象，用于中止异步操作。</p><h3 id="error构造函数" tabindex="-1">Error构造函数 <a class="header-anchor" href="#error构造函数" aria-label="Permalink to &quot;Error构造函数&quot;">​</a></h3><p>包括Error()、EvalError()、RangeError()、ReferenceError()、SyntaxError()、TypeError()、URIError()。</p>`,249),i=[n];function d(h,l,s,c,p,u){return e(),t("div",null,i)}const m=a(o,[["render",d]]);export{f as __pageData,m as default};
