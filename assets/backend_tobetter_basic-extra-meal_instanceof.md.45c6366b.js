import{_ as s,o as a,c as n,V as p}from"./chunks/framework.c6d8cbec.js";const g=JSON.parse('{"title":"掌握 Java instanceof关键字","description":"本文详细讲解了Java中的instanceof关键字，包括其作用、用法、使用场景以及注意事项。文章通过实例解析，帮助读者深入理解instanceof关键字在Java编程中的重要性，提高编程水平和技巧。","frontmatter":{"title":"掌握 Java instanceof关键字","shortTitle":"Java instanceof关键字","category":["Java核心"],"tag":["Java重要知识点"],"description":"本文详细讲解了Java中的instanceof关键字，包括其作用、用法、使用场景以及注意事项。文章通过实例解析，帮助读者深入理解instanceof关键字在Java编程中的重要性，提高编程水平和技巧。","head":[["meta",{"name":"keywords","content":"Java,instanceof,instanceof关键字"}]]},"headers":[],"relativePath":"backend/tobetter/basic-extra-meal/instanceof.md","filePath":"backend/tobetter/basic-extra-meal/instanceof.md"}'),l={name:"backend/tobetter/basic-extra-meal/instanceof.md"},o=p(`<h1 id="_5-17-java-instanceof关键字" tabindex="-1">5.17 Java instanceof关键字 <a class="header-anchor" href="#_5-17-java-instanceof关键字" aria-label="Permalink to &quot;5.17 Java instanceof关键字&quot;">​</a></h1><p>“三妹，今天我们来过一个非常简单的知识点，instanceof关键字。”</p><p>“用不着哥你来讲了，今天就换个形式，我来讲给你听。”三妹雄赳赳气昂昂地说。</p><p>instanceof 关键字的用法其实很简单：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F6F6F4;">(object) </span><span style="color:#F286C4;">instanceof</span><span style="color:#F6F6F4;"> (type)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">(object) </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> (type)</span></span></code></pre></div><p>用意也非常简单，判断对象是否符合指定的类型，结果要么是 true，要么是 false。在<a href="https://tobebetterjavaer.com/io/serialize.html" target="_blank" rel="noreferrer">反序列化</a>的时候，instanceof 操作符还是蛮常用的，因为这时候我们不太确定对象属不属于指定的类型，如果不进行判断的话，就容易抛出 ClassCastException 异常。</p><p>我们来建这样一个简单的类 Round：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">class</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Round</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Round</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>然后新增一个扩展类 Ring：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">class</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Ring</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">extends</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Round</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Ring</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Round</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这时候，我们就可以通过 instanceof 来检查 Ring 对象是否属于 Round 类型。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">Ring</span><span style="color:#F6F6F4;"> ring </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">Ring</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(ring </span><span style="color:#F286C4;">instanceof</span><span style="color:#F6F6F4;"> Round);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Ring ring </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Ring</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(ring </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> Round);</span></span></code></pre></div><p>结果会输出 true，因为 Ring 继承了 Round，也就意味着 Ring 和 Round 符合 <code> is-a</code> 的关系，而 instanceof 操作符正是基于类与类之间的继承关系，以及类与接口之间的实现关系的。</p><p>我们再来新建一个接口 Shape：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">interface</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Shape</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Shape</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>然后新建 Circle 类实现 Shape 接口并继承 Round 类：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">class</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Circle</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">extends</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Round</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">implements</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Shape</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Circle</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Round</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Shape</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>如果对象是由该类创建的，那么 instanceof 的结果肯定为 true。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">Circle</span><span style="color:#F6F6F4;"> circle </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">Circle</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(circle </span><span style="color:#F286C4;">instanceof</span><span style="color:#F6F6F4;"> Circle);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Circle circle </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Circle</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(circle </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> Circle);</span></span></code></pre></div><p>这个肯定没毛病，instanceof 就是干这个活的，大家也很好理解。那如果类型是父类呢？</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(circle </span><span style="color:#F286C4;">instanceof</span><span style="color:#F6F6F4;"> Round);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(circle </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> Round);</span></span></code></pre></div><p>结果肯定还是 true，因为依然符合 <code>is-a</code> 的关系。那如果类型为接口呢？</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(circle </span><span style="color:#F286C4;">instanceof</span><span style="color:#F6F6F4;"> Shape);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(circle </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> Shape);</span></span></code></pre></div><p>结果仍然为 true， 因为也符合 <code>is-a</code> 的关系。如果要比较的对象和要比较的类型之间没有关系，当然是不能使用 instanceof 进行比较的。</p><p>为了验证这一点，我们来创建一个实现了 Shape 但与 Circle 无关的 Triangle 类：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">class</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Triangle</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">implements</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Shape</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Triangle</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Shape</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这时候，再使用 instanceof 进行比较的话，编译器就报错了。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(circle </span><span style="color:#F286C4;">instanceof</span><span style="color:#F6F6F4;"> Triangle);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(circle </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> Triangle);</span></span></code></pre></div><p>错误信息如下所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">Inconvertible types; cannot cast &#39;com.itwanger.twentyfour.instanceof1.Circle&#39; to &#39;com.itwanger.twentyfour.instanceof1.Triangle&#39;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Inconvertible types; cannot cast &#39;com.itwanger.twentyfour.instanceof1.Circle&#39; to &#39;com.itwanger.twentyfour.instanceof1.Triangle&#39;</span></span></code></pre></div><p>意思就是类型不匹配，不能转换，我们使用 instanceof 比较的目的，也就是希望如果结果为 true 的时候能进行类型转换。但显然 Circle 不能转为 Triangle。</p><p>编译器已经提前帮我们预知了，很聪明。</p><p>Java 是一门面向对象的编程语言，也就意味着除了基本数据类型，所有的类都会隐式继承 Object 类。所以下面的结果肯定也会输出 true。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">Thread</span><span style="color:#F6F6F4;"> thread </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">Thread</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(thread </span><span style="color:#F286C4;">instanceof</span><span style="color:#F6F6F4;"> Object);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Thread thread </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(thread </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> Object);</span></span></code></pre></div><p>“那如果对象为 null 呢？”我这时候插话了。</p><p>“这个还真的是一个好问题啊。”三妹忍不住对我竖了一个大拇指。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">instanceof</span><span style="color:#F6F6F4;"> Object);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> Object);</span></span></code></pre></div><p>只有对象才会有 null 值，所以编译器是不会报错的，只不过，对于 null 来说，instanceof 的结果为 false。因为所有的对象都可以为 null，所以也不好确定 null 到底属于哪一个类。</p><p>通常，我们是这样使用 instanceof 操作符的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#7B7F8B;">// 先判断类型</span></span>
<span class="line"><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (obj </span><span style="color:#F286C4;">instanceof</span><span style="color:#F6F6F4;"> String) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 然后强制转换</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">String</span><span style="color:#F6F6F4;"> s </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (String) obj;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 然后才能使用</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 先判断类型</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (obj </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> String) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 然后强制转换</span></span>
<span class="line"><span style="color:#24292E;">    String s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (String) obj;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 然后才能使用</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>先用 instanceof 进行类型判断，然后再把 obj 强制转换成我们期望的类型再进行使用。</p><p>JDK 16 的时候，instanceof 模式匹配转了正，意味着使用 instanceof 的时候更便捷了。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (obj </span><span style="color:#F286C4;">instanceof</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">String</span><span style="color:#F6F6F4;"> s) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 如果类型匹配 直接使用 s</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (obj </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> String s) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果类型匹配 直接使用 s</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>可以直接在 if 条件判断类型的时候添加一个变量，就不需要再强转和声明新的变量了。</p><p>“哇，这样就简洁了呀！”为了配合三妹，我不仅惊叹到！</p><p>“好了，关于 instanceof 操作符我们就先讲到这吧，难是一点都不难，希望哥也能够很好的掌握。”三妹笑嘻嘻地说，看来她很享受这个讲的过程嘛。</p><hr>`,47),e=[o];function t(c,r,i,y,F,d){return a(),n("div",null,e)}const h=s(l,[["render",t]]);export{g as __pageData,h as default};
