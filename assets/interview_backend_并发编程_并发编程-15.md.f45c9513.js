import{_ as a,o as e,c as o,V as E}from"./chunks/framework.c6d8cbec.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/并发编程/并发编程-15.md","filePath":"interview/backend/并发编程/并发编程-15.md"}'),t={name:"interview/backend/并发编程/并发编程-15.md"},r=E('<h3 id="_1、java-线程数过多会造成什么异常" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#1java-%E7%BA%BF%E7%A8%8B%E6%95%B0%E8%BF%87%E5%A4%9A%E4%BC%9A%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E5%BC%82%E5%B8%B8" target="_blank" rel="noreferrer">1、Java 线程数过多会造成什么异常？</a> <a class="header-anchor" href="#_1、java-线程数过多会造成什么异常" aria-label="Permalink to &quot;[1、Java 线程数过多会造成什么异常？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题2021年，常见面试题及答案汇总.md#1java-线程数过多会造成什么异常)&quot;">​</a></h3><p><strong>1、</strong> 线程的生命周期开销非常高</p><p><strong>2、</strong> 消耗过多的 CPU</p><p>资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU资源时还将产生其他性能的开销。</p><p><strong>降低稳定性JVM</strong></p><p>在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。</p><h3 id="_2、同步方法和同步块-哪个是更好的选择" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#2%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%92%8C%E5%90%8C%E6%AD%A5%E5%9D%97%E5%93%AA%E4%B8%AA%E6%98%AF%E6%9B%B4%E5%A5%BD%E7%9A%84%E9%80%89%E6%8B%A9" target="_blank" rel="noreferrer">2、同步方法和同步块，哪个是更好的选择？</a> <a class="header-anchor" href="#_2、同步方法和同步块-哪个是更好的选择" aria-label="Permalink to &quot;[2、同步方法和同步块，哪个是更好的选择？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题2021年，常见面试题及答案汇总.md#2同步方法和同步块哪个是更好的选择)&quot;">​</a></h3><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p><p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p><h3 id="_3、说说类加载的过程" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#3%E8%AF%B4%E8%AF%B4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B" target="_blank" rel="noreferrer">3、说说类加载的过程</a> <a class="header-anchor" href="#_3、说说类加载的过程" aria-label="Permalink to &quot;[3、说说类加载的过程](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题2021年，常见面试题及答案汇总.md#3说说类加载的过程)&quot;">​</a></h3><p>加载 验证 准备（为一些类变量分配内存，并将其初始化为默认值） 解析（将符号引用替换为直接引用。类和接口、类方法、接口方法、字段等解析） 初始化</p><h3 id="_4、程序计数器是什么" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#4%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noreferrer">4、程序计数器是什么？</a> <a class="header-anchor" href="#_4、程序计数器是什么" aria-label="Permalink to &quot;[4、程序计数器是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题2021年，常见面试题及答案汇总.md#4程序计数器是什么)&quot;">​</a></h3><p><strong>程序计数器</strong>是一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器。字节码解释器工作时通过改变计数器的值选取下一条执行指令。分支、循环、跳转、线程恢复等功能都需要依赖计数器完成。是唯一在虚拟机规范中没有规定内存溢出情况的区域。</p><p>如果线程正在执行 Java 方法，计数器记录正在执行的虚拟机字节码指令地址。如果是本地方法，计数器值为 Undefined。</p><h3 id="_5、readwritelock是什么" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#5readwritelock%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noreferrer">5、ReadWriteLock是什么</a> <a class="header-anchor" href="#_5、readwritelock是什么" aria-label="Permalink to &quot;[5、ReadWriteLock是什么](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题2021年，常见面试题及答案汇总.md#5readwritelock是什么)&quot;">​</a></h3><p>首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p><p>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><h3 id="_6、synchronized-和-lock-有什么区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#6synchronized-%E5%92%8C-lock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">6、synchronized 和 Lock 有什么区别？</a> <a class="header-anchor" href="#_6、synchronized-和-lock-有什么区别" aria-label="Permalink to &quot;[6、synchronized 和 Lock 有什么区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题2021年，常见面试题及答案汇总.md#6synchronized-和-lock-有什么区别)&quot;">​</a></h3><p><strong>1、</strong> 首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；</p><p><strong>2、</strong> synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</p><p><strong>3、</strong> synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</p><p><strong>4、</strong> 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p><h3 id="_7、为什么线程通信的方法-wait-notify-和-notifyall-被定义在-object-类里" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#7%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95-wait,-notify%E5%92%8C-notifyall%E8%A2%AB%E5%AE%9A%E4%B9%89%E5%9C%A8-object-%E7%B1%BB%E9%87%8C" target="_blank" rel="noreferrer">7、为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</a> <a class="header-anchor" href="#_7、为什么线程通信的方法-wait-notify-和-notifyall-被定义在-object-类里" aria-label="Permalink to &quot;[7、为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题2021年，常见面试题及答案汇总.md#7为什么线程通信的方法-wait,-notify和-notifyall被定义在-object-类里)&quot;">​</a></h3><p>因为Java所有类的都继承了Object，Java想让任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</p><p>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</p><h3 id="_8、java-如何实现多线程之间的通讯和协作" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#8java-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E5%92%8C%E5%8D%8F%E4%BD%9C" target="_blank" rel="noreferrer">8、Java 如何实现多线程之间的通讯和协作？</a> <a class="header-anchor" href="#_8、java-如何实现多线程之间的通讯和协作" aria-label="Permalink to &quot;[8、Java 如何实现多线程之间的通讯和协作？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题2021年，常见面试题及答案汇总.md#8java-如何实现多线程之间的通讯和协作)&quot;">​</a></h3><p>可以通过中断 和 共享变量的方式实现线程间的通讯和协作</p><p>比如说最经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。</p><p><strong>Java中线程通信协作的最常见方式：</strong></p><p><strong>1、</strong> syncrhoized加锁的线程的Object类的wait()/notify()/notifyAll()</p><p><strong>2、</strong> ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()</p><p><strong>线程间直接的数据交换：</strong></p><p>通过管道进行线程间通信：字节流、字符流</p><h3 id="_9、怎么判断并发队列是阻塞队列还是非阻塞队列" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#9%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97%E6%98%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E8%BF%98%E6%98%AF%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97" target="_blank" rel="noreferrer">9、怎么判断并发队列是阻塞队列还是非阻塞队列</a> <a class="header-anchor" href="#_9、怎么判断并发队列是阻塞队列还是非阻塞队列" aria-label="Permalink to &quot;[9、怎么判断并发队列是阻塞队列还是非阻塞队列](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题2021年，常见面试题及答案汇总.md#9怎么判断并发队列是阻塞队列还是非阻塞队列)&quot;">​</a></h3><p>在并发队列上JDK提供了Queue接口，一个是以Queue接口下的BlockingQueue接口为代表的阻塞队列，另一个是高性能（无堵塞）队列。</p><h3 id="_10、volatile-能使得一个非原子操作变成原子操作吗" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#10volatile-%E8%83%BD%E4%BD%BF%E5%BE%97%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%8F%98%E6%88%90%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%90%97" target="_blank" rel="noreferrer">10、volatile 能使得一个非原子操作变成原子操作吗？</a> <a class="header-anchor" href="#_10、volatile-能使得一个非原子操作变成原子操作吗" aria-label="Permalink to &quot;[10、volatile 能使得一个非原子操作变成原子操作吗？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题2021年，常见面试题及答案汇总.md#10volatile-能使得一个非原子操作变成原子操作吗)&quot;">​</a></h3><p><strong>1、</strong> 关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步。</p><p><strong>2、</strong> 虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子性。</p><p><strong>所以从Oracle Java Spec里面可以看到：</strong></p><p><strong>1、</strong> 对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。</p><p><strong>2、</strong> 如果使用volatile修饰long和double，那么其读写都是原子操作</p><p><strong>3、</strong> 对于64位的引用地址的读写，都是原子操作</p><p><strong>4、</strong> 在实现JVM时，可以自由选择是否把读写long和double作为原子操作</p><p><strong>5、</strong> 推荐JVM实现为原子操作</p><h3 id="_11、swap会影响性能么" tabindex="-1">11、SWAP会影响性能么？ <a class="header-anchor" href="#_11、swap会影响性能么" aria-label="Permalink to &quot;11、SWAP会影响性能么？&quot;">​</a></h3><h3 id="_12、你是如何调用-wait-方法的-使用-if-块还是循环-为什么" tabindex="-1">12、你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？ <a class="header-anchor" href="#_12、你是如何调用-wait-方法的-使用-if-块还是循环-为什么" aria-label="Permalink to &quot;12、你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？&quot;">​</a></h3><h3 id="_13、如何合理分配线程池大小" tabindex="-1">13、如何合理分配线程池大小? <a class="header-anchor" href="#_13、如何合理分配线程池大小" aria-label="Permalink to &quot;13、如何合理分配线程池大小?&quot;">​</a></h3><h3 id="_14、在新生代-复制算法" tabindex="-1">14、在新生代-复制算法 <a class="header-anchor" href="#_14、在新生代-复制算法" aria-label="Permalink to &quot;14、在新生代-复制算法&quot;">​</a></h3><h3 id="_15、怎么打出线程栈信息" tabindex="-1">15、怎么打出线程栈信息？ <a class="header-anchor" href="#_15、怎么打出线程栈信息" aria-label="Permalink to &quot;15、怎么打出线程栈信息？&quot;">​</a></h3><h3 id="_16、代码示例" tabindex="-1">16、代码示例： <a class="header-anchor" href="#_16、代码示例" aria-label="Permalink to &quot;16、代码示例：&quot;">​</a></h3><h3 id="_17、在java中守护线程和本地线程区别" tabindex="-1">17、在java中守护线程和本地线程区别？ <a class="header-anchor" href="#_17、在java中守护线程和本地线程区别" aria-label="Permalink to &quot;17、在java中守护线程和本地线程区别？&quot;">​</a></h3><h3 id="_18、你对线程优先级的理解是什么" tabindex="-1">18、你对线程优先级的理解是什么？ <a class="header-anchor" href="#_18、你对线程优先级的理解是什么" aria-label="Permalink to &quot;18、你对线程优先级的理解是什么？&quot;">​</a></h3><h3 id="_19、被引用的对象就一定能存活吗" tabindex="-1">19、被引用的对象就一定能存活吗？ <a class="header-anchor" href="#_19、被引用的对象就一定能存活吗" aria-label="Permalink to &quot;19、被引用的对象就一定能存活吗？&quot;">​</a></h3><h3 id="_20、类加载的过程是什么" tabindex="-1">20、类加载的过程是什么？ <a class="header-anchor" href="#_20、类加载的过程是什么" aria-label="Permalink to &quot;20、类加载的过程是什么？&quot;">​</a></h3><h3 id="_21、什么是阻塞式方法" tabindex="-1">21、什么是阻塞式方法？ <a class="header-anchor" href="#_21、什么是阻塞式方法" aria-label="Permalink to &quot;21、什么是阻塞式方法？&quot;">​</a></h3><h3 id="_22、线程之间如何通信及线程之间如何同步" tabindex="-1">22、线程之间如何通信及线程之间如何同步 <a class="header-anchor" href="#_22、线程之间如何通信及线程之间如何同步" aria-label="Permalink to &quot;22、线程之间如何通信及线程之间如何同步&quot;">​</a></h3><h3 id="_23、非堵塞队列" tabindex="-1">23、非堵塞队列： <a class="header-anchor" href="#_23、非堵塞队列" aria-label="Permalink to &quot;23、非堵塞队列：&quot;">​</a></h3><h3 id="_24、四种构建线程池的区别及特点" tabindex="-1">24、四种构建线程池的区别及特点？ <a class="header-anchor" href="#_24、四种构建线程池的区别及特点" aria-label="Permalink to &quot;24、四种构建线程池的区别及特点？&quot;">​</a></h3><h3 id="_25、说说-jvm-如何执行-class-中的字节码。" tabindex="-1">25、说说 JVM 如何执行 class 中的字节码。 <a class="header-anchor" href="#_25、说说-jvm-如何执行-class-中的字节码。" aria-label="Permalink to &quot;25、说说 JVM 如何执行 class 中的字节码。&quot;">​</a></h3><h3 id="_26、threadpoolexecutor饱和策略有哪些" tabindex="-1">26、ThreadPoolExecutor饱和策略有哪些？ <a class="header-anchor" href="#_26、threadpoolexecutor饱和策略有哪些" aria-label="Permalink to &quot;26、ThreadPoolExecutor饱和策略有哪些？&quot;">​</a></h3><h3 id="_27、守护线程和用户线程有什么区别呢" tabindex="-1">27、守护线程和用户线程有什么区别呢？ <a class="header-anchor" href="#_27、守护线程和用户线程有什么区别呢" aria-label="Permalink to &quot;27、守护线程和用户线程有什么区别呢？&quot;">​</a></h3><h3 id="_28、gc垃圾回收算法与垃圾收集器的关系" tabindex="-1">28、GC垃圾回收算法与垃圾收集器的关系？ <a class="header-anchor" href="#_28、gc垃圾回收算法与垃圾收集器的关系" aria-label="Permalink to &quot;28、GC垃圾回收算法与垃圾收集器的关系？&quot;">​</a></h3><h3 id="_29、java-中垃圾收集的方法有哪些" tabindex="-1">29、Java 中垃圾收集的方法有哪些 <a class="header-anchor" href="#_29、java-中垃圾收集的方法有哪些" aria-label="Permalink to &quot;29、Java 中垃圾收集的方法有哪些&quot;">​</a></h3><h3 id="_30、分代收集算法" tabindex="-1">30、分代收集算法 <a class="header-anchor" href="#_30、分代收集算法" aria-label="Permalink to &quot;30、分代收集算法&quot;">​</a></h3><h3 id="_31、gc-roots-有哪些" tabindex="-1">31、GC Roots 有哪些？ <a class="header-anchor" href="#_31、gc-roots-有哪些" aria-label="Permalink to &quot;31、GC Roots 有哪些？&quot;">​</a></h3><h3 id="_32、什么是callable和future" tabindex="-1">32、什么是Callable和Future? <a class="header-anchor" href="#_32、什么是callable和future" aria-label="Permalink to &quot;32、什么是Callable和Future?&quot;">​</a></h3>',66),B=[r];function n(l,s,i,h,A,c){return e(),o("div",null,B)}const b=a(t,[["render",n]]);export{u as __pageData,b as default};
