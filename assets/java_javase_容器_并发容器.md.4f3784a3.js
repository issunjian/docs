import{_ as s,o as a,c as n,V as l}from"./chunks/framework.c6d8cbec.js";const d=JSON.parse('{"title":"并发容器","description":"","frontmatter":{},"headers":[],"relativePath":"java/javase/容器/并发容器.md","filePath":"java/javase/容器/并发容器.md"}'),e={name:"java/javase/容器/并发容器.md"},o=l(`<h1 id="并发容器" tabindex="-1">并发容器 <a class="header-anchor" href="#并发容器" aria-label="Permalink to &quot;并发容器&quot;">​</a></h1><hr><h2 id="并发原理" tabindex="-1">并发原理 <a class="header-anchor" href="#并发原理" aria-label="Permalink to &quot;并发原理&quot;">​</a></h2><p>Java 提供的基础容器都是线程不安全的，如果并发条件下多个线程同时对一个容器中的数据进行操作，可能会导致各种意想不到的错误。</p><p>因此 Java 又提供了一些并发容器在多线程情况下使用，这些并发容器都位于 java.util.concurrent 包内，使用时需要进行导入。</p><hr><h2 id="list-接口" tabindex="-1">List 接口 <a class="header-anchor" href="#list-接口" aria-label="Permalink to &quot;List 接口&quot;">​</a></h2><h3 id="vector-类-已过时" tabindex="-1"><s>Vector 类（已过时）</s> <a class="header-anchor" href="#vector-类-已过时" aria-label="Permalink to &quot;~~Vector 类（已过时）~~&quot;">​</a></h3><p>【数组序列】和 ArrayList 类类似，实现了 List 接口。内部使用 Object 数组存储。</p><p>Vector 类内部所有方法都是同步(synchronized) 的，因此线程安全。但高并发场景下非常容易阻塞，性能很差。</p><h3 id="copyonwritearraylist-类" tabindex="-1">CopyOnWriteArrayList 类 <a class="header-anchor" href="#copyonwritearraylist-类" aria-label="Permalink to &quot;CopyOnWriteArrayList 类&quot;">​</a></h3><p>【数组序列】和 ArrayList 类类似，实现了 List 接口。内部使用 Object 数组存储。</p><p>CopyOnWriteArrayList 对读取操作不上锁，对写入操作上锁。写入操作通过创建数组的副本来实现，修改的内容写入副本后再替换原来的数据。</p><p>不允许同时写，但读操作和写操作不冲突，在多读的场合性能非常好。</p><h3 id="concurrentlinkedqueue-类" tabindex="-1">ConcurrentLinkedQueue 类 <a class="header-anchor" href="#concurrentlinkedqueue-类" aria-label="Permalink to &quot;ConcurrentLinkedQueue 类&quot;">​</a></h3><p>【链表序列】和 LinkedList 类类似，实现了 List 以及 Deque 接口。内部使用双向链表存储。</p><p>ConcurrentLinkedQueue 类非阻塞，通过 CAS 算法实现线程安全，尝试更新数据时会对数据进行比对。高并发场景下如果加锁的代价很高，可以达到很好的性能。</p><hr><h2 id="blockingqueue-接口" tabindex="-1">BlockingQueue 接口 <a class="header-anchor" href="#blockingqueue-接口" aria-label="Permalink to &quot;BlockingQueue 接口&quot;">​</a></h2><p>【阻塞队列】被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p><h3 id="arrayblockingqueue-类" tabindex="-1">ArrayBlockingQueue 类 <a class="header-anchor" href="#arrayblockingqueue-类" aria-label="Permalink to &quot;ArrayBlockingQueue 类&quot;">​</a></h3><p>有界队列实现类，底层采用数组来实现。ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</p><h3 id="linkedblockingqueue-类" tabindex="-1">LinkedBlockingQueue 类 <a class="header-anchor" href="#linkedblockingqueue-类" aria-label="Permalink to &quot;LinkedBlockingQueue 类&quot;">​</a></h3><h3 id="priorityblockingqueue-类" tabindex="-1">PriorityBlockingQueue 类 <a class="header-anchor" href="#priorityblockingqueue-类" aria-label="Permalink to &quot;PriorityBlockingQueue 类&quot;">​</a></h3><hr><h2 id="map-接口" tabindex="-1">Map 接口 <a class="header-anchor" href="#map-接口" aria-label="Permalink to &quot;Map 接口&quot;">​</a></h2><h3 id="hashtable-类-已过时" tabindex="-1"><s>HashTable 类（已过时）</s> <a class="header-anchor" href="#hashtable-类-已过时" aria-label="Permalink to &quot;~~HashTable 类（已过时）~~&quot;">​</a></h3><p>【哈希表】和 HashMap 类类似，实现了 Map 接口。</p><p>HashTable 类内部所有方法都是同步(synchronized) 的，因此线程安全。但由于整个哈希存储区域共享一把锁，高并发场景下非常容易阻塞，性能很差。</p><h3 id="concurrenthashmap-类" tabindex="-1">ConcurrentHashMap 类 <a class="header-anchor" href="#concurrenthashmap-类" aria-label="Permalink to &quot;ConcurrentHashMap 类&quot;">​</a></h3><p>【哈希表】和 HashMap 类类似，实现了 Map 接口。</p><p>并发控制使用 synchronized 和 CAS 来操作，采取分段锁机制。synchronized 对哈希存储区域的每个 key 分别上锁，只锁定当前链表或红黑二叉树的首节点，这样只要不发生哈希冲突就不会产生并发，效率大大提升。</p><p>JDK 1.7 中， ConcurrentHashMap 类中包含静态内部类 Segment，继承于 ReentrantLock 类用来充当锁的角色，每个 Segment 对象守护若干个保存键值对的链表，共同构成 ConcurrentHashMap 实例中的数组。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。</p><p>JDK 1.8 中放弃了 Segment 臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">static</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">class</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">HashEntry</span><span style="color:#F6F6F4;">&lt;K,V&gt; {</span></span>
<span class="line"><span style="color:#F6F6F4;">       </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">K</span><span style="color:#F6F6F4;"> key;                       </span><span style="color:#7B7F8B;">// 声明 key 为 final 型</span></span>
<span class="line"><span style="color:#F6F6F4;">       </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> hash;                   </span><span style="color:#7B7F8B;">// 声明 hash 值为 final 型</span></span>
<span class="line"><span style="color:#F6F6F4;">       </span><span style="color:#F286C4;">volatile</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">V</span><span style="color:#F6F6F4;"> value;                 </span><span style="color:#7B7F8B;">// 声明 value 为 volatile 型</span></span>
<span class="line"><span style="color:#F6F6F4;">       </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">HashEntry</span><span style="color:#F6F6F4;">&lt;K,V&gt; next;      </span><span style="color:#7B7F8B;">// 声明 next 为 final 型</span></span>
<span class="line"><span style="color:#F6F6F4;">  </span></span>
<span class="line"><span style="color:#F6F6F4;">       </span><span style="color:#62E884;">HashEntry</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">K</span><span style="color:#F6F6F4;"> </span><span style="color:#FFB86C;font-style:italic;">key</span><span style="color:#F6F6F4;">, </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> </span><span style="color:#FFB86C;font-style:italic;">hash</span><span style="color:#F6F6F4;">, </span><span style="color:#97E1F1;font-style:italic;">HashEntry</span><span style="color:#F6F6F4;">&lt;K,V&gt; </span><span style="color:#FFB86C;font-style:italic;">next</span><span style="color:#F6F6F4;">, </span><span style="color:#97E1F1;font-style:italic;">V</span><span style="color:#F6F6F4;"> </span><span style="color:#FFB86C;font-style:italic;">value</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#F6F6F4;">           </span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">.key </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> key;</span></span>
<span class="line"><span style="color:#F6F6F4;">           </span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">.hash </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> hash;</span></span>
<span class="line"><span style="color:#F6F6F4;">           </span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">.next </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> next;</span></span>
<span class="line"><span style="color:#F6F6F4;">           </span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">.value </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> value;</span></span>
<span class="line"><span style="color:#F6F6F4;">       }</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">HashEntry</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> K key;                       </span><span style="color:#6A737D;">// 声明 key 为 final 型</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> hash;                   </span><span style="color:#6A737D;">// 声明 hash 值为 final 型</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> V value;                 </span><span style="color:#6A737D;">// 声明 value 为 volatile 型</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> HashEntry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; next;      </span><span style="color:#6A737D;">// 声明 next 为 final 型</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6F42C1;">HashEntry</span><span style="color:#24292E;">(K </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">hash</span><span style="color:#24292E;">, HashEntry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">next</span><span style="color:#24292E;">, V </span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">           </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.key </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> key;</span></span>
<span class="line"><span style="color:#24292E;">           </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.hash </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> hash;</span></span>
<span class="line"><span style="color:#24292E;">           </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> next;</span></span>
<span class="line"><span style="color:#24292E;">           </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> value;</span></span>
<span class="line"><span style="color:#24292E;">       }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><hr><h2 id="普通容器转换" tabindex="-1">普通容器转换 <a class="header-anchor" href="#普通容器转换" aria-label="Permalink to &quot;普通容器转换&quot;">​</a></h2><h3 id="synchronizedlist-方法" tabindex="-1">synchronizedList 方法 <a class="header-anchor" href="#synchronizedlist-方法" aria-label="Permalink to &quot;synchronizedList 方法&quot;">​</a></h3><p>如果遇到多个线程操作同一个容器的场景，可以通过 Collections 工具类中的 synchronizedList 方法将其转换成线程安全的容器。</p><p>方法会被 synchronized 关键字重定义。</p>`,40),p=[o];function t(r,c,i,y,F,h){return a(),n("div",null,p)}const E=s(e,[["render",t]]);export{d as __pageData,E as default};
