import{_ as a,o as r,c as e,V as o}from"./chunks/framework.c6d8cbec.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/并发编程/并发编程-05.md","filePath":"interview/backend/并发编程/并发编程-05.md"}'),t={name:"interview/backend/并发编程/并发编程-05.md"},n=o('<h3 id="_1、线程池四种创建方式" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#1%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9B%9B%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F" target="_blank" rel="noreferrer">1、线程池四种创建方式？</a> <a class="header-anchor" href="#_1、线程池四种创建方式" aria-label="Permalink to &quot;[1、线程池四种创建方式？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题整理及答案.md#1线程池四种创建方式)&quot;">​</a></h3><p><strong>Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：</strong></p><p><strong>1、</strong> newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p><strong>2、</strong> newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p><strong>3、</strong> newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p><p><strong>4、</strong> newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><h3 id="_2、什么是程序计数器" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#2%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8" target="_blank" rel="noreferrer">2、什么是程序计数器</a> <a class="header-anchor" href="#_2、什么是程序计数器" aria-label="Permalink to &quot;[2、什么是程序计数器](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题整理及答案.md#2什么是程序计数器)&quot;">​</a></h3><p>当前线程所执行的行号指示器。是 JVM 内存区域最小的一块区域。执行字节码工作时就是利用程序计数器来选取下一条需要执行的字节码指令。</p><h3 id="_3、thread-类中的-yield-方法有什么作用" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#3thread-%E7%B1%BB%E4%B8%AD%E7%9A%84-yield-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8" target="_blank" rel="noreferrer">3、Thread 类中的 yield 方法有什么作用？</a> <a class="header-anchor" href="#_3、thread-类中的-yield-方法有什么作用" aria-label="Permalink to &quot;[3、Thread 类中的 yield 方法有什么作用？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题整理及答案.md#3thread-类中的-yield-方法有什么作用)&quot;">​</a></h3><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。</p><p>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。</p><h3 id="_4、老年代" tabindex="-1">4、老年代 <a class="header-anchor" href="#_4、老年代" aria-label="Permalink to &quot;4、老年代&quot;">​</a></h3><p><strong>1、</strong> 主要存放应用程序中生命周期长的内存对象。</p><p><strong>2、</strong> 老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。</p><p><strong>3、</strong> MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。ajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。</p><h3 id="_5、你知道哪些jvm性能调优" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#5%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9Bjvm%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98" target="_blank" rel="noreferrer">5、你知道哪些JVM性能调优</a> <a class="header-anchor" href="#_5、你知道哪些jvm性能调优" aria-label="Permalink to &quot;[5、你知道哪些JVM性能调优](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题整理及答案.md#5你知道哪些jvm性能调优)&quot;">​</a></h3><p><strong>设定堆内存大小</strong></p><p><strong>1、</strong> -Xmx：堆内存最大限制。设定新生代大小。新生代不宜太小，否则会有大量对象涌入老年代</p><p><strong>2、</strong> -XX:NewSize：新生代大小</p><p><strong>3、</strong> -XX:NewRatio 新生代和老生代占比</p><p><strong>4、</strong> -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比</p><p><strong>5、</strong> 设定垃圾回收器 年轻代用 -XX:+UseParNewGC 年老代用-XX:+UseConcMarkSweepGC</p><h3 id="_6、说说线程栈" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#6%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E6%A0%88" target="_blank" rel="noreferrer">6、说说线程栈</a> <a class="header-anchor" href="#_6、说说线程栈" aria-label="Permalink to &quot;[6、说说线程栈](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题整理及答案.md#6说说线程栈)&quot;">​</a></h3><p><strong>这里的线程栈应该指的是虚拟机栈吧...</strong></p><p><strong>1、</strong> JVM规范让每个Java线程拥有自己的独立的JVM栈，也就是Java方法的调用栈。</p><p><strong>2、</strong> 当方法调用的时候，会生成一个栈帧。栈帧是保存在虚拟机栈中的，栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息</p><p><strong>3、</strong> 线程运行过程中，只有一个栈帧是处于活跃状态，称为“当前活跃栈帧”，当前活动栈帧始终是虚拟机栈的栈顶元素。</p><p><strong>4、</strong> 通过jstack工具查看线程状态</p><h3 id="_7、请解释stackoverflowerror和outofmemeryerror的区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#7%E8%AF%B7%E8%A7%A3%E9%87%8Astackoverflowerror%E5%92%8Coutofmemeryerror%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">7、请解释StackOverflowError和OutOfMemeryError的区别？</a> <a class="header-anchor" href="#_7、请解释stackoverflowerror和outofmemeryerror的区别" aria-label="Permalink to &quot;[7、请解释StackOverflowError和OutOfMemeryError的区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题整理及答案.md#7请解释stackoverflowerror和outofmemeryerror的区别)&quot;">​</a></h3><p>通过之前的分析可以发现，实际上每一块内存中都会存在有一部分的可变伸缩区，其基本流程为：如果空间内存不足，在可变范围之内扩大内存空间，当一段时间之后发现内存充足，会缩小内存空间。</p><p><strong>永久代（JDK 1.8后消失了）</strong></p><p>虽然java的版本是JDK1.8，但是java EE 的版本还是jdk1.7，永久代存在于堆内存之中</p><p><strong>元空间</strong></p><p>元空间在Jdk1.8之后才有的，器功能实际上和永久代没区别，唯一的区别在于永久代使用的是JVM的堆内存空间，元空间使用的是物理内存，所以元空间的大小受本地内存影响，一般默认在2M 左右。</p><p><strong>范例：设置一些参数，让元空间出错</strong></p><p>Java -XX:MetaspaceSize=1m</p><h3 id="_8、运行时栈帧包含哪些结构" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E7%BB%93%E6%9E%84" target="_blank" rel="noreferrer">8、运行时栈帧包含哪些结构？</a> <a class="header-anchor" href="#_8、运行时栈帧包含哪些结构" aria-label="Permalink to &quot;[8、运行时栈帧包含哪些结构？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题整理及答案.md#8运行时栈帧包含哪些结构)&quot;">​</a></h3><p><strong>1、</strong> 局部变量表</p><p><strong>2、</strong> 操作数栈</p><p><strong>3、</strong> 动态连接</p><p><strong>4、</strong> 返回地址</p><p><strong>5、</strong> 附加信息</p><h3 id="_9、minorgc-majorgc、fullgc都什么时候发生" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#9minorgcmajorgcfullgc%E9%83%BD%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F" target="_blank" rel="noreferrer">9、MinorGC，MajorGC、FullGC都什么时候发生？</a> <a class="header-anchor" href="#_9、minorgc-majorgc、fullgc都什么时候发生" aria-label="Permalink to &quot;[9、MinorGC，MajorGC、FullGC都什么时候发生？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题整理及答案.md#9minorgcmajorgcfullgc都什么时候发生)&quot;">​</a></h3><p>MinorGC在年轻代空间不足的时候发生，MajorGC指的是老年代的GC，出现MajorGC一般经常伴有MinorGC。</p><p>FullGC有三种情况。</p><p><strong>1、</strong> 当老年代无法再分配内存的时候</p><p><strong>2、</strong> 元空间不足的时候</p><p><strong>3、</strong> 显示调用System.gc的时候。另外，像CMS一类的垃圾回收器，在MinorGC出现promotion failure的时候也会发生FullGC</p><h3 id="_10、在监视器-monitor-内部-是如何做线程同步的-程序应该做哪种级别的同步" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#10%E5%9C%A8%E7%9B%91%E8%A7%86%E5%99%A8monitor%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%BA%94%E8%AF%A5%E5%81%9A%E5%93%AA%E7%A7%8D%E7%BA%A7%E5%88%AB%E7%9A%84%E5%90%8C%E6%AD%A5" target="_blank" rel="noreferrer">10、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</a> <a class="header-anchor" href="#_10、在监视器-monitor-内部-是如何做线程同步的-程序应该做哪种级别的同步" aria-label="Permalink to &quot;[10、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题整理及答案.md#10在监视器monitor内部是如何做线程同步的程序应该做哪种级别的同步)&quot;">​</a></h3><p>在 java 虚拟机中，监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p><p>一旦方法或者代码块被 synchronized 修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码</p><p>另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案</p><h3 id="_11、java8-与元数据" tabindex="-1">11、JAVA8 与元数据 <a class="header-anchor" href="#_11、java8-与元数据" aria-label="Permalink to &quot;11、JAVA8 与元数据&quot;">​</a></h3><h3 id="_12、线程之间如何通信及线程之间如何同步" tabindex="-1">12、线程之间如何通信及线程之间如何同步 <a class="header-anchor" href="#_12、线程之间如何通信及线程之间如何同步" aria-label="Permalink to &quot;12、线程之间如何通信及线程之间如何同步&quot;">​</a></h3><h3 id="_13、创建线程的三种方式的对比" tabindex="-1">13、创建线程的三种方式的对比？ <a class="header-anchor" href="#_13、创建线程的三种方式的对比" aria-label="Permalink to &quot;13、创建线程的三种方式的对比？&quot;">​</a></h3><h3 id="_14、详细介绍一下jvm内存模型" tabindex="-1">14、详细介绍一下JVM内存模型 <a class="header-anchor" href="#_14、详细介绍一下jvm内存模型" aria-label="Permalink to &quot;14、详细介绍一下JVM内存模型&quot;">​</a></h3><h3 id="_15、多线程的好处" tabindex="-1">15、多线程的好处 <a class="header-anchor" href="#_15、多线程的好处" aria-label="Permalink to &quot;15、多线程的好处&quot;">​</a></h3><h3 id="_16、什么是happen-before原则" tabindex="-1">16、什么是happen-before原则？ <a class="header-anchor" href="#_16、什么是happen-before原则" aria-label="Permalink to &quot;16、什么是happen-before原则？&quot;">​</a></h3><h3 id="_17、精确来说的话的话" tabindex="-1">17、精确来说的话的话： <a class="header-anchor" href="#_17、精确来说的话的话" aria-label="Permalink to &quot;17、精确来说的话的话：&quot;">​</a></h3><h3 id="_18、有哪些类加载器" tabindex="-1">18、有哪些类加载器？ <a class="header-anchor" href="#_18、有哪些类加载器" aria-label="Permalink to &quot;18、有哪些类加载器？&quot;">​</a></h3><h3 id="_19、什么是future" tabindex="-1">19、什么是Future？ <a class="header-anchor" href="#_19、什么是future" aria-label="Permalink to &quot;19、什么是Future？&quot;">​</a></h3><h3 id="_20、代码示例" tabindex="-1">20、代码示例 <a class="header-anchor" href="#_20、代码示例" aria-label="Permalink to &quot;20、代码示例&quot;">​</a></h3><h3 id="_21、分配cpu和io密集" tabindex="-1">21、分配CPU和IO密集： <a class="header-anchor" href="#_21、分配cpu和io密集" aria-label="Permalink to &quot;21、分配CPU和IO密集：&quot;">​</a></h3><h3 id="_22、java中用到的线程调度算法是什么" tabindex="-1">22、Java中用到的线程调度算法是什么？ <a class="header-anchor" href="#_22、java中用到的线程调度算法是什么" aria-label="Permalink to &quot;22、Java中用到的线程调度算法是什么？&quot;">​</a></h3><h3 id="_23、什么是daemon线程-它有什么意义" tabindex="-1">23、什么是Daemon线程？它有什么意义？ <a class="header-anchor" href="#_23、什么是daemon线程-它有什么意义" aria-label="Permalink to &quot;23、什么是Daemon线程？它有什么意义？&quot;">​</a></h3><h3 id="_24、serial-与-parallel-gc-之间的不同之处" tabindex="-1">24、Serial 与 Parallel GC 之间的不同之处？ <a class="header-anchor" href="#_24、serial-与-parallel-gc-之间的不同之处" aria-label="Permalink to &quot;24、Serial 与 Parallel GC 之间的不同之处？&quot;">​</a></h3><h3 id="_25、如何停止一个正在运行的线程" tabindex="-1">25、如何停止一个正在运行的线程？ <a class="header-anchor" href="#_25、如何停止一个正在运行的线程" aria-label="Permalink to &quot;25、如何停止一个正在运行的线程？&quot;">​</a></h3><h3 id="_26、你知道哪些gc类型" tabindex="-1">26、你知道哪些GC类型？ <a class="header-anchor" href="#_26、你知道哪些gc类型" aria-label="Permalink to &quot;26、你知道哪些GC类型？&quot;">​</a></h3><h3 id="_27、为什么我们调用start-方法时会执行run-方法-为什么我们不能直接调用run-方法" tabindex="-1">27、为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？ <a class="header-anchor" href="#_27、为什么我们调用start-方法时会执行run-方法-为什么我们不能直接调用run-方法" aria-label="Permalink to &quot;27、为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？&quot;">​</a></h3><h3 id="_28、java中有几种方法可以实现一个线程" tabindex="-1">28、java中有几种方法可以实现一个线程？ <a class="header-anchor" href="#_28、java中有几种方法可以实现一个线程" aria-label="Permalink to &quot;28、java中有几种方法可以实现一个线程？&quot;">​</a></h3><h3 id="_29、为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" tabindex="-1">29、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？ <a class="header-anchor" href="#_29、为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" aria-label="Permalink to &quot;29、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？&quot;">​</a></h3><h3 id="_30、说一下-synchronized-底层实现原理" tabindex="-1">30、说一下 synchronized 底层实现原理？ <a class="header-anchor" href="#_30、说一下-synchronized-底层实现原理" aria-label="Permalink to &quot;30、说一下 synchronized 底层实现原理？&quot;">​</a></h3><h3 id="_31、tomcat是怎么打破双亲委派机制的呢" tabindex="-1">31、Tomcat是怎么打破双亲委派机制的呢？ <a class="header-anchor" href="#_31、tomcat是怎么打破双亲委派机制的呢" aria-label="Permalink to &quot;31、Tomcat是怎么打破双亲委派机制的呢？&quot;">​</a></h3>',73),E=[n];function s(l,h,i,B,d,A){return r(),e("div",null,E)}const m=a(t,[["render",s]]);export{c as __pageData,m as default};
