import{_ as a,o as e,c as o,V as r}from"./chunks/framework.c6d8cbec.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/并发编程/并发编程-04.md","filePath":"interview/backend/并发编程/并发编程-04.md"}'),t={name:"interview/backend/并发编程/并发编程-04.md"},E=r('<h3 id="_1、jvm-运行时内存" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%9D%A2%E8%AF%95%E9%A2%98.md#1jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98" target="_blank" rel="noreferrer">1、JVM 运行时内存</a> <a class="header-anchor" href="#_1、jvm-运行时内存" aria-label="Permalink to &quot;[1、JVM 运行时内存](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题及答案，企业真面试题.md#1jvm-运行时内存)&quot;">​</a></h3><p>Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。</p><p><strong>新生代</strong></p><p>是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden区、 ServivorFrom、 ServivorTo 三个区。</p><p><strong>Eden 区</strong></p><p>Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。</p><p><strong>ServivorFrom</strong></p><p>上一次 GC 的幸存者，作为这一次 GC 的被扫描者。</p><p><strong>ServivorTo</strong></p><p>保留了一次 MinorGC 过程中的幸存者。</p><p><strong>MinorGC 的过程（复制-&gt;清空-&gt;互换）</strong></p><p>MinorGC 采用复制算法。</p><p><strong>eden、 servicorFrom 复制到 ServicorTo，年龄+1</strong></p><p>首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）；</p><p><strong>清空 eden、 servicorFrom</strong></p><p>然后，清空 Eden 和 ServicorFrom 中的对象；</p><p><strong>ServicorTo 和 ServicorFrom 互换</strong></p><p>最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。</p><h3 id="_2、如果你提交任务时-线程池队列已满-这时会发生什么" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%9D%A2%E8%AF%95%E9%A2%98.md#2%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%98%9F%E5%88%97%E5%B7%B2%E6%BB%A1%E8%BF%99%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88" target="_blank" rel="noreferrer">2、如果你提交任务时，线程池队列已满，这时会发生什么</a> <a class="header-anchor" href="#_2、如果你提交任务时-线程池队列已满-这时会发生什么" aria-label="Permalink to &quot;[2、如果你提交任务时，线程池队列已满，这时会发生什么](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题及答案，企业真面试题.md#2如果你提交任务时线程池队列已满这时会发生什么)&quot;">​</a></h3><p>这里区分一下：</p><p><strong>1、</strong> 如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务</p><p><strong>2、</strong> 如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</p><h3 id="_3、永久代" tabindex="-1">3、永久代 <a class="header-anchor" href="#_3、永久代" aria-label="Permalink to &quot;3、永久代&quot;">​</a></h3><p>指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域， 它和和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。</p><h3 id="_4、什么是不可变对象-它对写并发应用有什么帮助" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%9D%A2%E8%AF%95%E9%A2%98.md#4%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%AE%83%E5%AF%B9%E5%86%99%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%B8%AE%E5%8A%A9" target="_blank" rel="noreferrer">4、什么是不可变对象，它对写并发应用有什么帮助？</a> <a class="header-anchor" href="#_4、什么是不可变对象-它对写并发应用有什么帮助" aria-label="Permalink to &quot;[4、什么是不可变对象，它对写并发应用有什么帮助？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题及答案，企业真面试题.md#4什么是不可变对象它对写并发应用有什么帮助)&quot;">​</a></h3><p><strong>1、</strong> 不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。</p><p><strong>2、</strong> 不可变对象的类即为不可变类(Immutable Class)。Java平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等。</p><p><strong>3、</strong> 不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。</p><p><strong>1、</strong> 不可变对象永远是线程安全的。</p><p><strong>2、</strong> 只有满足如下状态，一个对象才是不可变的；</p><p><strong>3、</strong> 它的状态不能在创建后再被修改；</p><p><strong>4、</strong> 所有域都是final类型；并且，</p><p><strong>5、</strong> 它被正确创建（创建期间没有发生this引用的逸出）。</p><h3 id="_5、什么是多线程的上下文切换" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%9D%A2%E8%AF%95%E9%A2%98.md#5%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2" target="_blank" rel="noreferrer">5、什么是多线程的上下文切换</a> <a class="header-anchor" href="#_5、什么是多线程的上下文切换" aria-label="Permalink to &quot;[5、什么是多线程的上下文切换](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题及答案，企业真面试题.md#5什么是多线程的上下文切换)&quot;">​</a></h3><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><h3 id="_6、java的内存模型是什么-jmm是什么" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%9D%A2%E8%AF%95%E9%A2%98.md#6java%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88jmm%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noreferrer">6、Java的内存模型是什么？（JMM是什么？）</a> <a class="header-anchor" href="#_6、java的内存模型是什么-jmm是什么" aria-label="Permalink to &quot;[6、Java的内存模型是什么？（JMM是什么？）](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题及答案，企业真面试题.md#6java的内存模型是什么jmm是什么)&quot;">​</a></h3><p>JVM试图定义一种统一的内存模型，能将各种底层硬件及操作系统的内存访问差异进行封装，使Java程序在不同硬件及操作系统上都能达到相同的并发效果。它分为工作内存和主内存，线程无法对主存储器<strong>直接</strong>进行操作，一个线程要和另外一个线程通信，只能通过主存进行交换。</p><p>JMM可以说是Java并发的基础，它的定义将直接影响多线程实现的机制，如果你想要想深入了解多线程并发中的相关问题现象，对JMM的深入研究是必不可少的。</p><p>上面两个问题是经常容易搞混的，但它们的内容却完全不同的。</p><h3 id="_7、collections-synchronized-是什么-https-gitee-com-souyunku-devbooks-blob-master-docs-并发编程-并发编程高级面试题及答案-企业真面试题-md-7collectionssynchronized-是什么" tabindex="-1">[7、Collections.synchronized 是什么？](<a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%9D%A2%E8%AF%95%E9%A2%98.md#7collectionssynchronized-" target="_blank" rel="noreferrer">https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题及答案，企业真面试题.md#7collectionssynchronized-</a> 是什么) <a class="header-anchor" href="#_7、collections-synchronized-是什么-https-gitee-com-souyunku-devbooks-blob-master-docs-并发编程-并发编程高级面试题及答案-企业真面试题-md-7collectionssynchronized-是什么" aria-label="Permalink to &quot;[7、Collections.synchronized  是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题及答案，企业真面试题.md#7collectionssynchronized- 是什么)&quot;">​</a></h3><p>**注意：_ 号代表后面是还有内容的_</p><p>此方法是干什么的呢，他完完全全的可以把List、Map、Set接口底下的集合变成线程安全的集合</p><p>Collections.synchronized * ：原理是什么，我猜的话是代理模式：</p><p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/045/42/87_14.png#alt=87%5C_14.png" alt=""></p><h3 id="_8、在-java-程序中怎么保证多线程的运行安全" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%9D%A2%E8%AF%95%E9%A2%98.md#8%E5%9C%A8-java-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E5%AE%89%E5%85%A8" target="_blank" rel="noreferrer">8、在 Java 程序中怎么保证多线程的运行安全？</a> <a class="header-anchor" href="#_8、在-java-程序中怎么保证多线程的运行安全" aria-label="Permalink to &quot;[8、在 Java 程序中怎么保证多线程的运行安全？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题及答案，企业真面试题.md#8在-java-程序中怎么保证多线程的运行安全)&quot;">​</a></h3><p>出现线程安全问题的原因一般都是三个原因：</p><p><strong>1、</strong> 线程切换带来的原子性问题 解决办法：使用多线程之间同步synchronized或使用锁(lock)。</p><p><strong>2、</strong> 缓存导致的可见性问题 解决办法：synchronized、volatile、LOCK，可以解决可见性问题</p><p><strong>3、</strong> 编译优化带来的有序性问题 解决办法：Happens-Before 规则可以解决有序性问题</p><h3 id="_9、怎么获取-java-程序使用的内存-堆使用的百分比" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%9D%A2%E8%AF%95%E9%A2%98.md#9%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96-java-%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%A0%86%E4%BD%BF%E7%94%A8%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94" target="_blank" rel="noreferrer">9、怎么获取 Java 程序使用的内存？堆使用的百分比？</a> <a class="header-anchor" href="#_9、怎么获取-java-程序使用的内存-堆使用的百分比" aria-label="Permalink to &quot;[9、怎么获取 Java 程序使用的内存？堆使用的百分比？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题及答案，企业真面试题.md#9怎么获取-java-程序使用的内存堆使用的百分比)&quot;">​</a></h3><p>可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory()方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。</p><h3 id="_10、你如何确保main-方法所在的线程是java-程序最后结束的线程" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%9D%A2%E8%AF%95%E9%A2%98.md#10%E4%BD%A0%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9Dmain%E6%96%B9%E6%B3%95%E6%89%80%E5%9C%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%98%AFjava-%E7%A8%8B%E5%BA%8F%E6%9C%80%E5%90%8E%E7%BB%93%E6%9D%9F%E7%9A%84%E7%BA%BF%E7%A8%8B" target="_blank" rel="noreferrer">10、你如何确保main()方法所在的线程是Java 程序最后结束的线程？</a> <a class="header-anchor" href="#_10、你如何确保main-方法所在的线程是java-程序最后结束的线程" aria-label="Permalink to &quot;[10、你如何确保main()方法所在的线程是Java 程序最后结束的线程？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程高级面试题及答案，企业真面试题.md#10你如何确保main方法所在的线程是java-程序最后结束的线程)&quot;">​</a></h3><p>我们可以使用Thread类的join()方法来确保所有程序创建的线程在main()方法退出前结束。</p><h3 id="_11、多线程同步和互斥有几种实现方法-都是什么" tabindex="-1">11、多线程同步和互斥有几种实现方法，都是什么？ <a class="header-anchor" href="#_11、多线程同步和互斥有几种实现方法-都是什么" aria-label="Permalink to &quot;11、多线程同步和互斥有几种实现方法，都是什么？&quot;">​</a></h3><h3 id="_12、怎么查看服务器默认的垃圾回收器是哪一个" tabindex="-1">12、怎么查看服务器默认的垃圾回收器是哪一个？ <a class="header-anchor" href="#_12、怎么查看服务器默认的垃圾回收器是哪一个" aria-label="Permalink to &quot;12、怎么查看服务器默认的垃圾回收器是哪一个？&quot;">​</a></h3><h3 id="_13、如何在两个线程间共享数据" tabindex="-1">13、如何在两个线程间共享数据？ <a class="header-anchor" href="#_13、如何在两个线程间共享数据" aria-label="Permalink to &quot;13、如何在两个线程间共享数据？&quot;">​</a></h3><h3 id="_14、谈谈-jvm-中的常量池" tabindex="-1">14、谈谈 JVM 中的常量池 <a class="header-anchor" href="#_14、谈谈-jvm-中的常量池" aria-label="Permalink to &quot;14、谈谈 JVM 中的常量池&quot;">​</a></h3><h3 id="_15、线程池有什么优点" tabindex="-1">15、线程池有什么优点？ <a class="header-anchor" href="#_15、线程池有什么优点" aria-label="Permalink to &quot;15、线程池有什么优点？&quot;">​</a></h3><h3 id="_16、你都有哪些手段用来排查内存溢出" tabindex="-1">16、你都有哪些手段用来排查内存溢出？ <a class="header-anchor" href="#_16、你都有哪些手段用来排查内存溢出" aria-label="Permalink to &quot;16、你都有哪些手段用来排查内存溢出？&quot;">​</a></h3><h3 id="_17、你都用过g1垃圾回收器的哪几个重要参数" tabindex="-1">17、你都用过G1垃圾回收器的哪几个重要参数？ <a class="header-anchor" href="#_17、你都用过g1垃圾回收器的哪几个重要参数" aria-label="Permalink to &quot;17、你都用过G1垃圾回收器的哪几个重要参数？&quot;">​</a></h3><h3 id="_18、说说类加载的过程" tabindex="-1">18、说说类加载的过程 <a class="header-anchor" href="#_18、说说类加载的过程" aria-label="Permalink to &quot;18、说说类加载的过程&quot;">​</a></h3><h3 id="_19、什么是-callable-和-future" tabindex="-1">19、什么是 Callable 和 Future? <a class="header-anchor" href="#_19、什么是-callable-和-future" aria-label="Permalink to &quot;19、什么是 Callable 和 Future?&quot;">​</a></h3><h3 id="_20、什么是内存屏障" tabindex="-1">20、什么是内存屏障？ <a class="header-anchor" href="#_20、什么是内存屏障" aria-label="Permalink to &quot;20、什么是内存屏障？&quot;">​</a></h3><h3 id="_21、栈溢出的原因" tabindex="-1">21、栈溢出的原因？ <a class="header-anchor" href="#_21、栈溢出的原因" aria-label="Permalink to &quot;21、栈溢出的原因？&quot;">​</a></h3><h3 id="_22、你知道哪些故障处理工具" tabindex="-1">22、你知道哪些故障处理工具？ <a class="header-anchor" href="#_22、你知道哪些故障处理工具" aria-label="Permalink to &quot;22、你知道哪些故障处理工具？&quot;">​</a></h3><h3 id="_23、你平时工作中用过的jvm常用基本配置参数有哪些" tabindex="-1">23、你平时工作中用过的JVM常用基本配置参数有哪些？ <a class="header-anchor" href="#_23、你平时工作中用过的jvm常用基本配置参数有哪些" aria-label="Permalink to &quot;23、你平时工作中用过的JVM常用基本配置参数有哪些？&quot;">​</a></h3><h3 id="_24、说说zgc垃圾收集器的工作原理" tabindex="-1">24、说说ZGC垃圾收集器的工作原理 <a class="header-anchor" href="#_24、说说zgc垃圾收集器的工作原理" aria-label="Permalink to &quot;24、说说ZGC垃圾收集器的工作原理&quot;">​</a></h3><h3 id="_25、newscheduledthreadpool" tabindex="-1">25、newScheduledThreadPool <a class="header-anchor" href="#_25、newscheduledthreadpool" aria-label="Permalink to &quot;25、newScheduledThreadPool&quot;">​</a></h3><h3 id="_26、什么是线程调度器-thread-scheduler-和时间分片-time-slicing" tabindex="-1">26、什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？ <a class="header-anchor" href="#_26、什么是线程调度器-thread-scheduler-和时间分片-time-slicing" aria-label="Permalink to &quot;26、什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？&quot;">​</a></h3><h3 id="_27、对象是怎么从年轻代进入老年代的" tabindex="-1">27、对象是怎么从年轻代进入老年代的？ <a class="header-anchor" href="#_27、对象是怎么从年轻代进入老年代的" aria-label="Permalink to &quot;27、对象是怎么从年轻代进入老年代的？&quot;">​</a></h3><h3 id="_28、synchronizedmap-和-concurrenthashmap-有什么区别" tabindex="-1">28、SynchronizedMap 和 ConcurrentHashMap 有什么区别？ <a class="header-anchor" href="#_28、synchronizedmap-和-concurrenthashmap-有什么区别" aria-label="Permalink to &quot;28、SynchronizedMap 和 ConcurrentHashMap 有什么区别？&quot;">​</a></h3><h3 id="_29、你对线程优先级的理解是什么" tabindex="-1">29、你对线程优先级的理解是什么？ <a class="header-anchor" href="#_29、你对线程优先级的理解是什么" aria-label="Permalink to &quot;29、你对线程优先级的理解是什么？&quot;">​</a></h3><h3 id="_30、在-java-中-对象什么时候可以被垃圾回收" tabindex="-1">30、在 Java 中，对象什么时候可以被垃圾回收？ <a class="header-anchor" href="#_30、在-java-中-对象什么时候可以被垃圾回收" aria-label="Permalink to &quot;30、在 Java 中，对象什么时候可以被垃圾回收？&quot;">​</a></h3><h3 id="_31、重排序实际执行的指令步骤" tabindex="-1">31、重排序实际执行的指令步骤 <a class="header-anchor" href="#_31、重排序实际执行的指令步骤" aria-label="Permalink to &quot;31、重排序实际执行的指令步骤&quot;">​</a></h3>',74),n=[E];function s(i,l,h,B,A,c){return e(),o("div",null,n)}const m=a(t,[["render",s]]);export{u as __pageData,m as default};
