import{_ as s,o as a,c as n,V as l}from"./chunks/framework.c6d8cbec.js";const p="/docs/assets/65e8110b-71b1-4146-b2fa-7fc4ee8530af.d6c42fd0.png",o="/docs/assets/e23299c2-a11f-4f0f-a4e5-138fa1fdb331.35e91f65.png",e="/docs/assets/hash-01.3d12a3ac.png",t="/docs/assets/hashmap-resize-01.82879371.png",c="/docs/assets/hashmap-resize-02.49e64509.png",r="/docs/assets/hashmap-resize-03.8258b9cd.png",y="/docs/assets/hashmap-resize-04.fb6a724b.png",F="/docs/assets/hashmap-resize-05.009e4daf.png",i="/docs/assets/hashmap-loadfactor-01.9d4678a5.png",E="data:image/png;base64,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",A="/docs/assets/hashmap-loadfactor-04.075e55eb.png",h="data:image/png;base64,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",C="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAVoAAACMCAMAAAAKn5HCAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAtUExURf///yIlKTk8QM3OzywvMkpNUOvr61haXbe4udzd3ZGSlPb392ttb4CChKCho78glFUAAATySURBVHja7ZzrctsgEEYFLPfL+z9uBUhYdiCtWzS1ou/8CeMkM/ZhvSyw9rIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMD3eCg4BRE4I+2gdzqOkTMpsAgV081ytf5QkhnImIqlqlQyqJ1MYkzkn8SYgo2pRMZ0XsBMtJAxO9WyXB4ImJhfebFKQDo4JWwzEiqmY9YdQwYFwlxU2YOpHLrYMkxFM1J7WkjQMTMXtDywjlB8TS5qt6gNWMZmVweyFrSGGCrbuYuYpGisNZHRReoDF2PQ8gq5S2nKdReFqyTaWoPbvWzUE99rwsUQ9Mw6yRojrnMKbpJsav0aFnzeU697p3DjJGab2rJHFxNjLN5c7dLUqjVqaeobLkDtlmtFnHwS6qD2rEX37moJaqH22moPq5h6ecB7qP1LtVFKTmVodR7pfMEnGQ95Y+mdpHUn9H1p5r9Vu02Nv6Fa2TZmpoz0EimmyPPxqOAypkDflb1J83UaUldtLHMlFuvW3Sq/z93WrlaJuKn1SqyeZZCqbiTIUPTVFB/t8AOTLm/tTE+tLnMlBNcurWOubqZ2VXo4TmDtfFSXCN53woOw1dWhIFIdtcqWaxdKN9tHHJaxZ7WuDuNj+8tHdyemNrSol2rjkGtlu9ISs/d8F1Rrm1r+8JMGO9piS7xcZD+r3YQqdpsbmKFa39Tq36nlW4w7p8Zqt6Gaegh0FbWPoXhPrS6H1MmOiy/dEoz/qpadwEerXf5c7d7X4qB2tlqvtxcU/0rt7RLCG2oXn2rPECmofXo3/qva+k82vLZjQW1HrXlDreV7yaVfyiqo/cfiK+8p1Dbiy7j4up3aQ5l5eNGm6cob0y0oPf9SA2xFrdxHEWpbQSpz4wRJadswLEKXUzCSekmyrE5cxiWU369D8/X8oAWteo3nLeC9bNWDvUmDLPEK2YXqmPhi2qNL3IakF7kPX3OCIOmMskYzfozGNituifusJH+YS/B7RD3q5fG58tqnIix6HzrfZu2knCD0Dzux9MIY+wHHWSIw9DHOX45NipIxqJ2PKckcak/AJqPKJhJqz8m1UAu1UPujyjioPYVem8iPU/s/9jT9NpEfpzb8hwOUfpvIRdU6TdL1C/DD50V8lKT3fnHvNJfxjJgetIlcUq3X3CjDu27942HFKR8yUnlAcIrGRH7C8x+0iVxSrctJzbQrhJcnSXuY6uDr4VbIj9YkLE7oiBu0iVxSrczPItFgQd5/kWoMqXyWbUnvtzruhFTbbRPJn23roj5Y7VroRFNVmQ6BaXtY0LJbasFq5Qlvom6byN74+4X0wWpjOb/Oz0TpDttt1sMmHV6OpxNSf7dNJLf7dvnoCiF3fA8/Oup1/ZT8oxJKx6bjE/o4+20iV8y1Yn0FuaXYDszGKu9xyxjY49p8fkIYtYlcUG2smuQg/MLuLsYWtE63y+84+Zt1xm0iF1RLJad56je/q3YtqLjdzMZy5R3Kd++RnT3RozaRC6qVuY5SWvaD1j2i0uSUIOqXxuYygccUpjcSjNtELqhWSZJy+EGj43bLcKL9m1+WVJa+6ScM4zaRt0gf0j7ixfhFPE+9Pf6lEid0ZwzaRN4JFS1rTwnjUmt85fXBbbdN5B21bO8e4ZwY1D6/iT6jTQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXIRf4bwll02aRuEAAAAASUVORK5CYII=",d="data:image/png;base64,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",u="/docs/assets/hashmap-loadfactor-08.e80c2e95.png",D="/docs/assets/hashmap-loadfactor-09.fb85e1f5.png",f="/docs/assets/hashmap-thread-nosafe-01.09a9b5df.png",g="/docs/assets/hashmap-thread-nosafe-02.ad385eb1.png",b="/docs/assets/hashmap-thread-nosafe-03.5a31db68.png",m="/docs/assets/hashmap-thread-nosafe-02.ad385eb1.png",v="/docs/assets/hashmap-thread-nosafe-05.6f240fba.png",T="/docs/assets/hashmap-thread-nosafe-06.1df440e3.png",k="/docs/assets/hashmap-thread-nosafe-07.6dceff4f.png",B="/docs/assets/hashmap-thread-nosafe-08.73f59783.png",q="/docs/assets/hashmap-thread-nosafe-09.aca28e35.png",M="/docs/assets/hashmap-thread-nosafe-10.85b9ba5b.png",K=JSON.parse('{"title":"Java HashMap详解：源码分析与实际应用指南","description":"本文详细解析了 Java HashMap 的实现原理、功能特点以及源码，为您提供了 HashMap 的实际应用示例和性能优化建议。阅读本文，将帮助您更深入地理解 HashMap，从而在实际编程中充分发挥其优势。","frontmatter":{"title":"Java HashMap详解：源码分析与实际应用指南","shortTitle":"HashMap详解（附源码）","category":["Java核心"],"tag":["集合框架（容器）"],"description":"本文详细解析了 Java HashMap 的实现原理、功能特点以及源码，为您提供了 HashMap 的实际应用示例和性能优化建议。阅读本文，将帮助您更深入地理解 HashMap，从而在实际编程中充分发挥其优势。","head":[["meta",{"name":"keywords","content":"Java,HashMap,java hashmap, 源码分析, 实现原理"}]]},"headers":[],"relativePath":"backend/tobetter/collection/hashmap.md","filePath":"backend/tobetter/collection/hashmap.md"}'),w={name:"backend/tobetter/collection/hashmap.md"},I=l(`<h1 id="_6-9-hashmap详解-附源码" tabindex="-1">6.9 HashMap详解（附源码） <a class="header-anchor" href="#_6-9-hashmap详解-附源码" aria-label="Permalink to &quot;6.9 HashMap详解（附源码）&quot;">​</a></h1><p>这篇文章将通过源码的方式，详细透彻地讲清楚 Java 的 HashMap，包括 hash 方法的原理、HashMap 的扩容机制、HashMap的加载因子为什么是 0.75 而不是 0.6、0.8，以及 HashMap 为什么是线程不安全的，基本上 HashMap 的<a href="https://tobebetterjavaer.com/interview/java-hashmap-13.html" target="_blank" rel="noreferrer">常见面试题</a>，都会在这一篇文章里讲明白。</p><p>HashMap 是 Java 中常用的数据结构之一，用于存储键值对。在 HashMap 中，每个键都映射到一个唯一的值，可以通过键来快速访问对应的值。</p><p>HashMap 不仅在日常开发中经常用到，在面试中也是重点考察的对象。</p><p>以下是 HashMap 增删改查的简单例子：</p><p><strong>1）增加元素</strong>：</p><p>将一个键值对（元素）添加到 HashMap 中，可以使用 put() 方法。例如，将名字和年龄作为键值对添加到 HashMap 中：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">HashMap</span><span style="color:#F6F6F4;">&lt;String, Integer&gt; map </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">HashMap</span><span style="color:#F6F6F4;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#BF9EEE;">20</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#BF9EEE;">25</span><span style="color:#F6F6F4;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">HashMap&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; map </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> HashMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;沉默&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">20</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;王二&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">25</span><span style="color:#24292E;">);</span></span></code></pre></div><p><strong>2）删除元素</strong>：</p><p>从 HashMap 中删除一个键值对，可以使用 remove() 方法。例如，删除名字为 &quot;沉默&quot; 的键值对：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">remove</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;沉默&quot;</span><span style="color:#24292E;">);</span></span></code></pre></div><p><strong>3）修改元素</strong>：</p><p>修改 HashMap 中的一个键值对，可以使用 put() 方法。例如，将名字为 &quot;沉默&quot; 的年龄修改为 30：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#BF9EEE;">30</span><span style="color:#F6F6F4;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;沉默&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">30</span><span style="color:#24292E;">);</span></span></code></pre></div><p>为什么和添加元素的方法一样呢？这个我们后面会讲，先简单说一下，是因为 HashMap 的键是唯一的，所以再次 put 的时候会覆盖掉之前的键值对。</p><p><strong>4）查找元素</strong>：</p><p>从 HashMap 中查找一个键对应的值，可以使用 get() 方法。例如，查找名字为 &quot;沉默&quot; 的年龄：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> age </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> map.</span><span style="color:#62E884;">get</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> age </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> map.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;沉默&quot;</span><span style="color:#24292E;">);</span></span></code></pre></div><p>在实际应用中，HashMap 可以用于缓存、索引等场景。例如，可以将用户 ID 作为键，用户信息作为值，将用户信息缓存到 HashMap 中，以便快速查找。又如，可以将关键字作为键，文档 ID 列表作为值，将文档索引缓存到 HashMap 中，以便快速搜索文档。</p><p>HashMap 的实现原理是基于哈希表的，它的底层是一个数组，数组的每个位置可能是一个链表或红黑树，也可能只是一个键值对（后面会讲）。当添加一个键值对时，HashMap 会根据键的哈希值计算出该键对应的数组下标（索引），然后将键值对插入到对应的位置。</p><p>当通过键查找值时，HashMap 也会根据键的哈希值计算出数组下标，并查找对应的值。</p><h3 id="_01、hash方法的原理" tabindex="-1">01、hash方法的原理 <a class="header-anchor" href="#_01、hash方法的原理" aria-label="Permalink to &quot;01、hash方法的原理&quot;">​</a></h3><p>简单了解 HashMap 后，我们来讨论第一个问题：hash 方法的原理，对吃透 HashMap 会大有帮助。</p><p>来看一下 hash 方法的源码（JDK 8 中的 HashMap）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">static</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">hash</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">Object</span><span style="color:#F6F6F4;"> key) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> h;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> (key </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> (h </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> key.</span><span style="color:#62E884;">hashCode</span><span style="color:#F6F6F4;">()) </span><span style="color:#F286C4;">^</span><span style="color:#F6F6F4;"> (h </span><span style="color:#F286C4;">&gt;&gt;&gt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">16</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">hash</span><span style="color:#24292E;">(Object key) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> h;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (key </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> key.</span><span style="color:#6F42C1;">hashCode</span><span style="color:#24292E;">()) </span><span style="color:#D73A49;">^</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">&gt;&gt;&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">16</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这段代码究竟是用来干嘛的呢？</p><p><strong>将 key 的 hashCode 值进行处理，得到最终的哈希值</strong>。</p><p>怎么理解这句话呢？不要着急。</p><p>我们来 new 一个 HashMap，并通过 put 方法添加一个元素。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">HashMap</span><span style="color:#F6F6F4;">&lt;String, String&gt; map </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">HashMap</span><span style="color:#F6F6F4;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">chenmo</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">HashMap&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; map </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> HashMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;chenmo&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默&quot;</span><span style="color:#24292E;">);</span></span></code></pre></div><p>来看一下 put 方法的源码。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">public</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">V</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">K</span><span style="color:#F6F6F4;"> key, </span><span style="color:#97E1F1;font-style:italic;">V</span><span style="color:#F6F6F4;"> value) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">putVal</span><span style="color:#F6F6F4;">(</span><span style="color:#62E884;">hash</span><span style="color:#F6F6F4;">(key), key, value, </span><span style="color:#BF9EEE;">false</span><span style="color:#F6F6F4;">, </span><span style="color:#BF9EEE;">true</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> V </span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(K key, V value) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">putVal</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">hash</span><span style="color:#24292E;">(key), key, value, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>看到 hash 方法的身影了吧？</p><h4 id="hash-方法的作用" tabindex="-1">hash 方法的作用 <a class="header-anchor" href="#hash-方法的作用" aria-label="Permalink to &quot;hash 方法的作用&quot;">​</a></h4><p>前面也说了，HashMap 的底层是通过数组的形式实现的，初始大小是 16（这个后面会讲），先记住。</p><p>也就是说，HashMap 在添加第一个元素的时候，需要通过键的哈希码在大小为 16 的数组中确定一个位置（索引），怎么确定呢？</p><p>为了方便大家直观的感受，我这里画了一副图，16 个方格子（可以把它想象成一个一个桶），每个格子都有一个编号，对应大小为 16 的数组下标（索引）。</p><img src="`+p+'"><p>现在，我们要把 key 为 “chenmo”，value 为“沉默”的键值对放到这 16 个格子中的一个。</p><p>怎么确定位置（索引）呢？</p><p>我先告诉大家结论，通过这个与运算 <code>(n - 1) &amp; hash</code>，其中变量 n 为数组的长度，变量 hash 就是通过 <code>hash()</code> 方法计算后的结果。</p><p>那“chenmo”这个 key 计算后的位置（索引）是多少呢？</p><p>答案是 8，也就是说 <code>map.put(&quot;chenmo&quot;, &quot;沉默&quot;)</code> 会把key 为 “chenmo”，value 为“沉默”的键值对放到下标为 8 的位置上（也就是索引为 8 的桶上）。</p><img src="'+o+`"><p>这样大家就会对 HashMap 存放键值对（元素）的时候有一个大致的印象。其中的一点是，hash 方法对计算键值对的位置起到了至关重要的作用。</p><p>回到 hash 方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">static</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">hash</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">Object</span><span style="color:#F6F6F4;"> key) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> h;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> (key </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> (h </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> key.</span><span style="color:#62E884;">hashCode</span><span style="color:#F6F6F4;">()) </span><span style="color:#F286C4;">^</span><span style="color:#F6F6F4;"> (h </span><span style="color:#F286C4;">&gt;&gt;&gt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">16</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">hash</span><span style="color:#24292E;">(Object key) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> h;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (key </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> key.</span><span style="color:#6F42C1;">hashCode</span><span style="color:#24292E;">()) </span><span style="color:#D73A49;">^</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">&gt;&gt;&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">16</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>下面是对该方法的一些解释：</p><ul><li>参数 key：需要计算哈希码的键值。</li><li><code>key == null ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>：这是一个三目运算符，如果键值为null，则哈希码为0（依旧是说如果键为 null，则存放在第一个位置）；否则，通过调用<code>hashCode()</code>方法获取键的哈希码，并将其与右移16位的哈希码进行异或运算。</li><li><code>^</code> 运算符：异或运算符是Java中的一种位运算符，它用于将两个数的二进制位进行比较，如果相同则为0，不同则为1。</li><li><code>h &gt;&gt;&gt; 16</code>：将哈希码向右移动16位，相当于将原来的哈希码分成了两个16位的部分。</li><li>最终返回的是经过异或运算后得到的哈希码值。</li></ul><p>这短短的一行代码，汇聚不少计算机巨佬们的聪明才智。</p><p>理论上，哈希值（哈希码）是一个 int 类型，范围从-2147483648 到 2147483648。前后加起来大概 40 亿的映射空间，只要哈希值映射得比较均匀松散，一般是不会出现哈希碰撞（哈希冲突会降低 HashMap 的效率）。</p><p>但问题是一个 40 亿长度的数组，内存是放不下的。HashMap 扩容之前的数组初始大小只有 16，所以这个哈希值是不能直接拿来用的，用之前要和数组的长度做取模运算（前文提到的 <code>(n - 1) &amp; hash</code>），用得到的余数来访问数组下标才行。</p><h4 id="取模运算" tabindex="-1">取模运算 <a class="header-anchor" href="#取模运算" aria-label="Permalink to &quot;取模运算&quot;">​</a></h4><p>取模运算（（“Modulo Operation”））和取余运算（（“Remainder Operation ”））是两种不同的运算方式，它们在计算机中的实现也不同。</p><p>在数学中，取模运算和取余运算是等价的，都是计算一个数除以另一个数的余数。例如，10 mod 3 和 10 % 3 都等于 1，因为 10 除以 3 的余数是 1。</p><p>在计算机中，取模运算和取余运算的差别在于，当被除数为负数时，<strong>取模运算的结果符号与被除数相同，取余运算的结果符号与除数相同</strong>。</p><p>例如，-10 mod 3 的结果是 -1，而 -10 % 3 的结果是 2，因为 -10 除以 3 的余数是 -1，所以 -10 取模 3 的结果应该是 -1；而 -10 对 3 取余的结果是 2，因为：-10 ÷ 3 = -3 余 -1，由于除数为正数 3，余数的符号应与被除数的符号相同，因此余数应为正数 2，而不是 -1。</p><p>在 Java 中，取模运算使用 % 运算符，取余运算使用 <code>Math.floorMod()</code> 方法。例如，计算 -10 mod 3 和 -10 % 3 的结果：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> a </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">-</span><span style="color:#BF9EEE;">10</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">%</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">3</span><span style="color:#F6F6F4;">; </span><span style="color:#7B7F8B;">// a = -1</span></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> b </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> Math.</span><span style="color:#62E884;">floorMod</span><span style="color:#F6F6F4;">(</span><span style="color:#F286C4;">-</span><span style="color:#BF9EEE;">10</span><span style="color:#F6F6F4;">, </span><span style="color:#BF9EEE;">3</span><span style="color:#F6F6F4;">); </span><span style="color:#7B7F8B;">// b = 2</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">10</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">%</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// a = -1</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">floorMod</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// b = 2</span></span></code></pre></div><p>需要注意的是，在数学中，取模运算和取余运算都有定义域的限制，即除数不能为 0。在计算机中，除数为 0 会抛出异常或返回 NaN（Not a Number）。</p><p>HashMap 的取模运算有两处。</p><p>一处是往 HashMap 中 put 的时候（会调用私有的 <code>putVal</code> 方法）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">V</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">putVal</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> hash, </span><span style="color:#97E1F1;font-style:italic;">K</span><span style="color:#F6F6F4;"> key, </span><span style="color:#97E1F1;font-style:italic;">V</span><span style="color:#F6F6F4;"> value, </span><span style="color:#97E1F1;font-style:italic;">boolean</span><span style="color:#F6F6F4;"> onlyIfAbsent, </span><span style="color:#97E1F1;font-style:italic;">boolean</span><span style="color:#F6F6F4;"> evict) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 数组</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">HashMap</span><span style="color:#F6F6F4;">.</span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt;[] tab; </span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 元素</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">HashMap</span><span style="color:#F6F6F4;">.</span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt; p; </span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// n 为数组的长度 i 为下标</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> n, i;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 数组为空的时候</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> ((tab </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> table) </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">||</span><span style="color:#F6F6F4;"> (n </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> tab.length) </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">)</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#7B7F8B;">// 第一次扩容后的数组长度</span></span>
<span class="line"><span style="color:#F6F6F4;">        n </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (tab </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">resize</span><span style="color:#F6F6F4;">()).length;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 计算节点的插入位置，如果该位置为空，则新建一个节点插入</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> ((p </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> tab[i </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (n </span><span style="color:#F286C4;">-</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;"> hash]) </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">)</span></span>
<span class="line"><span style="color:#F6F6F4;">        tab[i] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">newNode</span><span style="color:#F6F6F4;">(hash, key, value, </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> V </span><span style="color:#6F42C1;">putVal</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> hash, K key, V value, </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> onlyIfAbsent, </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> evict) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 数组</span></span>
<span class="line"><span style="color:#24292E;">    HashMap.Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt;[] tab; </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 元素</span></span>
<span class="line"><span style="color:#24292E;">    HashMap.Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; p; </span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// n 为数组的长度 i 为下标</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> n, i;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 数组为空的时候</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((tab </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> table) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tab.length) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 第一次扩容后的数组长度</span></span>
<span class="line"><span style="color:#24292E;">        n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (tab </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">resize</span><span style="color:#24292E;">()).length;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 计算节点的插入位置，如果该位置为空，则新建一个节点插入</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tab[i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> hash]) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        tab[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">newNode</span><span style="color:#24292E;">(hash, key, value, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>其中 <code>(n - 1) &amp; hash</code> 为取模运算，为什么没用 <code>%</code>，我们随后解释。</p><p>一处是从 HashMap 中 get 的时候（会调用 <code>getNode</code> 方法）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;">K,V</span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">getNode</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> hash, </span><span style="color:#97E1F1;font-style:italic;">Object</span><span style="color:#F6F6F4;"> key) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 获取当前的数组和长度，以及当前节点链表的第一个节点（根据索引直接从数组中找）</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt;[] tab; </span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt; first, e; </span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> n; </span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">K</span><span style="color:#F6F6F4;"> k;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> ((tab </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> table) </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">&amp;&amp;</span><span style="color:#F6F6F4;"> (n </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> tab.length) </span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">&amp;&amp;</span></span>
<span class="line"><span style="color:#F6F6F4;">            (first </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> tab[(n </span><span style="color:#F286C4;">-</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;"> hash]) </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#7B7F8B;">// 如果第一个节点就是要查找的节点，则直接返回</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (first.hash </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> hash </span><span style="color:#F286C4;">&amp;&amp;</span><span style="color:#F6F6F4;"> ((k </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> first.key) </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> key </span><span style="color:#F286C4;">||</span><span style="color:#F6F6F4;"> (key </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">&amp;&amp;</span><span style="color:#F6F6F4;"> key.</span><span style="color:#62E884;">equals</span><span style="color:#F6F6F4;">(k))))</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> first;</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#7B7F8B;">// 如果第一个节点不是要查找的节点，则遍历节点链表查找</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> ((e </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> first.next) </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">do</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">                </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (e.hash </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> hash </span><span style="color:#F286C4;">&amp;&amp;</span><span style="color:#F6F6F4;"> ((k </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e.key) </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> key </span><span style="color:#F286C4;">||</span><span style="color:#F6F6F4;"> (key </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">&amp;&amp;</span><span style="color:#F6F6F4;"> key.</span><span style="color:#62E884;">equals</span><span style="color:#F6F6F4;">(k))))</span></span>
<span class="line"><span style="color:#F6F6F4;">                    </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> e;</span></span>
<span class="line"><span style="color:#F6F6F4;">            } </span><span style="color:#F286C4;">while</span><span style="color:#F6F6F4;"> ((e </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e.next) </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">        }</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 如果节点链表中没有找到对应的节点，则返回 null</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getNode</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> hash, Object key) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取当前的数组和长度，以及当前节点链表的第一个节点（根据索引直接从数组中找）</span></span>
<span class="line"><span style="color:#24292E;">    Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt;[] tab; </span></span>
<span class="line"><span style="color:#24292E;">    Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; first, e; </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> n; </span></span>
<span class="line"><span style="color:#24292E;">    K k;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((tab </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> table) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tab.length) </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">            (first </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tab[(n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> hash]) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果第一个节点就是要查找的节点，则直接返回</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (first.hash </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> hash </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> ((k </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> first.key) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> key </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (key </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> key.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(k))))</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> first;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果第一个节点不是要查找的节点，则遍历节点链表查找</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> first.next) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">do</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (e.hash </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> hash </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> ((k </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e.key) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> key </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (key </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> key.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(k))))</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> e;</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> ((e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e.next) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果节点链表中没有找到对应的节点，则返回 null</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>看到没，取模运算 <code>(n - 1) &amp; hash</code> 再次出现，说简单点，就是把键的哈希码经过 <code>hash()</code> 方法计算后，再和（数组长度-1）做了一个“与”运算。</p><h4 id="取模运算-和位运算" tabindex="-1">取模运算%和位运算&amp; <a class="header-anchor" href="#取模运算-和位运算" aria-label="Permalink to &quot;取模运算%和位运算&amp;&quot;">​</a></h4><p>可能大家在疑惑：<strong>取模运算难道不该用 <code>%</code> 吗？为什么要用位运算 <code>&amp;</code> 呢</strong>？</p><p>这是因为 <code>&amp;</code> 运算比 <code>%</code> 更加高效，并且当 b 为 2 的 n 次方时，存在下面这样一个公式。</p><blockquote><p>a % b = a &amp; (b-1)</p></blockquote><p>用 $2^n$ 替换下 b 就是：</p><blockquote><p>a % $2^n$ = a &amp; ($2^n$-1)</p></blockquote><p>我们来验证一下，假如 a = 14，b = 8，也就是 $2^3$，n=3。</p><p>14%8（余数为 6）。</p><p>14 的二进制为 1110，8 的二进制 1000，8-1 = 7，7 的二进制为 0111，1110&amp;0111=0110，也就是 0<code>*</code>$2^0$+1<code>*</code>$2^1$+1<code>*</code>$2^2$+0<code>*</code>$2^3$=0+2+4+0=6，14%8 刚好也等于 6。</p><p>害，计算机就是这么讲道理，没办法，😝</p><p>这也正好解释了为什么 HashMap 的数组长度要取 2 的整次方。</p><p>为什么会这样巧呢？</p><p>因为（数组长度-1）正好相当于一个“低位掩码”——这个掩码的低位最好全是 1，这样 &amp; 操作才有意义，否则结果就肯定是 0，那么 &amp; 操作就没有意义了。</p><blockquote><p>a&amp;b 操作的结果是：a、b 中对应位同时为 1，则对应结果位为 1，否则为 0</p></blockquote><p>2 的整次幂刚好是偶数，偶数-1 是奇数，奇数的二进制最后一位是 1，保证了 hash &amp;(length-1) 的最后一位可能为 0，也可能为 1（这取决于 h 的值），即 &amp; 运算后的结果可能为偶数，也可能为奇数，这样便可以保证哈希值的均匀性。</p><p>&amp; 操作的结果就是将哈希值的高位全部归零，只保留低位值，用来做数组下标访问。</p><p>假设某哈希值为 <code>10100101 11000100 00100101</code>，用它来做取模运算，我们来看一下结果。HashMap 的初始长度为 16（内部是数组），16-1=15，二进制是 <code>00000000 00000000 00001111</code>（高位用 0 来补齐）：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">10100101 11000100 00100101</span></span>
<span class="line"><span style="color:#f6f6f4;">&amp;	00000000 00000000 00001111</span></span>
<span class="line"><span style="color:#f6f6f4;">----------------------------------</span></span>
<span class="line"><span style="color:#f6f6f4;">	 00000000 00000000 00000101</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">10100101 11000100 00100101</span></span>
<span class="line"><span style="color:#24292e;">&amp;	00000000 00000000 00001111</span></span>
<span class="line"><span style="color:#24292e;">----------------------------------</span></span>
<span class="line"><span style="color:#24292e;">	 00000000 00000000 00000101</span></span></code></pre></div><p>因为 15 的高位全部是 0，所以 &amp; 运算后的高位结果肯定是 0，只剩下 4 个低位 <code>0101</code>，也就是十进制的 5，也就是将哈希值为 <code>10100101 11000100 00100101</code> 的键放在数组的第 5 位。</p><p>当然了，如果你是新手，上面这些 01 串没看懂，也没关系，记住取模运算就行了，记不住取模运算也没关系，记住<strong>取模运算是为了计算数组的下标就可以了</strong>。</p><ul><li>put 的时候计算下标，把键值对放到对应的桶上。</li><li>get 的时候通过下标，把键值对从对应的桶上取出来。</li></ul><h4 id="为什么取模运算之前要调用-hash-方法呢" tabindex="-1">为什么取模运算之前要调用 hash 方法呢？ <a class="header-anchor" href="#为什么取模运算之前要调用-hash-方法呢" aria-label="Permalink to &quot;为什么取模运算之前要调用 hash 方法呢？&quot;">​</a></h4><p>看下面这个图。</p><img src="`+e+`"><p>某哈希值为 <code>11111111 11111111 11110000 1110 1010</code>，将它右移 16 位（h &gt;&gt;&gt; 16），刚好是 <code>00000000 00000000 11111111 11111111</code>，再进行异或操作（h ^ (h &gt;&gt;&gt; 16)），结果是 <code>11111111 11111111 00001111 00010101</code></p><blockquote><p>异或（<code>^</code>）运算是基于二进制的位运算，采用符号 XOR 或者<code>^</code>来表示，运算规则是：如果是同值取 0、异值取 1</p></blockquote><p>由于混合了原来哈希值的高位和低位，所以低位的随机性加大了（掺杂了部分高位的特征，高位的信息也得到了保留）。</p><p>结果再与数组长度-1（<code>00000000 00000000 00000000 00001111</code>）做取模运算，得到的下标就是 <code>00000000 00000000 00000000 00000101</code>，也就是 5。</p><p>还记得之前我们假设的某哈希值 <code>10100101 11000100 00100101</code> 吗？在没有调用 hash 方法之前，与 15 做取模运算后的结果也是 5，我们不妨来看看调用 hash 之后的取模运算结果是多少。</p><p>某哈希值 <code>00000000 10100101 11000100 00100101</code>（补齐 32 位），将它右移 16 位（h &gt;&gt;&gt; 16），刚好是 <code>00000000 00000000 00000000 10100101</code>，再进行异或操作（h ^ (h &gt;&gt;&gt; 16)），结果是 <code>00000000 10100101 00111011 10000000</code></p><p>结果再与数组长度-1（<code>00000000 00000000 00000000 00001111</code>）做取模运算，得到的下标就是 <code>00000000 00000000 00000000 00000000</code>，也就是 0。</p><p>综上所述，<strong>hash 方法是用来做哈希值优化的</strong>，把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了随机性。</p><p>说白了，<strong>hash 方法就是为了增加随机性，让数据元素更加均衡的分布，减少碰撞</strong>。</p><p>我这里写了一段测试代码，假如 HashMap 的容量就是第一次扩容时候的 16，我在里面放了五个键值对，来看一下键的 hash 值（经过 <code>hash()</code> 方法计算后的哈希码）和索引（取模运算后）</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">HashMap</span><span style="color:#F6F6F4;">&lt;String, String&gt; map </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">HashMap</span><span style="color:#F6F6F4;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">chenmo</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">wanger</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">chenqingyang</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">陈清扬</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">xiaozhuanling</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">小转铃</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">fangxiaowan</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">方小婉</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">// 遍历 HashMap</span></span>
<span class="line"><span style="color:#F286C4;">for</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">String</span><span style="color:#F6F6F4;"> key </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> map.</span><span style="color:#62E884;">keySet</span><span style="color:#F6F6F4;">()) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> h, n </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">16</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> hash </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (key </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> (h </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> key.</span><span style="color:#62E884;">hashCode</span><span style="color:#F6F6F4;">()) </span><span style="color:#F286C4;">^</span><span style="color:#F6F6F4;"> (h </span><span style="color:#F286C4;">&gt;&gt;&gt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">16</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> i </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (n </span><span style="color:#F286C4;">-</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;"> hash;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 打印 key 的 hash 值 和 索引 i</span></span>
<span class="line"><span style="color:#F6F6F4;">    System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(key </span><span style="color:#F286C4;">+</span><span style="color:#F6F6F4;"> </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">的hash值 : </span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">+</span><span style="color:#F6F6F4;"> hash </span><span style="color:#F286C4;">+</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;"> 的索引 : </span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">+</span><span style="color:#F6F6F4;"> i);</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">HashMap&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; map </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> HashMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;chenmo&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;wanger&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;chenqingyang&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;陈清扬&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;xiaozhuanling&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;小转铃&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;fangxiaowan&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;方小婉&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 遍历 HashMap</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (String key </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> map.</span><span style="color:#6F42C1;">keySet</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> h, n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">16</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> hash </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (key </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> key.</span><span style="color:#6F42C1;">hashCode</span><span style="color:#24292E;">()) </span><span style="color:#D73A49;">^</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">&gt;&gt;&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">16</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> hash;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 打印 key 的 hash 值 和 索引 i</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(key </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;的hash值 : &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> hash </span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 的索引 : &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> i);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>输出结果如下所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">xiaozhuanling的hash值 : 14597045 的索引 : 5</span></span>
<span class="line"><span style="color:#f6f6f4;">fangxiaowan的hash值 : -392727066 的索引 : 6</span></span>
<span class="line"><span style="color:#f6f6f4;">chenmo的hash值 : -1361556696 的索引 : 8</span></span>
<span class="line"><span style="color:#f6f6f4;">chenqingyang的hash值 : -613818743 的索引 : 9</span></span>
<span class="line"><span style="color:#f6f6f4;">wanger的hash值 : -795084437 的索引 : 11</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">xiaozhuanling的hash值 : 14597045 的索引 : 5</span></span>
<span class="line"><span style="color:#24292e;">fangxiaowan的hash值 : -392727066 的索引 : 6</span></span>
<span class="line"><span style="color:#24292e;">chenmo的hash值 : -1361556696 的索引 : 8</span></span>
<span class="line"><span style="color:#24292e;">chenqingyang的hash值 : -613818743 的索引 : 9</span></span>
<span class="line"><span style="color:#24292e;">wanger的hash值 : -795084437 的索引 : 11</span></span></code></pre></div><p>也就是说，此时还没有发生哈希冲突，索引值都是比较均匀分布的，5、6、8、9、11，这其中的很大一部分功劳，就来自于 hash 方法。</p><h4 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h4><p>hash 方法的主要作用是将 key 的 hashCode 值进行处理，得到最终的哈希值。由于 key 的 hashCode 值是不确定的，可能会出现哈希冲突，因此需要将哈希值通过一定的算法映射到 HashMap 的实际存储位置上。</p><p>hash 方法的原理是，先获取 key 对象的 hashCode 值，然后将其高位与低位进行异或操作，得到一个新的哈希值。为什么要进行异或操作呢？因为对于 hashCode 的高位和低位，它们的分布是比较均匀的，如果只是简单地将它们加起来或者进行位运算，容易出现哈希冲突，而异或操作可以避免这个问题。</p><p>然后将新的哈希值取模（mod），得到一个实际的存储位置。这个取模操作的目的是将哈希值映射到桶（Bucket）的索引上，桶是 HashMap 中的一个数组，每个桶中会存储着一个链表（或者红黑树），装载哈希值相同的键值对（没有相同哈希值的话就只存储一个键值对）。</p><p>总的来说，HashMap 的 hash 方法就是将 key 对象的 hashCode 值进行处理，得到最终的哈希值，并通过一定的算法映射到实际的存储位置上。这个过程决定了 HashMap 内部键值对的查找效率。</p><h3 id="_02、hashmap的扩容机制" tabindex="-1">02、HashMap的扩容机制 <a class="header-anchor" href="#_02、hashmap的扩容机制" aria-label="Permalink to &quot;02、HashMap的扩容机制&quot;">​</a></h3><p>好，理解了 hash 方法后我们来看第二个问题，HashMap 的扩容机制。</p><p>大家都知道，数组一旦初始化后大小就无法改变了，所以就有了 <a href="https://tobebetterjavaer.com/collection/arraylist.html" target="_blank" rel="noreferrer">ArrayList</a>这种“动态数组”，可以自动扩容。</p><p>HashMap 的底层用的也是数组。向 HashMap 里不停地添加元素，当数组无法装载更多元素时，就需要对数组进行扩容，以便装入更多的元素；除此之外，容量的提升也会相应地提高查询效率，因为“桶（坑）”更多了嘛，原来需要通过链表存储的（查询的时候需要遍历），扩容后可能就有自己专属的“坑位”了（直接就能查出来）。</p><p>来看这个例子，容量我们定位 16：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">HashMap</span><span style="color:#F6F6F4;">&lt;String, String&gt; map </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">HashMap</span><span style="color:#F6F6F4;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">chenmo</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">wanger</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">chenqingyang</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">陈清扬</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">xiaozhuanling</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">小转铃</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">fangxiaowan</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">方小婉</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">yexin</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">叶辛</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">liuting</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">,</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">刘婷</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">map.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">yaoxiaojuan</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">,</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">姚小娟</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">// 遍历 HashMap</span></span>
<span class="line"><span style="color:#F286C4;">for</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">String</span><span style="color:#F6F6F4;"> key </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> map.</span><span style="color:#62E884;">keySet</span><span style="color:#F6F6F4;">()) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> h, n </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">16</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> hash </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (key </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> (h </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> key.</span><span style="color:#62E884;">hashCode</span><span style="color:#F6F6F4;">()) </span><span style="color:#F286C4;">^</span><span style="color:#F6F6F4;"> (h </span><span style="color:#F286C4;">&gt;&gt;&gt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">16</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> i </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (n </span><span style="color:#F286C4;">-</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;"> hash;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 打印 key 的 hash 值 和 索引 i</span></span>
<span class="line"><span style="color:#F6F6F4;">    System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(key </span><span style="color:#F286C4;">+</span><span style="color:#F6F6F4;"> </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">的hash值 : </span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">+</span><span style="color:#F6F6F4;"> hash </span><span style="color:#F286C4;">+</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;"> 的索引 : </span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">+</span><span style="color:#F6F6F4;"> i);</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">HashMap&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; map </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> HashMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;chenmo&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;wanger&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;chenqingyang&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;陈清扬&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;xiaozhuanling&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;小转铃&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;fangxiaowan&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;方小婉&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;yexin&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;叶辛&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;liuting&quot;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&quot;刘婷&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">map.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;yaoxiaojuan&quot;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&quot;姚小娟&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 遍历 HashMap</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (String key </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> map.</span><span style="color:#6F42C1;">keySet</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> h, n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">16</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> hash </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (key </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> key.</span><span style="color:#6F42C1;">hashCode</span><span style="color:#24292E;">()) </span><span style="color:#D73A49;">^</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">&gt;&gt;&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">16</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> hash;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 打印 key 的 hash 值 和 索引 i</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(key </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;的hash值 : &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> hash </span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 的索引 : &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> i);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>来看输出结果：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">liuting的hash值 : 183821170 的索引 : 2</span></span>
<span class="line"><span style="color:#f6f6f4;">xiaozhuanling的hash值 : 14597045 的索引 : 5</span></span>
<span class="line"><span style="color:#f6f6f4;">fangxiaowan的hash值 : -392727066 的索引 : 6</span></span>
<span class="line"><span style="color:#f6f6f4;">yaoxiaojuan的hash值 : 1231568918 的索引 : 6</span></span>
<span class="line"><span style="color:#f6f6f4;">chenmo的hash值 : -1361556696 的索引 : 8</span></span>
<span class="line"><span style="color:#f6f6f4;">chenqingyang的hash值 : -613818743 的索引 : 9</span></span>
<span class="line"><span style="color:#f6f6f4;">yexin的hash值 : 114873289 的索引 : 9</span></span>
<span class="line"><span style="color:#f6f6f4;">wanger的hash值 : -795084437 的索引 : 11</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">liuting的hash值 : 183821170 的索引 : 2</span></span>
<span class="line"><span style="color:#24292e;">xiaozhuanling的hash值 : 14597045 的索引 : 5</span></span>
<span class="line"><span style="color:#24292e;">fangxiaowan的hash值 : -392727066 的索引 : 6</span></span>
<span class="line"><span style="color:#24292e;">yaoxiaojuan的hash值 : 1231568918 的索引 : 6</span></span>
<span class="line"><span style="color:#24292e;">chenmo的hash值 : -1361556696 的索引 : 8</span></span>
<span class="line"><span style="color:#24292e;">chenqingyang的hash值 : -613818743 的索引 : 9</span></span>
<span class="line"><span style="color:#24292e;">yexin的hash值 : 114873289 的索引 : 9</span></span>
<span class="line"><span style="color:#24292e;">wanger的hash值 : -795084437 的索引 : 11</span></span></code></pre></div><p>看到没？</p><ul><li>fangxiaowan（方小婉）和 yaoxiaojuan（姚小娟）的索引都是 6；</li><li>chenqingyang（陈清扬）和yexin（叶辛）的索引都是 9</li></ul><p>这就意味着，要采用拉链法（后面会讲）将他们放在同一个索引的链表上。查询的时候，就不能直接通过索引的方式直接拿到（<a href="https://tobebetterjavaer.com/collection/time-complexity.html" target="_blank" rel="noreferrer">时间复杂度</a>为 O(1)），而要通过遍历的方式（时间复杂度为 O(n)）。</p><p>那假如把数组的长度由 16 扩容为 32 呢？</p><p>将之前示例中的 n 由 16 改为 32 即可得到如下的答案：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F6F6F4;">liuting的hash值 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">183821170</span><span style="color:#F6F6F4;"> 的索引 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">18</span></span>
<span class="line"><span style="color:#F6F6F4;">xiaozhuanling的hash值 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">14597045</span><span style="color:#F6F6F4;"> 的索引 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">21</span></span>
<span class="line"><span style="color:#F6F6F4;">fangxiaowan的hash值 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">-</span><span style="color:#BF9EEE;">392727066</span><span style="color:#F6F6F4;"> 的索引 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">6</span></span>
<span class="line"><span style="color:#F6F6F4;">yaoxiaojuan的hash值 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1231568918</span><span style="color:#F6F6F4;"> 的索引 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">22</span></span>
<span class="line"><span style="color:#F6F6F4;">chenmo的hash值 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">-</span><span style="color:#BF9EEE;">1361556696</span><span style="color:#F6F6F4;"> 的索引 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">8</span></span>
<span class="line"><span style="color:#F6F6F4;">chenqingyang的hash值 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">-</span><span style="color:#BF9EEE;">613818743</span><span style="color:#F6F6F4;"> 的索引 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">9</span></span>
<span class="line"><span style="color:#F6F6F4;">yexin的hash值 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">114873289</span><span style="color:#F6F6F4;"> 的索引 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">9</span></span>
<span class="line"><span style="color:#F6F6F4;">wanger的hash值 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">-</span><span style="color:#BF9EEE;">795084437</span><span style="color:#F6F6F4;"> 的索引 </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">11</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">liuting的hash值 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">183821170</span><span style="color:#24292E;"> 的索引 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">18</span></span>
<span class="line"><span style="color:#24292E;">xiaozhuanling的hash值 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">14597045</span><span style="color:#24292E;"> 的索引 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">21</span></span>
<span class="line"><span style="color:#24292E;">fangxiaowan的hash值 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">392727066</span><span style="color:#24292E;"> 的索引 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">6</span></span>
<span class="line"><span style="color:#24292E;">yaoxiaojuan的hash值 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1231568918</span><span style="color:#24292E;"> 的索引 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">22</span></span>
<span class="line"><span style="color:#24292E;">chenmo的hash值 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1361556696</span><span style="color:#24292E;"> 的索引 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">8</span></span>
<span class="line"><span style="color:#24292E;">chenqingyang的hash值 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">613818743</span><span style="color:#24292E;"> 的索引 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">9</span></span>
<span class="line"><span style="color:#24292E;">yexin的hash值 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">114873289</span><span style="color:#24292E;"> 的索引 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">9</span></span>
<span class="line"><span style="color:#24292E;">wanger的hash值 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">795084437</span><span style="color:#24292E;"> 的索引 </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">11</span></span></code></pre></div><p>可以看到：</p><ul><li>虽然chenqingyang（陈清扬）和yexin（叶辛）的索引仍然是 9。</li><li>但 fangxiaowan（方小婉）的索引为 6，yaoxiaojuan（姚小娟）的索引由 6 变为 22，各自都有坑了。</li></ul><p>当然了，数组是无法自动扩容的，所以如果要扩容的话，就需要新建一个大的数组，然后把之前小的数组的元素复制过去，并且要重新计算哈希值和重新分配桶（重新散列），这个过程也是挺耗时的。</p><h4 id="resize方法" tabindex="-1">resize方法 <a class="header-anchor" href="#resize方法" aria-label="Permalink to &quot;resize方法&quot;">​</a></h4><p>HashMap 的扩容是通过 resize 方法来实现的，JDK 8 中融入了红黑树（链表长度超过 8 的时候，会将链表转化为红黑树来提高查询效率），对于新手来说，可能比较难理解。</p><p>为了减轻大家的学习压力，就还使用 JDK 7 的源码，搞清楚了 JDK 7 的，再看 JDK 8 的就会轻松很多。</p><p>来看 Java7 的 resize 方法源码，我加了注释：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#7B7F8B;">// newCapacity为新的容量</span></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">void</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">resize</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> newCapacity) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 小数组，临时过度下</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">[] oldTable </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> table;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 扩容前的容量</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> oldCapacity </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> oldTable.length;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 = 1&lt;&lt;30</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (oldCapacity </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> MAXIMUM_CAPACITY) {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#7B7F8B;">// 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2 的 31 次方-1</span></span>
<span class="line"><span style="color:#F6F6F4;">        threshold </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> Integer.MAX_VALUE;</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 初始化一个新的数组（大容量）</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">[] newTable </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">[newCapacity];</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 把小数组的元素转移到大数组中</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#62E884;">transfer</span><span style="color:#F6F6F4;">(newTable, </span><span style="color:#62E884;">initHashSeedAsNeeded</span><span style="color:#F6F6F4;">(newCapacity));</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 引用新的大数组</span></span>
<span class="line"><span style="color:#F6F6F4;">    table </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> newTable;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 重新计算阈值</span></span>
<span class="line"><span style="color:#F6F6F4;">    threshold </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;">)Math.</span><span style="color:#62E884;">min</span><span style="color:#F6F6F4;">(newCapacity </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;"> loadFactor, MAXIMUM_CAPACITY </span><span style="color:#F286C4;">+</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// newCapacity为新的容量</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">resize</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> newCapacity) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 小数组，临时过度下</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">Entry</span><span style="color:#24292E;">[] oldTable </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> table;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 扩容前的容量</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> oldCapacity </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldTable.length;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 = 1&lt;&lt;30</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldCapacity </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> MAXIMUM_CAPACITY) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2 的 31 次方-1</span></span>
<span class="line"><span style="color:#24292E;">        threshold </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Integer.MAX_VALUE;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化一个新的数组（大容量）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">Entry</span><span style="color:#24292E;">[] newTable </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Entry</span><span style="color:#24292E;">[newCapacity];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 把小数组的元素转移到大数组中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">transfer</span><span style="color:#24292E;">(newTable, </span><span style="color:#6F42C1;">initHashSeedAsNeeded</span><span style="color:#24292E;">(newCapacity));</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 引用新的大数组</span></span>
<span class="line"><span style="color:#24292E;">    table </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newTable;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 重新计算阈值</span></span>
<span class="line"><span style="color:#24292E;">    threshold </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">)Math.</span><span style="color:#6F42C1;">min</span><span style="color:#24292E;">(newCapacity </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> loadFactor, MAXIMUM_CAPACITY </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>该方法接收一个新的容量 newCapacity，然后将 HashMap 的容量扩大到 newCapacity。</p><p>首先，方法获取当前 HashMap 的旧数组 oldTable 和旧容量 oldCapacity。如果旧容量已经达到 HashMap 支持的最大容量 MAXIMUM_CAPACITY（ 2 的 30 次方），就将新的阈值 threshold 调整为 Integer.MAX_VALUE（2 的 31 次方 - 1），这是因为 HashMap 的容量不能超过 MAXIMUM_CAPACITY。</p><p>因为 2,147,483,647（Integer.MAX_VALUE） - 1,073,741,824（MAXIMUM_CAPACITY） = 1,073,741,823，刚好相差一倍（HashMap 每次扩容都是之前的一倍）。</p><p>接着，方法创建一个新的数组 newTable，并将旧数组 oldTable 中的元素转移到新数组 newTable 中。转移过程是通过调用 transfer 方法来实现的。该方法遍历旧数组中的每个桶，并将每个桶中的键值对重新计算哈希值后，将其插入到新数组对应的桶中。</p><p>转移完成后，方法将 HashMap 内部的数组引用 table 指向新数组 newTable，并重新计算阈值 threshold。新的阈值是新容量 newCapacity 乘以负载因子 loadFactor 的结果，但如果计算结果超过了 HashMap 支持的最大容量 MAXIMUM_CAPACITY，则将阈值设置为 MAXIMUM_CAPACITY + 1，这是因为 HashMap 的元素数量不能超过 MAXIMUM_CAPACITY。</p><h4 id="新容量newcapacity" tabindex="-1">新容量newCapacity <a class="header-anchor" href="#新容量newcapacity" aria-label="Permalink to &quot;新容量newCapacity&quot;">​</a></h4><p>那 newCapacity 是如何计算的呢？</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> newCapacity </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> oldCapacity </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">2</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (newCapacity </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">||</span><span style="color:#F6F6F4;"> newCapacity </span><span style="color:#F286C4;">&gt;=</span><span style="color:#F6F6F4;"> MAXIMUM_CAPACITY) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    newCapacity </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> MAXIMUM_CAPACITY;</span></span>
<span class="line"><span style="color:#F6F6F4;">} </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (newCapacity </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> DEFAULT_INITIAL_CAPACITY) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    newCapacity </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> DEFAULT_INITIAL_CAPACITY;</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> newCapacity </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldCapacity </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newCapacity </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> newCapacity </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> MAXIMUM_CAPACITY) {</span></span>
<span class="line"><span style="color:#24292E;">    newCapacity </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> MAXIMUM_CAPACITY;</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newCapacity </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> DEFAULT_INITIAL_CAPACITY) {</span></span>
<span class="line"><span style="color:#24292E;">    newCapacity </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> DEFAULT_INITIAL_CAPACITY;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>新容量 newCapacity 被初始化为原容量 oldCapacity 的两倍。然后，如果 newCapacity 超过了 HashMap 的容量限制 MAXIMUM_CAPACITY（2^30），就将 newCapacity 设置为 MAXIMUM_CAPACITY。如果 newCapacity 小于默认初始容量 DEFAULT_INITIAL_CAPACITY（16），就将 newCapacity 设置为 DEFAULT_INITIAL_CAPACITY。这样可以避免新容量太小或太大导致哈希冲突过多或者浪费空间。</p><p>Java 8 的时候，newCapacity 的计算方式发生了一些细微的变化。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> newCapacity </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> oldCapacity </span><span style="color:#F286C4;">&lt;&lt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (newCapacity </span><span style="color:#F286C4;">&gt;=</span><span style="color:#F6F6F4;"> DEFAULT_INITIAL_CAPACITY </span><span style="color:#F286C4;">&amp;&amp;</span><span style="color:#F6F6F4;"> oldCapacity </span><span style="color:#F286C4;">&gt;=</span><span style="color:#F6F6F4;"> DEFAULT_INITIAL_CAPACITY) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (newCapacity </span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;"> MAXIMUM_CAPACITY)</span></span>
<span class="line"><span style="color:#F6F6F4;">        newCapacity </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> MAXIMUM_CAPACITY;</span></span>
<span class="line"><span style="color:#F6F6F4;">} </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (newCapacity </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> DEFAULT_INITIAL_CAPACITY)</span></span>
<span class="line"><span style="color:#F6F6F4;">        newCapacity </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> DEFAULT_INITIAL_CAPACITY;</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> newCapacity </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldCapacity </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newCapacity </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> DEFAULT_INITIAL_CAPACITY </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> oldCapacity </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> DEFAULT_INITIAL_CAPACITY) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newCapacity </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> MAXIMUM_CAPACITY)</span></span>
<span class="line"><span style="color:#24292E;">        newCapacity </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> MAXIMUM_CAPACITY;</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newCapacity </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> DEFAULT_INITIAL_CAPACITY)</span></span>
<span class="line"><span style="color:#24292E;">        newCapacity </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> DEFAULT_INITIAL_CAPACITY;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>注意，<code>oldCapacity * 2</code> 变成了 <code>oldCapacity &lt;&lt; 1</code>，出现了左移（<code>&lt;&lt;</code>），这里简单介绍一下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">a=39</span></span>
<span class="line"><span style="color:#f6f6f4;">b = a &lt;&lt; 2</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">a=39</span></span>
<span class="line"><span style="color:#24292e;">b = a &lt;&lt; 2</span></span></code></pre></div><p>十进制 39 用 8 位的二进制来表示，就是 00100111，左移两位后是 10011100（低位用 0 补上），再转成十进制数就是 156。</p><p>移位运算通常可以用来代替乘法运算和除法运算。例如，将 0010011（39）左移两位就是 10011100（156），刚好变成了原来的 4 倍。</p><p>实际上呢，二进制数左移后会变成原来的 2 倍、4 倍、8 倍，记住这个就好。</p><h4 id="transfer方法" tabindex="-1">transfer方法 <a class="header-anchor" href="#transfer方法" aria-label="Permalink to &quot;transfer方法&quot;">​</a></h4><p>接下来，来说 transfer 方法，该方法用来转移，将旧的小数组元素拷贝到新的大数组中。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">void</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">transfer</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">[] newTable, </span><span style="color:#97E1F1;font-style:italic;">boolean</span><span style="color:#F6F6F4;"> rehash) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 新的容量</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> newCapacity </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> newTable.length;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 遍历小数组</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">for</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">&lt;K,V&gt; e </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> table) {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">while</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> e) {</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#7B7F8B;">// 拉链法，相同 key 上的不同值</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">&lt;K,V&gt; next </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e.next;</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#7B7F8B;">// 是否需要重新计算 hash</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (rehash) {</span></span>
<span class="line"><span style="color:#F6F6F4;">                e.hash </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> e.key </span><span style="color:#F286C4;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">hash</span><span style="color:#F6F6F4;">(e.key);</span></span>
<span class="line"><span style="color:#F6F6F4;">            }</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#7B7F8B;">// 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> i </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">indexFor</span><span style="color:#F6F6F4;">(e.hash, newCapacity);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#7B7F8B;">// 同一位置上的新元素被放在链表的头部</span></span>
<span class="line"><span style="color:#F6F6F4;">            e.next </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> newTable[i];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#7B7F8B;">// 放在新的数组上</span></span>
<span class="line"><span style="color:#F6F6F4;">            newTable[i] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#7B7F8B;">// 链表上的下一个元素</span></span>
<span class="line"><span style="color:#F6F6F4;">            e </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> next;</span></span>
<span class="line"><span style="color:#F6F6F4;">        }</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">transfer</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">Entry</span><span style="color:#24292E;">[] newTable, </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> rehash) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 新的容量</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> newCapacity </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newTable.length;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 遍历小数组</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; e </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> table) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> e) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 拉链法，相同 key 上的不同值</span></span>
<span class="line"><span style="color:#24292E;">            Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e.next;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 是否需要重新计算 hash</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (rehash) {</span></span>
<span class="line"><span style="color:#24292E;">                e.hash </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> e.key </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">hash</span><span style="color:#24292E;">(e.key);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">indexFor</span><span style="color:#24292E;">(e.hash, newCapacity);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 同一位置上的新元素被放在链表的头部</span></span>
<span class="line"><span style="color:#24292E;">            e.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newTable[i];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 放在新的数组上</span></span>
<span class="line"><span style="color:#24292E;">            newTable[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 链表上的下一个元素</span></span>
<span class="line"><span style="color:#24292E;">            e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> next;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>该方法接受一个新的 Entry 数组 newTable 和一个布尔值 rehash 作为参数，其中 newTable 表示新的哈希表，rehash 表示是否需要重新计算键的哈希值。</p><p>在方法中，首先获取新哈希表（数组）的长度 newCapacity，然后遍历旧哈希表中的每个 Entry。对于每个 Entry，使用拉链法将相同 key 值的不同 value 值存储在同一个链表中。如果 rehash 为 true，则需要重新计算键的哈希值，并将新的哈希值存储在 Entry 的 hash 属性中。</p><p>接着，根据新哈希表的长度和键的哈希值，计算 Entry 在新数组中的位置 i，然后将该 Entry 添加到新数组的 i 位置上。由于新元素需要被放在链表的头部，因此将新元素的下一个元素设置为当前数组位置上的元素。</p><p>最后，遍历完旧哈希表中的所有元素后，转移工作完成，新的哈希表 newTable 已经包含了旧哈希表中的所有元素。</p><h4 id="拉链法" tabindex="-1">拉链法 <a class="header-anchor" href="#拉链法" aria-label="Permalink to &quot;拉链法&quot;">​</a></h4><p>注意，<code>e.next = newTable[i]</code>，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素最终会被放到链表的尾部，这就会导致<strong>在旧数组中同一个链表上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上</strong>。</p><p>就这点上，Java 8 做了很大的优化（下面会讲）。</p><p>现在假设 hash 算法就是简单的用键的哈希值（一个 int 值）和数组大小取模（也就是 <code>hashCode % table.length</code>）。</p><p>继续假设：</p><ul><li>数组 table 的长度为 2</li><li>键的哈希值为 3、7、5</li></ul><p>取模运算后，哈希冲突都到 table[1] 上了，因为余数为 1。那么扩容前的样子如下图所示。</p><img src="`+t+'"><p>数组的容量为 2， key 3、7、5 都在 table[1] 的链表上。</p><p>假设负载因子（后面会细讲） loadFactor 为 1，也就是当元素的个数大于 table 的长度时进行扩容。</p><p>扩容后的数组容量为 4。</p><ul><li>key 3 取模（3%4）后是 3，放在 table[3] 上。</li><li>key 7 取模（7%4）后是 3，放在 table[3] 上的链表头部。</li><li>key 5 取模（5%4）后是 1，放在 table[1] 上。</li></ul><img src="'+c+'"><p>按照我们的预期，扩容后的 7 仍然应该在 3 这条链表的后面，但实际上呢？ 7 跑到 3 这条链表的头部了。</p><p>针对 JDK 7 中的这个情况，JDK 8 做了哪些优化呢？</p><p>看下面这张图。</p><img src="'+r+'"><p>n 为 table 的长度，默认值为 16。</p><ul><li>n-1 也就是二进制的 0000 1111（1X$2^0$+1X$2^1$+1X$2^2$+1X$2^3$=1+2+4+8=15）；</li><li>key1 哈希值的最后 8 位为 0000 0101</li><li>key2 哈希值的最后 8 位为 0001 0101（和 key1 不同）</li><li>做与运算后发生了哈希冲突，索引都在（0000 0101）上。</li></ul><p>扩容后为 32。</p><ul><li>n-1 也就是二进制的 0001 1111（1X$2^0$+1X$2^1$+1X$2^2$+1X$2^3$+1X$2^4$=1+2+4+8+16=31），扩容前是 0000 1111。</li><li>key1 哈希值的低位为 0000 0101</li><li>key2 哈希值的低位为 0001 0101（和 key1 不同）</li><li>key1 做与运算后，索引为 0000 0101。</li><li>key2 做与运算后，索引为 0001 0101。</li></ul><p>新的索引就会发生这样的变化：</p><ul><li>原来的索引是 5（<em>0</em> 0101）</li><li>原来的容量是 16</li><li>扩容后的容量是 32</li><li>扩容后的索引是 21（<em>1</em> 0101），也就是 5+16，也就是原来的索引+原来的容量</li></ul><img src="'+y+'"><p>也就是说，JDK 8 不需要像 JDK 7 那样重新计算 hash，只需要看原来的hash值新增的那个bit是1还是0就好了，是0的话就表示索引没变，是1的话，索引就变成了“原索引+原来的容量”。</p><img src="'+F+`"><p>JDK 8 的这个设计非常巧妙，既省去了重新计算hash的时间，同时，由于新增的1 bit是0还是1是随机的，因此扩容的过程，可以均匀地把之前的节点分散到新的位置上。</p><p>woc，只能说 HashMap 的作者 Doug Lea、Josh Bloch、Arthur van Hoff、Neal Gafter 真的强——的一笔。</p><h4 id="java-8-扩容" tabindex="-1">Java 8 扩容 <a class="header-anchor" href="#java-8-扩容" aria-label="Permalink to &quot;Java 8 扩容&quot;">​</a></h4><p>JDK 8 的扩容源代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;">K,V</span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;">[] </span><span style="color:#62E884;">resize</span><span style="color:#F6F6F4;">() {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt;[] oldTab </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> table; </span><span style="color:#7B7F8B;">// 获取原来的数组 table</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> oldCap </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (oldTab </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> oldTab.length; </span><span style="color:#7B7F8B;">// 获取数组长度 oldCap</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> oldThr </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> threshold; </span><span style="color:#7B7F8B;">// 获取阈值 oldThr</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> newCap, newThr </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (oldCap </span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">) { </span><span style="color:#7B7F8B;">// 如果原来的数组 table 不为空</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (oldCap </span><span style="color:#F286C4;">&gt;=</span><span style="color:#F6F6F4;"> MAXIMUM_CAPACITY) { </span><span style="color:#7B7F8B;">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span>
<span class="line"><span style="color:#F6F6F4;">            threshold </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> Integer.MAX_VALUE;</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> oldTab;</span></span>
<span class="line"><span style="color:#F6F6F4;">        }</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> ((newCap </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> oldCap </span><span style="color:#F286C4;">&lt;&lt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> MAXIMUM_CAPACITY </span><span style="color:#F286C4;">&amp;&amp;</span><span style="color:#F6F6F4;"> </span><span style="color:#7B7F8B;">// 没超过最大值，就扩充为原来的2倍</span></span>
<span class="line"><span style="color:#F6F6F4;">                 oldCap </span><span style="color:#F286C4;">&gt;=</span><span style="color:#F6F6F4;"> DEFAULT_INITIAL_CAPACITY)</span></span>
<span class="line"><span style="color:#F6F6F4;">            newThr </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> oldThr </span><span style="color:#F286C4;">&lt;&lt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">; </span><span style="color:#7B7F8B;">// double threshold</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (oldThr </span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">) </span><span style="color:#7B7F8B;">// initial capacity was placed in threshold</span></span>
<span class="line"><span style="color:#F6F6F4;">        newCap </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> oldThr;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> { </span><span style="color:#7B7F8B;">// zero initial threshold signifies using defaults</span></span>
<span class="line"><span style="color:#F6F6F4;">        newCap </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> DEFAULT_INITIAL_CAPACITY;</span></span>
<span class="line"><span style="color:#F6F6F4;">        newThr </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;">)(DEFAULT_LOAD_FACTOR </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;"> DEFAULT_INITIAL_CAPACITY);</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 计算新的 resize 上限</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (newThr </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#97E1F1;font-style:italic;">float</span><span style="color:#F6F6F4;"> ft </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">float</span><span style="color:#F6F6F4;">)newCap </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;"> loadFactor;</span></span>
<span class="line"><span style="color:#F6F6F4;">        newThr </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (newCap </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> MAXIMUM_CAPACITY </span><span style="color:#F286C4;">&amp;&amp;</span><span style="color:#F6F6F4;"> ft </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">float</span><span style="color:#F6F6F4;">)MAXIMUM_CAPACITY </span><span style="color:#F286C4;">?</span></span>
<span class="line"><span style="color:#F6F6F4;">                  (</span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;">)ft </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> Integer.MAX_VALUE);</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    threshold </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> newThr; </span><span style="color:#7B7F8B;">// 将新阈值赋值给成员变量 threshold</span></span>
<span class="line"><span style="color:#F6F6F4;">    @</span><span style="color:#97E1F1;font-style:italic;">SuppressWarnings</span><span style="color:#F6F6F4;">({</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">rawtypes</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">,</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">unchecked</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">})</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt;[] newTab </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;">K,V</span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;">[])</span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">[newCap]; </span><span style="color:#7B7F8B;">// 创建新数组 newTab</span></span>
<span class="line"><span style="color:#F6F6F4;">    table </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> newTab; </span><span style="color:#7B7F8B;">// 将新数组 newTab 赋值给成员变量 table</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (oldTab </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) { </span><span style="color:#7B7F8B;">// 如果旧数组 oldTab 不为空</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">for</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> j </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">; j </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> oldCap; </span><span style="color:#F286C4;">++</span><span style="color:#F6F6F4;">j) { </span><span style="color:#7B7F8B;">// 遍历旧数组的每个元素</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt; e;</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> ((e </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> oldTab[j]) </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) { </span><span style="color:#7B7F8B;">// 如果该元素不为空</span></span>
<span class="line"><span style="color:#F6F6F4;">                oldTab[j] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">; </span><span style="color:#7B7F8B;">// 将旧数组中该位置的元素置为 null，以便垃圾回收</span></span>
<span class="line"><span style="color:#F6F6F4;">                </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (e.next </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) </span><span style="color:#7B7F8B;">// 如果该元素没有冲突</span></span>
<span class="line"><span style="color:#F6F6F4;">                    newTab[e.hash </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;"> (newCap </span><span style="color:#F286C4;">-</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">)] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e; </span><span style="color:#7B7F8B;">// 直接将该元素放入新数组</span></span>
<span class="line"><span style="color:#F6F6F4;">                </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (e </span><span style="color:#F286C4;">instanceof</span><span style="color:#F6F6F4;"> TreeNode) </span><span style="color:#7B7F8B;">// 如果该元素是树节点</span></span>
<span class="line"><span style="color:#F6F6F4;">                    ((</span><span style="color:#97E1F1;font-style:italic;">TreeNode</span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;">K,V</span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;">)e).</span><span style="color:#62E884;">split</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">, newTab, j, oldCap); </span><span style="color:#7B7F8B;">// 将该树节点分裂成两个链表</span></span>
<span class="line"><span style="color:#F6F6F4;">                </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> { </span><span style="color:#7B7F8B;">// 如果该元素是链表</span></span>
<span class="line"><span style="color:#F6F6F4;">                    </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt; loHead </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">, loTail </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">; </span><span style="color:#7B7F8B;">// 低位链表的头结点和尾结点</span></span>
<span class="line"><span style="color:#F6F6F4;">                    </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt; hiHead </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">, hiTail </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">; </span><span style="color:#7B7F8B;">// 高位链表的头结点和尾结点</span></span>
<span class="line"><span style="color:#F6F6F4;">                    </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt; next;</span></span>
<span class="line"><span style="color:#F6F6F4;">                    </span><span style="color:#F286C4;">do</span><span style="color:#F6F6F4;"> { </span><span style="color:#7B7F8B;">// 遍历该链表</span></span>
<span class="line"><span style="color:#F6F6F4;">                        next </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e.next;</span></span>
<span class="line"><span style="color:#F6F6F4;">                        </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> ((e.hash </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;"> oldCap) </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">) { </span><span style="color:#7B7F8B;">// 如果该元素在低位链表中</span></span>
<span class="line"><span style="color:#F6F6F4;">                            </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (loTail </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) </span><span style="color:#7B7F8B;">// 如果低位链表还没有结点</span></span>
<span class="line"><span style="color:#F6F6F4;">                                loHead </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e; </span><span style="color:#7B7F8B;">// 将该元素作为低位链表的头结点</span></span>
<span class="line"><span style="color:#F6F6F4;">                            </span><span style="color:#F286C4;">else</span></span>
<span class="line"><span style="color:#F6F6F4;">                                loTail.next </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e; </span><span style="color:#7B7F8B;">// 如果低位链表已经有结点，将该元素加入低位链表的尾部</span></span>
<span class="line"><span style="color:#F6F6F4;">                            loTail </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e; </span><span style="color:#7B7F8B;">// 更新低位链表的尾结点</span></span>
<span class="line"><span style="color:#F6F6F4;">                        }</span></span>
<span class="line"><span style="color:#F6F6F4;">                        </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> { </span><span style="color:#7B7F8B;">// 如果该元素在高位链表中</span></span>
<span class="line"><span style="color:#F6F6F4;">                            </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (hiTail </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) </span><span style="color:#7B7F8B;">// 如果高位链表还没有结点</span></span>
<span class="line"><span style="color:#F6F6F4;">                                hiHead </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e; </span><span style="color:#7B7F8B;">// 将该元素作为高位链表的头结点</span></span>
<span class="line"><span style="color:#F6F6F4;">                            </span><span style="color:#F286C4;">else</span></span>
<span class="line"><span style="color:#F6F6F4;">                                hiTail.next </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e; </span><span style="color:#7B7F8B;">// 如果高位链表已经有结点，将该元素加入高位链表的尾部</span></span>
<span class="line"><span style="color:#F6F6F4;">                            hiTail </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e; </span><span style="color:#7B7F8B;">// 更新高位链表的尾结点</span></span>
<span class="line"><span style="color:#F6F6F4;">                        }</span></span>
<span class="line"><span style="color:#F6F6F4;">                    } </span><span style="color:#F286C4;">while</span><span style="color:#F6F6F4;"> ((e </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> next) </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">); </span><span style="color:#7B7F8B;">//</span></span>
<span class="line"><span style="color:#F6F6F4;">                    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (loTail </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) { </span><span style="color:#7B7F8B;">// 如果低位链表不为空</span></span>
<span class="line"><span style="color:#F6F6F4;">                        loTail.next </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">; </span><span style="color:#7B7F8B;">// 将低位链表的尾结点指向 null，以便垃圾回收</span></span>
<span class="line"><span style="color:#F6F6F4;">                        newTab[j] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> loHead; </span><span style="color:#7B7F8B;">// 将低位链表作为新数组对应位置的元素</span></span>
<span class="line"><span style="color:#F6F6F4;">                    }</span></span>
<span class="line"><span style="color:#F6F6F4;">                    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (hiTail </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) { </span><span style="color:#7B7F8B;">// 如果高位链表不为空</span></span>
<span class="line"><span style="color:#F6F6F4;">                        hiTail.next </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">; </span><span style="color:#7B7F8B;">// 将高位链表的尾结点指向 null，以便垃圾回收</span></span>
<span class="line"><span style="color:#F6F6F4;">                        newTab[j </span><span style="color:#F286C4;">+</span><span style="color:#F6F6F4;"> oldCap] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> hiHead; </span><span style="color:#7B7F8B;">// 将高位链表作为新数组对应位置的元素</span></span>
<span class="line"><span style="color:#F6F6F4;">                    }</span></span>
<span class="line"><span style="color:#F6F6F4;">                }</span></span>
<span class="line"><span style="color:#F6F6F4;">            }</span></span>
<span class="line"><span style="color:#F6F6F4;">        }</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> newTab; </span><span style="color:#7B7F8B;">// 返回新数组</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">resize</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt;[] oldTab </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> table; </span><span style="color:#6A737D;">// 获取原来的数组 table</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> oldCap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (oldTab </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> oldTab.length; </span><span style="color:#6A737D;">// 获取数组长度 oldCap</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> oldThr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> threshold; </span><span style="color:#6A737D;">// 获取阈值 oldThr</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> newCap, newThr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldCap </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 如果原来的数组 table 不为空</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldCap </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> MAXIMUM_CAPACITY) { </span><span style="color:#6A737D;">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span>
<span class="line"><span style="color:#24292E;">            threshold </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Integer.MAX_VALUE;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> oldTab;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((newCap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldCap </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> MAXIMUM_CAPACITY </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 没超过最大值，就扩充为原来的2倍</span></span>
<span class="line"><span style="color:#24292E;">                 oldCap </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> DEFAULT_INITIAL_CAPACITY)</span></span>
<span class="line"><span style="color:#24292E;">            newThr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldThr </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// double threshold</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldThr </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// initial capacity was placed in threshold</span></span>
<span class="line"><span style="color:#24292E;">        newCap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldThr;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// zero initial threshold signifies using defaults</span></span>
<span class="line"><span style="color:#24292E;">        newCap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> DEFAULT_INITIAL_CAPACITY;</span></span>
<span class="line"><span style="color:#24292E;">        newThr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">)(DEFAULT_LOAD_FACTOR </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> DEFAULT_INITIAL_CAPACITY);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 计算新的 resize 上限</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newThr </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">float</span><span style="color:#24292E;"> ft </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">float</span><span style="color:#24292E;">)newCap </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> loadFactor;</span></span>
<span class="line"><span style="color:#24292E;">        newThr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (newCap </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> MAXIMUM_CAPACITY </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> ft </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">float</span><span style="color:#24292E;">)MAXIMUM_CAPACITY </span><span style="color:#D73A49;">?</span></span>
<span class="line"><span style="color:#24292E;">                  (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">)ft </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> Integer.MAX_VALUE);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    threshold </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newThr; </span><span style="color:#6A737D;">// 将新阈值赋值给成员变量 threshold</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">SuppressWarnings</span><span style="color:#24292E;">({</span><span style="color:#032F62;">&quot;rawtypes&quot;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&quot;unchecked&quot;</span><span style="color:#24292E;">})</span></span>
<span class="line"><span style="color:#24292E;">        Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt;[] newTab </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (Node</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">[])</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Node</span><span style="color:#24292E;">[newCap]; </span><span style="color:#6A737D;">// 创建新数组 newTab</span></span>
<span class="line"><span style="color:#24292E;">    table </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newTab; </span><span style="color:#6A737D;">// 将新数组 newTab 赋值给成员变量 table</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldTab </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 如果旧数组 oldTab 不为空</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; j </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> oldCap; </span><span style="color:#D73A49;">++</span><span style="color:#24292E;">j) { </span><span style="color:#6A737D;">// 遍历旧数组的每个元素</span></span>
<span class="line"><span style="color:#24292E;">            Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; e;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldTab[j]) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 如果该元素不为空</span></span>
<span class="line"><span style="color:#24292E;">                oldTab[j] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 将旧数组中该位置的元素置为 null，以便垃圾回收</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (e.next </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 如果该元素没有冲突</span></span>
<span class="line"><span style="color:#24292E;">                    newTab[e.hash </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> (newCap </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e; </span><span style="color:#6A737D;">// 直接将该元素放入新数组</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (e </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> TreeNode) </span><span style="color:#6A737D;">// 如果该元素是树节点</span></span>
<span class="line"><span style="color:#24292E;">                    ((TreeNode</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">)e).</span><span style="color:#6F42C1;">split</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, newTab, j, oldCap); </span><span style="color:#6A737D;">// 将该树节点分裂成两个链表</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 如果该元素是链表</span></span>
<span class="line"><span style="color:#24292E;">                    Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; loHead </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, loTail </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 低位链表的头结点和尾结点</span></span>
<span class="line"><span style="color:#24292E;">                    Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; hiHead </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, hiTail </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 高位链表的头结点和尾结点</span></span>
<span class="line"><span style="color:#24292E;">                    Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; next;</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">do</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 遍历该链表</span></span>
<span class="line"><span style="color:#24292E;">                        next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e.next;</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((e.hash </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> oldCap) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 如果该元素在低位链表中</span></span>
<span class="line"><span style="color:#24292E;">                            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (loTail </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 如果低位链表还没有结点</span></span>
<span class="line"><span style="color:#24292E;">                                loHead </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e; </span><span style="color:#6A737D;">// 将该元素作为低位链表的头结点</span></span>
<span class="line"><span style="color:#24292E;">                            </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">                                loTail.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e; </span><span style="color:#6A737D;">// 如果低位链表已经有结点，将该元素加入低位链表的尾部</span></span>
<span class="line"><span style="color:#24292E;">                            loTail </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e; </span><span style="color:#6A737D;">// 更新低位链表的尾结点</span></span>
<span class="line"><span style="color:#24292E;">                        }</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 如果该元素在高位链表中</span></span>
<span class="line"><span style="color:#24292E;">                            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (hiTail </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 如果高位链表还没有结点</span></span>
<span class="line"><span style="color:#24292E;">                                hiHead </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e; </span><span style="color:#6A737D;">// 将该元素作为高位链表的头结点</span></span>
<span class="line"><span style="color:#24292E;">                            </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">                                hiTail.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e; </span><span style="color:#6A737D;">// 如果高位链表已经有结点，将该元素加入高位链表的尾部</span></span>
<span class="line"><span style="color:#24292E;">                            hiTail </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e; </span><span style="color:#6A737D;">// 更新高位链表的尾结点</span></span>
<span class="line"><span style="color:#24292E;">                        }</span></span>
<span class="line"><span style="color:#24292E;">                    } </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> ((e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> next) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">//</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (loTail </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 如果低位链表不为空</span></span>
<span class="line"><span style="color:#24292E;">                        loTail.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 将低位链表的尾结点指向 null，以便垃圾回收</span></span>
<span class="line"><span style="color:#24292E;">                        newTab[j] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> loHead; </span><span style="color:#6A737D;">// 将低位链表作为新数组对应位置的元素</span></span>
<span class="line"><span style="color:#24292E;">                    }</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (hiTail </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 如果高位链表不为空</span></span>
<span class="line"><span style="color:#24292E;">                        hiTail.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 将高位链表的尾结点指向 null，以便垃圾回收</span></span>
<span class="line"><span style="color:#24292E;">                        newTab[j </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> oldCap] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> hiHead; </span><span style="color:#6A737D;">// 将高位链表作为新数组对应位置的元素</span></span>
<span class="line"><span style="color:#24292E;">                    }</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> newTab; </span><span style="color:#6A737D;">// 返回新数组</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>1、获取原来的数组 table、数组长度 oldCap 和阈值 oldThr。</p><p>2、如果原来的数组 table 不为空，则根据扩容规则计算新数组长度 newCap 和新阈值 newThr，然后将原数组中的元素复制到新数组中。</p><p>3、如果原来的数组 table 为空但阈值 oldThr 不为零，则说明是通过带参数构造函数创建的 HashMap，此时将阈值作为新数组长度 newCap。</p><p>4、如果原来的数组 table 和阈值 oldThr 都为零，则说明是通过无参数构造函数创建的 HashMap，此时将默认初始容量 DEFAULT_INITIAL_CAPACITY（16）和默认负载因子 DEFAULT_LOAD_FACTOR（0.75）计算出新数组长度 newCap 和新阈值 newThr。</p><p>5、计算新阈值 threshold，并将其赋值给成员变量 threshold。</p><p>6、创建新数组 newTab，并将其赋值给成员变量 table。</p><p>7、如果旧数组 oldTab 不为空，则遍历旧数组的每个元素，将其复制到新数组中。</p><p>8、返回新数组 newTab。</p><h4 id="小结-1" tabindex="-1">小结 <a class="header-anchor" href="#小结-1" aria-label="Permalink to &quot;小结&quot;">​</a></h4><p>HashMap 的内部实现是通过一个数组和链表或红黑树的组合来实现的。当我们往 HashMap 中不断添加元素时，HashMap 会自动进行扩容操作（条件是元素数量达到负载因子（load factor）乘以数组长度时），以保证其存储的元素数量不会超出其容量限制。下面是 HashMap 的扩容机制：</p><p>1、在进行扩容操作时，HashMap 会先将数组的长度扩大一倍，然后将原来的元素重新散列（这个词还是挺贴切的）到新的数组中。由于元素的散列位置是通过 key 的 hashcode 和数组长度取模得到的，因此在数组长度扩大后，元素的散列位置也会发生一些改变。</p><p>2、在重新散列元素时，如果一个元素的散列位置发生了改变，那么它需要被移动到新的位置。如果新的位置上已经有元素了，那么这个元素就会被添加到链表的末尾，如果链表的长度超过了阈值（8个），那么它将会被转换成红黑树。</p><p>总之，HashMap 的扩容机制是通过增加数组长度和重新散列元素来实现的，它可以保证 HashMap 的存储容量足够大，同时也可以保证 HashMap 的存储效率和检索效率。但是，由于扩容操作需要耗费一定的时间和空间，因此我们需要在使用 HashMap 时，合理地设置初始容量和负载因子，以避免过多的扩容操作。</p><h3 id="_03、加载因子为什么是0-75" tabindex="-1">03、加载因子为什么是0.75 <a class="header-anchor" href="#_03、加载因子为什么是0-75" aria-label="Permalink to &quot;03、加载因子为什么是0.75&quot;">​</a></h3><p>上一个问题提到了加载因子（或者叫负载因子），那么这个问题我们来讨论为什么加载因子是 0.75 而不是 0.6、0.8。</p><p>我们知道，HashMap 是用数组+链表/红黑树实现的，我们要想往 HashMap 中添加数据（元素/键值对）或者取数据，就需要确定数据在数组中的下标（索引）。</p><p>先把数据的键进行一次 hash：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">static</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">hash</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">Object</span><span style="color:#F6F6F4;"> key) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> h;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> (key </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> (h </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> key.</span><span style="color:#62E884;">hashCode</span><span style="color:#F6F6F4;">()) </span><span style="color:#F286C4;">^</span><span style="color:#F6F6F4;"> (h </span><span style="color:#F286C4;">&gt;&gt;&gt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">16</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">hash</span><span style="color:#24292E;">(Object key) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> h;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (key </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> key.</span><span style="color:#6F42C1;">hashCode</span><span style="color:#24292E;">()) </span><span style="color:#D73A49;">^</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">&gt;&gt;&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">16</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>再做一次取模运算确定下标：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F6F6F4;">i </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (n </span><span style="color:#F286C4;">-</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;"> hash</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> hash</span></span></code></pre></div><p>那这样的过程容易产生两个问题：</p><ul><li>数组的容量过小，经过哈希计算后的下标，容易出现冲突；</li><li>数组的容量过大，导致空间利用率不高。</li></ul><p>加载因子是用来表示 HashMap 中数据的填满程度：</p><blockquote><p>加载因子 = 填入哈希表中的数据个数 / 哈希表的长度</p></blockquote><p>这就意味着：</p><ul><li>加载因子越小，填满的数据就越少，哈希冲突的几率就减少了，但浪费了空间，而且还会提高扩容的触发几率；</li><li>加载因子越大，填满的数据就越多，空间利用率就高，但哈希冲突的几率就变大了。</li></ul><p>好难！！！！</p><p>这就必须在“<strong>哈希冲突</strong>”与“<strong>空间利用率</strong>”两者之间有所取舍，尽量保持平衡，谁也不碍着谁。</p><p>我们知道，HashMap 是通过拉链法来解决哈希冲突的。</p><p>为了减少哈希冲突发生的概率，当 HashMap 的数组长度达到一个<strong>临界值</strong>的时候，就会触发扩容，扩容后会将之前小数组中的元素转移到大数组中，这是一个相当耗时的操作。</p><p>这个临界值由什么来确定呢？</p><blockquote><p>临界值 = 初始容量 * 加载因子</p></blockquote><p>一开始，HashMap 的容量是 16：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">static</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> DEFAULT_INITIAL_CAPACITY </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">&lt;&lt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">4</span><span style="color:#F6F6F4;">; </span><span style="color:#7B7F8B;">// aka 16</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> DEFAULT_INITIAL_CAPACITY </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// aka 16</span></span></code></pre></div><p>加载因子是 0.75：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">static</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">float</span><span style="color:#F6F6F4;"> DEFAULT_LOAD_FACTOR </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0.75f</span><span style="color:#F6F6F4;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">float</span><span style="color:#24292E;"> DEFAULT_LOAD_FACTOR </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0.75f</span><span style="color:#24292E;">;</span></span></code></pre></div><p>也就是说，当 16*0.75=12 时，会触发扩容机制。</p><p><strong>为什么加载因子会选择 0.75 呢？为什么不是0.8、0.6呢</strong>？</p><p>这跟统计学里的一个很重要的原理——泊松分布有关。</p><p>是时候上维基百科了：</p><blockquote><p>泊松分布，是一种统计与概率学里常见到的离散概率分布，由法国数学家西莫恩·德尼·泊松在1838年时提出。它会对随机事件的发生次数进行建模，适用于涉及计算在给定的时间段、距离、面积等范围内发生随机事件的次数的应用情形。</p></blockquote><p>阮一峰老师曾在一篇博文中详细的介绍了泊松分布和指数分布，大家可以去看一下。</p><blockquote><p>链接：<a href="https://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html" target="_blank" rel="noreferrer">https://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html</a></p></blockquote><p>具体是用这么一个公式来表示的。</p><img src="`+i+`"><p>等号的左边，P 表示概率，N表示某种函数关系，t 表示时间，n 表示数量。</p><p>在 HashMap 的 doc 文档里，曾有这么一段描述：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">Because TreeNodes are about twice the size of regular nodes, we</span></span>
<span class="line"><span style="color:#f6f6f4;">use them only when bins contain enough nodes to warrant use</span></span>
<span class="line"><span style="color:#f6f6f4;">(see TREEIFY_THRESHOLD). And when they become too small (due to</span></span>
<span class="line"><span style="color:#f6f6f4;">removal or resizing) they are converted back to plain bins.  In</span></span>
<span class="line"><span style="color:#f6f6f4;">usages with well-distributed user hashCodes, tree bins are</span></span>
<span class="line"><span style="color:#f6f6f4;">rarely used.  Ideally, under random hashCodes, the frequency of</span></span>
<span class="line"><span style="color:#f6f6f4;">nodes in bins follows a Poisson distribution</span></span>
<span class="line"><span style="color:#f6f6f4;">(http://en.wikipedia.org/wiki/Poisson_distribution) with a</span></span>
<span class="line"><span style="color:#f6f6f4;">parameter of about 0.5 on average for the default resizing</span></span>
<span class="line"><span style="color:#f6f6f4;">threshold of 0.75, although with a large variance because of</span></span>
<span class="line"><span style="color:#f6f6f4;">resizing granularity. Ignoring variance, the expected</span></span>
<span class="line"><span style="color:#f6f6f4;">occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span></span>
<span class="line"><span style="color:#f6f6f4;">factorial(k)). The first values are:</span></span>
<span class="line"><span style="color:#f6f6f4;">0:    0.60653066</span></span>
<span class="line"><span style="color:#f6f6f4;">1:    0.30326533</span></span>
<span class="line"><span style="color:#f6f6f4;">2:    0.07581633</span></span>
<span class="line"><span style="color:#f6f6f4;">3:    0.01263606</span></span>
<span class="line"><span style="color:#f6f6f4;">4:    0.00157952</span></span>
<span class="line"><span style="color:#f6f6f4;">5:    0.00015795</span></span>
<span class="line"><span style="color:#f6f6f4;">6:    0.00001316</span></span>
<span class="line"><span style="color:#f6f6f4;">7:    0.00000094</span></span>
<span class="line"><span style="color:#f6f6f4;">8:    0.00000006</span></span>
<span class="line"><span style="color:#f6f6f4;">more: less than 1 in ten million</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Because TreeNodes are about twice the size of regular nodes, we</span></span>
<span class="line"><span style="color:#24292e;">use them only when bins contain enough nodes to warrant use</span></span>
<span class="line"><span style="color:#24292e;">(see TREEIFY_THRESHOLD). And when they become too small (due to</span></span>
<span class="line"><span style="color:#24292e;">removal or resizing) they are converted back to plain bins.  In</span></span>
<span class="line"><span style="color:#24292e;">usages with well-distributed user hashCodes, tree bins are</span></span>
<span class="line"><span style="color:#24292e;">rarely used.  Ideally, under random hashCodes, the frequency of</span></span>
<span class="line"><span style="color:#24292e;">nodes in bins follows a Poisson distribution</span></span>
<span class="line"><span style="color:#24292e;">(http://en.wikipedia.org/wiki/Poisson_distribution) with a</span></span>
<span class="line"><span style="color:#24292e;">parameter of about 0.5 on average for the default resizing</span></span>
<span class="line"><span style="color:#24292e;">threshold of 0.75, although with a large variance because of</span></span>
<span class="line"><span style="color:#24292e;">resizing granularity. Ignoring variance, the expected</span></span>
<span class="line"><span style="color:#24292e;">occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span></span>
<span class="line"><span style="color:#24292e;">factorial(k)). The first values are:</span></span>
<span class="line"><span style="color:#24292e;">0:    0.60653066</span></span>
<span class="line"><span style="color:#24292e;">1:    0.30326533</span></span>
<span class="line"><span style="color:#24292e;">2:    0.07581633</span></span>
<span class="line"><span style="color:#24292e;">3:    0.01263606</span></span>
<span class="line"><span style="color:#24292e;">4:    0.00157952</span></span>
<span class="line"><span style="color:#24292e;">5:    0.00015795</span></span>
<span class="line"><span style="color:#24292e;">6:    0.00001316</span></span>
<span class="line"><span style="color:#24292e;">7:    0.00000094</span></span>
<span class="line"><span style="color:#24292e;">8:    0.00000006</span></span>
<span class="line"><span style="color:#24292e;">more: less than 1 in ten million</span></span></code></pre></div><p>为了便于大家的理解，这里来重温一下 HashMap 的拉链法和红黑树结构。</p><p>Java 8 之前，HashMap 使用链表来解决冲突，即当两个或者多个键映射到同一个桶时，它们被放在同一个桶的链表上。当链表上的节点（Node）过多时，链表会变得很长，查找的效率（<a href="https://tobebetterjavaer.com/collection/linkedlist.html" target="_blank" rel="noreferrer">LinkedList</a> 的查找效率为 O（n））就会受到影响。</p><p>Java 8 中，当链表的节点数超过一个阈值（8）时，链表将转为红黑树（节点为TreeNode），红黑树（在讲<a href="https://tobebetterjavaer.com/collection/treemap.html" target="_blank" rel="noreferrer">TreeMap</a>时会细说）是一种高效的平衡树结构，能够在 O(log n) 的时间内完成插入、删除和查找等操作。这种结构在节点数很多时，可以提高 HashMap 的性能和可伸缩性。</p><p>好，有了这个背景，我们来把上面的 doc 文档翻译为中文：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">因为TreeNode（红黑树的节点）的大小大约是常规节点（链表的节点 Node）的两倍，所以只有当桶内包含足够多的节点时才使用红黑树（参见TREEIFY_THRESHOLD「阈值，值为8」，节点数量较多时，红黑树可以提高查询效率）。</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">由于删除元素或者调整数组大小（扩容）时（再次散列），红黑树可能会被转换为链表（节点数量小于 8 时），节点数量较少时，链表的效率比红黑树更高，因为红黑树需要更多的内存空间来存储节点。</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">在具有良好分布的hashCode使用中，很少使用红黑树。</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">理想情况下，在随机hashCode下，节点在桶中的频率遵循泊松分布（https://zh.wikipedia.org/wiki/卜瓦松分布），平均缩放阈值为0.75，忽略方差，列表大小k的预期出现次数为（exp（-0.5）* pow（0.5，k）/ factorial（k））。</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">前几个值是：</span></span>
<span class="line"><span style="color:#f6f6f4;">0: 0.60653066</span></span>
<span class="line"><span style="color:#f6f6f4;">1: 0.30326533</span></span>
<span class="line"><span style="color:#f6f6f4;">2: 0.07581633</span></span>
<span class="line"><span style="color:#f6f6f4;">3: 0.01263606</span></span>
<span class="line"><span style="color:#f6f6f4;">4: 0.00157952</span></span>
<span class="line"><span style="color:#f6f6f4;">5: 0.00015795</span></span>
<span class="line"><span style="color:#f6f6f4;">6: 0.00001316</span></span>
<span class="line"><span style="color:#f6f6f4;">7: 0.00000094</span></span>
<span class="line"><span style="color:#f6f6f4;">8: 0.00000006</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">更多：小于一千万分之一</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">因为TreeNode（红黑树的节点）的大小大约是常规节点（链表的节点 Node）的两倍，所以只有当桶内包含足够多的节点时才使用红黑树（参见TREEIFY_THRESHOLD「阈值，值为8」，节点数量较多时，红黑树可以提高查询效率）。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">由于删除元素或者调整数组大小（扩容）时（再次散列），红黑树可能会被转换为链表（节点数量小于 8 时），节点数量较少时，链表的效率比红黑树更高，因为红黑树需要更多的内存空间来存储节点。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">在具有良好分布的hashCode使用中，很少使用红黑树。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">理想情况下，在随机hashCode下，节点在桶中的频率遵循泊松分布（https://zh.wikipedia.org/wiki/卜瓦松分布），平均缩放阈值为0.75，忽略方差，列表大小k的预期出现次数为（exp（-0.5）* pow（0.5，k）/ factorial（k））。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">前几个值是：</span></span>
<span class="line"><span style="color:#24292e;">0: 0.60653066</span></span>
<span class="line"><span style="color:#24292e;">1: 0.30326533</span></span>
<span class="line"><span style="color:#24292e;">2: 0.07581633</span></span>
<span class="line"><span style="color:#24292e;">3: 0.01263606</span></span>
<span class="line"><span style="color:#24292e;">4: 0.00157952</span></span>
<span class="line"><span style="color:#24292e;">5: 0.00015795</span></span>
<span class="line"><span style="color:#24292e;">6: 0.00001316</span></span>
<span class="line"><span style="color:#24292e;">7: 0.00000094</span></span>
<span class="line"><span style="color:#24292e;">8: 0.00000006</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">更多：小于一千万分之一</span></span></code></pre></div><p>虽然这段话的本意更多的是表示 jdk 8中为什么拉链长度超过8的时候进行了红黑树转换，但提到了 0.75 这个加载因子，但没提到底为什么。</p><p>为了搞清楚到底为什么，我看到了这篇文章：</p><blockquote><p>参考链接：<a href="https://segmentfault.com/a/1190000023308658" target="_blank" rel="noreferrer">https://segmentfault.com/a/1190000023308658</a></p></blockquote><p>里面提到了一个概念：<strong>二项分布（Binomial Distribution）</strong>。</p><p>在做一件事情的时候，其结果的概率只有2种情况，和抛硬币一样，不是正面就是反面。</p><p>假如，我们做了 N 次实验，那么在每次试验中只有两种可能的结果，并且每次实验是独立的，不同实验之间互不影响，每次实验成功的概率都是一样的。</p><p>以此理论为基础：我们往哈希表中扔数据，如果发生哈希冲突就为失败，否则为成功。</p><p>我们可以设想，实验的hash值是随机的，并且经过hash运算的键都会映射到hash表的地址空间上，那么这个结果也是随机的。所以，每次put的时候就相当于我们在扔一个16面（HashMap 第一次扩容后的数组默认长度为16）的骰子，扔骰子实验那肯定是相互独立的。碰撞发生即扔了n次有出现重复数字。</p><p>然后，我们的目的是啥呢？</p><p>就是掷了k次骰子，没有一次是相同的概率，需要尽可能的大些，一般意义上我们肯定要大于0.5（这个数是个理想数）。</p><p>于是，n次事件里面，碰撞为0的概率，由上面公式得：</p><img src="`+E+'"><p>这个概率值需要大于0.5，我们认为这样的hashmap可以提供很低的碰撞率。所以：</p><p>&lt;img src=&quot;./images/hashmap-loadfactor-03png)</p><p>这时候，我们对于该公式其实最想求的时候长度s的时候，n为多少次就应该进行扩容了？而负载因子则是$n/s$的值。所以推导如下：</p><img src="'+A+'"><p>所以可以得到</p><img src="'+h+'"><p>其中</p><img src="'+C+'"><p>这就是一个求 <code>∞⋅0</code>函数极限问题，这里我们先令$s = m+1（m \\to \\infty）$则转化为</p><img src="'+d+'"><p>我们再令 $x = \\frac{1}{m} （x \\to 0）$ 则有，</p><img src="'+u+'"><p>所以</p><img src="'+D+`"><p>考虑到 HashMap的容量有一个要求：它必须是2的n 次幂。当加载因子选择了0.75就可以保证它与容量的乘积为整数。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">16*0.75=12</span></span>
<span class="line"><span style="color:#f6f6f4;">32*0.75=24</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">16*0.75=12</span></span>
<span class="line"><span style="color:#24292e;">32*0.75=24</span></span></code></pre></div><p>除了 0.75，0.5~1 之间还有 0.625（5/8）、0.875（7/8）可选，从中位数的角度，挑 0.75 比较完美。另外，维基百科上说，拉链法（解决哈希冲突的一种）的加载因子最好限制在 0.7-0.8以下，超过0.8，查表时的CPU缓存不命中（cache missing）会按照指数曲线上升。</p><p>综上，0.75 是个比较完美的选择。</p><h4 id="小结-2" tabindex="-1">小结 <a class="header-anchor" href="#小结-2" aria-label="Permalink to &quot;小结&quot;">​</a></h4><p>HashMap 的加载因子（load factor，直译为加载因子，意译为负载因子）是指哈希表中填充元素的个数与桶的数量的比值，当元素个数达到负载因子与桶的数量的乘积时，就需要进行扩容。这个值一般选择 0.75，是因为这个值可以在时间和空间成本之间做到一个折中，使得哈希表的性能达到较好的表现。</p><p>如果负载因子过大，填充因子较多，那么哈希表中的元素就会越来越多地聚集在少数的桶中，这就导致了冲突的增加，这些冲突会导致查找、插入和删除操作的效率下降。同时，这也会导致需要更频繁地进行扩容，进一步降低了性能。</p><p>如果负载因子过小，那么桶的数量会很多，虽然可以减少冲突，但是在空间利用上面也会有浪费，因此选择 0.75 是为了取得一个平衡点，即在时间和空间成本之间取得一个比较好的平衡点。</p><p>总之，选择 0.75 这个值是为了在时间和空间成本之间达到一个较好的平衡点，既可以保证哈希表的性能表现，又能够充分利用空间。</p><h3 id="_04、线程不安全" tabindex="-1">04、线程不安全 <a class="header-anchor" href="#_04、线程不安全" aria-label="Permalink to &quot;04、线程不安全&quot;">​</a></h3><p>其实这个问题也不用说太多，但考虑到<a href="https://tobebetterjavaer.com/interview/java-hashmap-13.html" target="_blank" rel="noreferrer">面试的时候有些面试官会问</a>，那就简单说一下。</p><p>三方面原因：</p><ul><li>多线程下扩容会死循环</li><li>多线程下 put 会导致元素丢失</li><li>put 和 get 并发时会导致 get 到 null</li></ul><h4 id="_1-多线程下扩容会死循环" tabindex="-1">1）多线程下扩容会死循环 <a class="header-anchor" href="#_1-多线程下扩容会死循环" aria-label="Permalink to &quot;1）多线程下扩容会死循环&quot;">​</a></h4><p>众所周知，HashMap 是通过拉链法来解决哈希冲突的，也就是当哈希冲突时，会将相同哈希值的键值对通过链表的形式存放起来。</p><p>JDK 7 时，采用的是头部插入的方式来存放链表的，也就是下一个冲突的键值对会放在上一个键值对的前面（讲扩容的时候讲过了）。扩容的时候就有可能导致出现环形链表，造成死循环。</p><p>resize 方法的源码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#7B7F8B;">// newCapacity为新的容量</span></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">void</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">resize</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> newCapacity) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 小数组，临时过度下</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">[] oldTable </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> table;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 扩容前的容量</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> oldCapacity </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> oldTable.length;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 = 1&lt;&lt;30</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (oldCapacity </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> MAXIMUM_CAPACITY) {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#7B7F8B;">// 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2 的 31 次方-1</span></span>
<span class="line"><span style="color:#F6F6F4;">        threshold </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> Integer.MAX_VALUE;</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 初始化一个新的数组（大容量）</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">[] newTable </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">[newCapacity];</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 把小数组的元素转移到大数组中</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#62E884;">transfer</span><span style="color:#F6F6F4;">(newTable, </span><span style="color:#62E884;">initHashSeedAsNeeded</span><span style="color:#F6F6F4;">(newCapacity));</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 引用新的大数组</span></span>
<span class="line"><span style="color:#F6F6F4;">    table </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> newTable;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 重新计算阈值</span></span>
<span class="line"><span style="color:#F6F6F4;">    threshold </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;">)Math.</span><span style="color:#62E884;">min</span><span style="color:#F6F6F4;">(newCapacity </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;"> loadFactor, MAXIMUM_CAPACITY </span><span style="color:#F286C4;">+</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// newCapacity为新的容量</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">resize</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> newCapacity) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 小数组，临时过度下</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">Entry</span><span style="color:#24292E;">[] oldTable </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> table;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 扩容前的容量</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> oldCapacity </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldTable.length;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 = 1&lt;&lt;30</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldCapacity </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> MAXIMUM_CAPACITY) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2 的 31 次方-1</span></span>
<span class="line"><span style="color:#24292E;">        threshold </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Integer.MAX_VALUE;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化一个新的数组（大容量）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">Entry</span><span style="color:#24292E;">[] newTable </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Entry</span><span style="color:#24292E;">[newCapacity];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 把小数组的元素转移到大数组中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">transfer</span><span style="color:#24292E;">(newTable, </span><span style="color:#6F42C1;">initHashSeedAsNeeded</span><span style="color:#24292E;">(newCapacity));</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 引用新的大数组</span></span>
<span class="line"><span style="color:#24292E;">    table </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newTable;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 重新计算阈值</span></span>
<span class="line"><span style="color:#24292E;">    threshold </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">)Math.</span><span style="color:#6F42C1;">min</span><span style="color:#24292E;">(newCapacity </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> loadFactor, MAXIMUM_CAPACITY </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>transfer 方法用来转移，将小数组的元素拷贝到新的数组中。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">void</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">transfer</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">[] newTable, </span><span style="color:#97E1F1;font-style:italic;">boolean</span><span style="color:#F6F6F4;"> rehash) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 新的容量</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> newCapacity </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> newTable.length;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 遍历小数组</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">for</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">&lt;K,V&gt; e </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> table) {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">while</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> e) {</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#7B7F8B;">// 拉链法，相同 key 上的不同值</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">&lt;K,V&gt; next </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e.next;</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#7B7F8B;">// 是否需要重新计算 hash</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (rehash) {</span></span>
<span class="line"><span style="color:#F6F6F4;">                e.hash </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> e.key </span><span style="color:#F286C4;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">hash</span><span style="color:#F6F6F4;">(e.key);</span></span>
<span class="line"><span style="color:#F6F6F4;">            }</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#7B7F8B;">// 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> i </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">indexFor</span><span style="color:#F6F6F4;">(e.hash, newCapacity);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#7B7F8B;">// 同一位置上的新元素被放在链表的头部</span></span>
<span class="line"><span style="color:#F6F6F4;">            e.next </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> newTable[i];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#7B7F8B;">// 放在新的数组上</span></span>
<span class="line"><span style="color:#F6F6F4;">            newTable[i] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#7B7F8B;">// 链表上的下一个元素</span></span>
<span class="line"><span style="color:#F6F6F4;">            e </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> next;</span></span>
<span class="line"><span style="color:#F6F6F4;">        }</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">transfer</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">Entry</span><span style="color:#24292E;">[] newTable, </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> rehash) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 新的容量</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> newCapacity </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newTable.length;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 遍历小数组</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; e </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> table) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> e) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 拉链法，相同 key 上的不同值</span></span>
<span class="line"><span style="color:#24292E;">            Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e.next;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 是否需要重新计算 hash</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (rehash) {</span></span>
<span class="line"><span style="color:#24292E;">                e.hash </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> e.key </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">hash</span><span style="color:#24292E;">(e.key);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">indexFor</span><span style="color:#24292E;">(e.hash, newCapacity);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 同一位置上的新元素被放在链表的头部</span></span>
<span class="line"><span style="color:#24292E;">            e.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newTable[i];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 放在新的数组上</span></span>
<span class="line"><span style="color:#24292E;">            newTable[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 链表上的下一个元素</span></span>
<span class="line"><span style="color:#24292E;">            e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> next;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>注意 <code>e.next = newTable[i]</code> 和 <code>newTable[i] = e</code> 这两行代码，就会将同一位置上的新元素被放在链表的头部。</p><p>扩容前的样子假如是下面这样子。</p><img src="`+f+'"><p>那么正常扩容后就是下面这样子。</p><img src="'+g+'"><p>假设现在有两个线程同时进行扩容，线程 A 在执行到 <code>newTable[i] = e;</code> 被挂起，此时线程 A 中：e=3、next=7、e.next=null</p><img src="'+b+'"><p>线程 B 开始执行，并且完成了数据转移。</p><img src="'+m+'"><p>此时，7 的 next 为 3，3 的 next 为 null。</p><p>随后线程A获得CPU时间片继续执行 <code>newTable[i] = e</code>，将3放入新数组对应的位置，执行完此轮循环后线程A的情况如下：</p><img src="'+v+'"><p>执行下一轮循环，此时 e=7，原本线程 A 中 7 的 next 为 5，但由于 table 是线程 A 和线程 B 共享的，而线程 B 顺利执行完后，7 的 next 变成了 3，那么此时线程 A 中，7 的 next 也为 3 了。</p><p>采用头部插入的方式，变成了下面这样子：</p><img src="'+T+'"><p>好像也没什么问题，此时 next = 3，e = 3。</p><p>进行下一轮循环，但此时，由于线程 B 将 3 的 next 变为了 null，所以此轮循环应该是最后一轮了。</p><p>接下来当执行完 <code>e.next=newTable[i]</code> 即 3.next=7 后，3 和 7 之间就相互链接了，执行完 <code>newTable[i]=e</code> 后，3 被头插法重新插入到链表中，执行结果如下图所示：</p><img src="'+k+'"><p>套娃开始，元素 5 也就成了弃婴，惨~~~</p><p>不过，JDK 8 时已经修复了这个问题，扩容时会保持链表原来的顺序（嗯，等于说了半天白说了，哈哈，这个面试题确实是这样，很水，但有些面试官又确实比较装逼）。</p><h4 id="_2-多线程下-put-会导致元素丢失" tabindex="-1">2）多线程下 put 会导致元素丢失 <a class="header-anchor" href="#_2-多线程下-put-会导致元素丢失" aria-label="Permalink to &quot;2）多线程下 put 会导致元素丢失&quot;">​</a></h4><p>正常情况下，当发生哈希冲突时，HashMap 是这样的：</p><img src="'+B+`"><p>但多线程同时执行 put 操作时，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。</p><p>put 的源码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">V</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">putVal</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> hash, </span><span style="color:#97E1F1;font-style:italic;">K</span><span style="color:#F6F6F4;"> key, </span><span style="color:#97E1F1;font-style:italic;">V</span><span style="color:#F6F6F4;"> value, </span><span style="color:#97E1F1;font-style:italic;">boolean</span><span style="color:#F6F6F4;"> onlyIfAbsent,</span></span>
<span class="line"><span style="color:#F6F6F4;">               </span><span style="color:#97E1F1;font-style:italic;">boolean</span><span style="color:#F6F6F4;"> evict) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt;[] tab; </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt; p; </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> n, i;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 步骤①：tab为空则创建</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> ((tab </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> table) </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">||</span><span style="color:#F6F6F4;"> (n </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> tab.length) </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">)</span></span>
<span class="line"><span style="color:#F6F6F4;">        n </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (tab </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">resize</span><span style="color:#F6F6F4;">()).length;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 步骤②：计算index，并对null做处理 </span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> ((p </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> tab[i </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (n </span><span style="color:#F286C4;">-</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;"> hash]) </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">)</span></span>
<span class="line"><span style="color:#F6F6F4;">        tab[i] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">newNode</span><span style="color:#F6F6F4;">(hash, key, value, </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt; e; </span><span style="color:#97E1F1;font-style:italic;">K</span><span style="color:#F6F6F4;"> k;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#7B7F8B;">// 步骤③：节点key存在，直接覆盖value</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (p.hash </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> hash </span><span style="color:#F286C4;">&amp;&amp;</span></span>
<span class="line"><span style="color:#F6F6F4;">            ((k </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> p.key) </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> key </span><span style="color:#F286C4;">||</span><span style="color:#F6F6F4;"> (key </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">&amp;&amp;</span><span style="color:#F6F6F4;"> key.</span><span style="color:#62E884;">equals</span><span style="color:#F6F6F4;">(k))))</span></span>
<span class="line"><span style="color:#F6F6F4;">            e </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> p;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#7B7F8B;">// 步骤④：判断该链为红黑树</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (p </span><span style="color:#F286C4;">instanceof</span><span style="color:#F6F6F4;"> TreeNode)</span></span>
<span class="line"><span style="color:#F6F6F4;">            e </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> ((</span><span style="color:#97E1F1;font-style:italic;">TreeNode</span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;">K,V</span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;">)p).</span><span style="color:#62E884;">putTreeVal</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">, tab, hash, key, value);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#7B7F8B;">// 步骤⑤：该链为链表</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">for</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> binCount </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">; ; </span><span style="color:#F286C4;">++</span><span style="color:#F6F6F4;">binCount) {</span></span>
<span class="line"><span style="color:#F6F6F4;">                </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> ((e </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> p.next) </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#F6F6F4;">                    p.next </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">newNode</span><span style="color:#F6F6F4;">(hash, key, value, </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">                    </span><span style="color:#7B7F8B;">//链表长度大于8转换为红黑树进行处理</span></span>
<span class="line"><span style="color:#F6F6F4;">                    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (binCount </span><span style="color:#F286C4;">&gt;=</span><span style="color:#F6F6F4;"> TREEIFY_THRESHOLD </span><span style="color:#F286C4;">-</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">) </span><span style="color:#7B7F8B;">// -1 for 1st</span></span>
<span class="line"><span style="color:#F6F6F4;">                        </span><span style="color:#62E884;">treeifyBin</span><span style="color:#F6F6F4;">(tab, hash);</span></span>
<span class="line"><span style="color:#F6F6F4;">                    </span><span style="color:#F286C4;">break</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">                }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">                </span><span style="color:#7B7F8B;">// key已经存在直接覆盖value</span></span>
<span class="line"><span style="color:#F6F6F4;">                </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (e.hash </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> hash </span><span style="color:#F286C4;">&amp;&amp;</span></span>
<span class="line"><span style="color:#F6F6F4;">                    ((k </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e.key) </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> key </span><span style="color:#F286C4;">||</span><span style="color:#F6F6F4;"> (key </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">&amp;&amp;</span><span style="color:#F6F6F4;"> key.</span><span style="color:#62E884;">equals</span><span style="color:#F6F6F4;">(k))))</span></span>
<span class="line"><span style="color:#F6F6F4;">                    </span><span style="color:#F286C4;">break</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">                p </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e;</span></span>
<span class="line"><span style="color:#F6F6F4;">            }</span></span>
<span class="line"><span style="color:#F6F6F4;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#7B7F8B;">// 步骤⑥、直接覆盖</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (e </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) { </span><span style="color:#7B7F8B;">// existing mapping for key</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#97E1F1;font-style:italic;">V</span><span style="color:#F6F6F4;"> oldValue </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e.value;</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (</span><span style="color:#F286C4;">!</span><span style="color:#F6F6F4;">onlyIfAbsent </span><span style="color:#F286C4;">||</span><span style="color:#F6F6F4;"> oldValue </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">)</span></span>
<span class="line"><span style="color:#F6F6F4;">                e.value </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> value;</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#62E884;">afterNodeAccess</span><span style="color:#F6F6F4;">(e);</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> oldValue;</span></span>
<span class="line"><span style="color:#F6F6F4;">        }</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">++</span><span style="color:#F6F6F4;">modCount;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 步骤⑦：超过最大容量 就扩容</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (</span><span style="color:#F286C4;">++</span><span style="color:#F6F6F4;">size </span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;"> threshold)</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#62E884;">resize</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#62E884;">afterNodeInsertion</span><span style="color:#F6F6F4;">(evict);</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> V </span><span style="color:#6F42C1;">putVal</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> hash, K key, V value, </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> onlyIfAbsent,</span></span>
<span class="line"><span style="color:#24292E;">               </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> evict) {</span></span>
<span class="line"><span style="color:#24292E;">    Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt;[] tab; Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; p; </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> n, i;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 步骤①：tab为空则创建</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((tab </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> table) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tab.length) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (tab </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">resize</span><span style="color:#24292E;">()).length;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 步骤②：计算index，并对null做处理 </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tab[i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> hash]) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        tab[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">newNode</span><span style="color:#24292E;">(hash, key, value, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; e; K k;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 步骤③：节点key存在，直接覆盖value</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (p.hash </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> hash </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">            ((k </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p.key) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> key </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (key </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> key.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(k))))</span></span>
<span class="line"><span style="color:#24292E;">            e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 步骤④：判断该链为红黑树</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (p </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> TreeNode)</span></span>
<span class="line"><span style="color:#24292E;">            e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ((TreeNode</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">)p).</span><span style="color:#6F42C1;">putTreeVal</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, tab, hash, key, value);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 步骤⑤：该链为链表</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> binCount </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; ; </span><span style="color:#D73A49;">++</span><span style="color:#24292E;">binCount) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p.next) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    p.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">newNode</span><span style="color:#24292E;">(hash, key, value, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">//链表长度大于8转换为红黑树进行处理</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (binCount </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> TREEIFY_THRESHOLD </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// -1 for 1st</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#6F42C1;">treeifyBin</span><span style="color:#24292E;">(tab, hash);</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// key已经存在直接覆盖value</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (e.hash </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> hash </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">                    ((k </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e.key) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> key </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (key </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> key.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(k))))</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 步骤⑥、直接覆盖</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (e </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// existing mapping for key</span></span>
<span class="line"><span style="color:#24292E;">            V oldValue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e.value;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">onlyIfAbsent </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> oldValue </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                e.value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> value;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">afterNodeAccess</span><span style="color:#24292E;">(e);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> oldValue;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">++</span><span style="color:#24292E;">modCount;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 步骤⑦：超过最大容量 就扩容</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">size </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> threshold)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">resize</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">afterNodeInsertion</span><span style="color:#24292E;">(evict);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>问题发生在步骤 ② 这里：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> ((p </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> tab[i </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (n </span><span style="color:#F286C4;">-</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">&amp;</span><span style="color:#F6F6F4;"> hash]) </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">)</span></span>
<span class="line"><span style="color:#F6F6F4;">    tab[i] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">newNode</span><span style="color:#F6F6F4;">(hash, key, value, </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tab[i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> hash]) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    tab[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">newNode</span><span style="color:#24292E;">(hash, key, value, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span></code></pre></div><p>两个线程都执行了 if 语句，假设线程 A 先执行了 <code> tab[i] = newNode(hash, key, value, null)</code>，那 table 是这样的：</p><img src="`+q+'"><p>接着，线程 B 执行了 <code> tab[i] = newNode(hash, key, value, null)</code>，那 table 是这样的：</p><img src="'+M+`"><p>3 被干掉了。</p><h4 id="_3-put-和-get-并发时会导致-get-到-null" tabindex="-1">3）put 和 get 并发时会导致 get 到 null <a class="header-anchor" href="#_3-put-和-get-并发时会导致-get-到-null" aria-label="Permalink to &quot;3）put 和 get 并发时会导致 get 到 null&quot;">​</a></h4><p>线程 A 执行put时，因为元素个数超出阈值而出现扩容，线程B 此时执行get，有可能导致这个问题。</p><p>注意来看 resize 源码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;">K,V</span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;">[] </span><span style="color:#62E884;">resize</span><span style="color:#F6F6F4;">() {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt;[] oldTab </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> table;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> oldCap </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (oldTab </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> oldTab.length;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> oldThr </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> threshold;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> newCap, newThr </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (oldCap </span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#7B7F8B;">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (oldCap </span><span style="color:#F286C4;">&gt;=</span><span style="color:#F6F6F4;"> MAXIMUM_CAPACITY) {</span></span>
<span class="line"><span style="color:#F6F6F4;">            threshold </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> Integer.MAX_VALUE;</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> oldTab;</span></span>
<span class="line"><span style="color:#F6F6F4;">        }</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#7B7F8B;">// 没超过最大值，就扩充为原来的2倍</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> ((newCap </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> oldCap </span><span style="color:#F286C4;">&lt;&lt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> MAXIMUM_CAPACITY </span><span style="color:#F286C4;">&amp;&amp;</span></span>
<span class="line"><span style="color:#F6F6F4;">                 oldCap </span><span style="color:#F286C4;">&gt;=</span><span style="color:#F6F6F4;"> DEFAULT_INITIAL_CAPACITY)</span></span>
<span class="line"><span style="color:#F6F6F4;">            newThr </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> oldThr </span><span style="color:#F286C4;">&lt;&lt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">; </span><span style="color:#7B7F8B;">// double threshold</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (oldThr </span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">) </span><span style="color:#7B7F8B;">// initial capacity was placed in threshold</span></span>
<span class="line"><span style="color:#F6F6F4;">        newCap </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> oldThr;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> {               </span><span style="color:#7B7F8B;">// zero initial threshold signifies using defaults</span></span>
<span class="line"><span style="color:#F6F6F4;">        newCap </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> DEFAULT_INITIAL_CAPACITY;</span></span>
<span class="line"><span style="color:#F6F6F4;">        newThr </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;">)(DEFAULT_LOAD_FACTOR </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;"> DEFAULT_INITIAL_CAPACITY);</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 计算新的resize上限</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (newThr </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#97E1F1;font-style:italic;">float</span><span style="color:#F6F6F4;"> ft </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">float</span><span style="color:#F6F6F4;">)newCap </span><span style="color:#F286C4;">*</span><span style="color:#F6F6F4;"> loadFactor;</span></span>
<span class="line"><span style="color:#F6F6F4;">        newThr </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (newCap </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> MAXIMUM_CAPACITY </span><span style="color:#F286C4;">&amp;&amp;</span><span style="color:#F6F6F4;"> ft </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">float</span><span style="color:#F6F6F4;">)MAXIMUM_CAPACITY </span><span style="color:#F286C4;">?</span></span>
<span class="line"><span style="color:#F6F6F4;">                  (</span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;">)ft </span><span style="color:#F286C4;">:</span><span style="color:#F6F6F4;"> Integer.MAX_VALUE);</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    threshold </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> newThr;</span></span>
<span class="line"><span style="color:#F6F6F4;">    @</span><span style="color:#97E1F1;font-style:italic;">SuppressWarnings</span><span style="color:#F6F6F4;">({</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">rawtypes</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">,</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">unchecked</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">})</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;K,V&gt;[] newTab </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;">K,V</span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;">[])</span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">[newCap];</span></span>
<span class="line"><span style="color:#F6F6F4;">    table </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> newTab;</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">resize</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt;[] oldTab </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> table;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> oldCap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (oldTab </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> oldTab.length;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> oldThr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> threshold;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> newCap, newThr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldCap </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldCap </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> MAXIMUM_CAPACITY) {</span></span>
<span class="line"><span style="color:#24292E;">            threshold </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Integer.MAX_VALUE;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> oldTab;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 没超过最大值，就扩充为原来的2倍</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((newCap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldCap </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> MAXIMUM_CAPACITY </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">                 oldCap </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> DEFAULT_INITIAL_CAPACITY)</span></span>
<span class="line"><span style="color:#24292E;">            newThr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldThr </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// double threshold</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldThr </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// initial capacity was placed in threshold</span></span>
<span class="line"><span style="color:#24292E;">        newCap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldThr;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {               </span><span style="color:#6A737D;">// zero initial threshold signifies using defaults</span></span>
<span class="line"><span style="color:#24292E;">        newCap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> DEFAULT_INITIAL_CAPACITY;</span></span>
<span class="line"><span style="color:#24292E;">        newThr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">)(DEFAULT_LOAD_FACTOR </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> DEFAULT_INITIAL_CAPACITY);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 计算新的resize上限</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newThr </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">float</span><span style="color:#24292E;"> ft </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">float</span><span style="color:#24292E;">)newCap </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> loadFactor;</span></span>
<span class="line"><span style="color:#24292E;">        newThr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (newCap </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> MAXIMUM_CAPACITY </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> ft </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">float</span><span style="color:#24292E;">)MAXIMUM_CAPACITY </span><span style="color:#D73A49;">?</span></span>
<span class="line"><span style="color:#24292E;">                  (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">)ft </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> Integer.MAX_VALUE);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    threshold </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newThr;</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">SuppressWarnings</span><span style="color:#24292E;">({</span><span style="color:#032F62;">&quot;rawtypes&quot;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&quot;unchecked&quot;</span><span style="color:#24292E;">})</span></span>
<span class="line"><span style="color:#24292E;">        Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt;[] newTab </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (Node</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">[])</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Node</span><span style="color:#24292E;">[newCap];</span></span>
<span class="line"><span style="color:#24292E;">    table </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newTab;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>线程 A 执行完 <code>table = newTab</code> 之后，线程 B 中的 table 此时也发生了变化，此时去 get 的时候当然会 get 到 null 了，因为元素还没有转移。</p><p>参考链接：</p><blockquote><ul><li><a href="https://blog.csdn.net/lonyw/article/details/80519652" target="_blank" rel="noreferrer">https://blog.csdn.net/lonyw/article/details/80519652</a></li><li><a href="https://zhuanlan.zhihu.com/p/91636401" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/91636401</a></li><li><a href="https://www.zhihu.com/question/20733617" target="_blank" rel="noreferrer">https://www.zhihu.com/question/20733617</a></li><li><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/21673805</a></li></ul></blockquote><h4 id="_4-小结" tabindex="-1">4）小结 <a class="header-anchor" href="#_4-小结" aria-label="Permalink to &quot;4）小结&quot;">​</a></h4><p>HashMap 是线程不安全的主要是因为它在进行插入、删除和扩容等操作时可能会导致链表的结构发生变化，从而破坏了 HashMap 的不变性。具体来说，如果在一个线程正在遍历 HashMap 的链表时，另外一个线程对该链表进行了修改（比如添加了一个节点），那么就会导致链表的结构发生变化，从而破坏了当前线程正在进行的遍历操作，可能导致遍历失败或者出现死循环等问题。</p><p>为了解决这个问题，Java 提供了线程安全的 HashMap 实现类 <a href="https://tobebetterjavaer.com/thread/ConcurrentHashMap.html" target="_blank" rel="noreferrer">ConcurrentHashMap</a>。ConcurrentHashMap 内部采用了分段锁（Segment），将整个 Map 拆分为多个小的 HashMap，每个小的 HashMap 都有自己的锁，不同的线程可以同时访问不同的小 Map，从而实现了线程安全。在进行插入、删除和扩容等操作时，只需要锁住当前小 Map，不会对整个 Map 进行锁定，提高了并发访问的效率。</p><h3 id="_05、总结" tabindex="-1">05、总结 <a class="header-anchor" href="#_05、总结" aria-label="Permalink to &quot;05、总结&quot;">​</a></h3><p>HashMap是Java中最常用的集合之一，它是一种键值对存储的数据结构，可以根据键来快速访问对应的值。以下是对HashMap的总结：</p><ul><li>HashMap采用数组+链表/红黑树的存储结构，能够在O(1)的时间复杂度内实现元素的添加、删除、查找等操作。</li><li>HashMap是线程不安全的，因此在多线程环境下需要使用<a href="https://tobebetterjavaer.com/thread/ConcurrentHashMap.html" target="_blank" rel="noreferrer">ConcurrentHashMap</a>来保证线程安全。</li><li>HashMap的扩容机制是通过扩大数组容量和重新计算hash值来实现的，扩容时需要重新计算所有元素的hash值，因此在元素较多时扩容会影响性能。</li><li>在Java 8中，HashMap的实现引入了拉链法、树化等机制来优化大量元素存储的情况，进一步提升了性能。</li><li>HashMap中的key是唯一的，如果要存储重复的key，则后面的值会覆盖前面的值。</li><li>HashMap的初始容量和加载因子都可以设置，初始容量表示数组的初始大小，加载因子表示数组的填充因子。一般情况下，初始容量为16，加载因子为0.75。</li><li>HashMap在遍历时是无序的，因此如果需要有序遍历，可以使用<a href="https://tobebetterjavaer.com/collection/treemap.html" target="_blank" rel="noreferrer">TreeMap</a>。</li></ul><p>综上所述，HashMap是一种高效的数据结构，具有快速查找和插入元素的能力，但需要注意线程安全和性能问题。</p><hr>`,334),H=[I];function N(x,j,V,P,U,X){return a(),n("div",null,H)}const Y=s(w,[["render",N]]);export{K as __pageData,Y as default};
