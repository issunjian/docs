import{_ as s,o as a,c as n,V as l}from"./chunks/framework.c6d8cbec.js";const e="/docs/assets/moxing-20230408110408.919f4a23.png",o="/docs/assets/moxing-20230408110433.33805813.png",p="/docs/assets/buffer-channel-selector-20230406182813.61959a1a.png",t="/docs/assets/moxing-20230408114300.a9485457.png",c="/docs/assets/moxing-20230408115158.e7af81f2.png",r="/docs/assets/moxing-20230408115251.a7b2217d.png",y="/docs/assets/moxing-20230408115328.141d6368.png",v=JSON.parse('{"title":"一文彻底理解Java IO模型（阻塞IO非阻塞IO/IO多路复用）","description":"I/O 模型包括阻塞 I/O、非阻塞 I/O、多路复用、信号驱动和异步 I/O。阻塞 I/O 操作等待数据传输完成，非阻塞 I/O 操作不等待，可执行其他任务。多路复用适用于高并发和高吞吐量场景，信号驱动依赖信号通知应用程序。异步 I/O 由内核负责数据传输，应用程序无需等待。","frontmatter":{"title":"一文彻底理解Java IO模型（阻塞IO非阻塞IO/IO多路复用）","shortTitle":"Java IO模型","category":["Java核心"],"tag":["Java NIO"],"description":"I/O 模型包括阻塞 I/O、非阻塞 I/O、多路复用、信号驱动和异步 I/O。阻塞 I/O 操作等待数据传输完成，非阻塞 I/O 操作不等待，可执行其他任务。多路复用适用于高并发和高吞吐量场景，信号驱动依赖信号通知应用程序。异步 I/O 由内核负责数据传输，应用程序无需等待。","author":"沉默王二","head":[["meta",{"name":"keywords","content":"IO模型, 阻塞IO, 非阻塞IO, 多路复用, 信号驱动, 异步IO,java,nio"}]]},"headers":[],"relativePath":"backend/tobetter/nio/moxing.md","filePath":"backend/tobetter/nio/moxing.md"}'),i={name:"backend/tobetter/nio/moxing.md"},F=l("",52),I=[F];function h(O,d,E,C,k,g){return a(),n("div",null,I)}const f=s(i,[["render",h]]);export{v as __pageData,f as default};
