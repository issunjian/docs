import{_ as e,o as a,c as t,V as s}from"./chunks/framework.c6d8cbec.js";const B=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/react/React最新面试题2021年，常见面试题及答案汇总.md","filePath":"interview/backend/react/React最新面试题2021年，常见面试题及答案汇总.md"}'),n={name:"interview/backend/react/React最新面试题2021年，常见面试题及答案汇总.md"},o=s(`<h3 id="_1、react-中-refs-的作用是什么" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#1react-%E4%B8%AD-refs-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noreferrer">1、React 中 refs 的作用是什么</a> <a class="header-anchor" href="#_1、react-中-refs-的作用是什么" aria-label="Permalink to &quot;[1、React 中 refs 的作用是什么](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新面试题2021年，常见面试题及答案汇总.md#1react-中-refs-的作用是什么)&quot;">​</a></h3><p><code>Refs</code> 是 <code>React</code> 提供给我们的安全访问 <code>DOM</code>元素或者某个组件实例的句柄可以为元素添加ref属性然后在回调函数中接受该元素在 <code>DOM</code> 树中的句柄该值会作为回调函数的第一个参数返回</p><h3 id="_2、区分状态和-props" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#2%E5%8C%BA%E5%88%86%E7%8A%B6%E6%80%81%E5%92%8C-props" target="_blank" rel="noreferrer">2、区分状态和 props</a> <a class="header-anchor" href="#_2、区分状态和-props" aria-label="Permalink to &quot;[2、区分状态和 props](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新面试题2021年，常见面试题及答案汇总.md#2区分状态和-props)&quot;">​</a></h3><table><thead><tr><th>条件</th><th>State</th><th>Props</th></tr></thead><tbody><tr><td>1、从父组件中接收初始值</td><td>Yes</td><td>Yes</td></tr><tr><td>2、父组件可以改变值</td><td>No</td><td>Yes</td></tr><tr><td>3、在组件中设置默认值</td><td>Yes</td><td>Yes</td></tr><tr><td>4、在组件的内部变化</td><td>Yes</td><td>No</td></tr><tr><td>5、设置子组件的初始值</td><td>Yes</td><td>Yes</td></tr><tr><td>6、在子组件的内部更改</td><td>No</td><td>Yes</td></tr></tbody></table><h3 id="_3、什么是redux" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#3%E4%BB%80%E4%B9%88%E6%98%AFredux" target="_blank" rel="noreferrer">3、什么是Redux？</a> <a class="header-anchor" href="#_3、什么是redux" aria-label="Permalink to &quot;[3、什么是Redux？](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新面试题2021年，常见面试题及答案汇总.md#3什么是redux)&quot;">​</a></h3><p>Redux 是当今最热门的前端开发库之一。它是 JavaScript 程序的可预测状态容器，用于整个应用的状态管理。使用 Redux 开发的应用易于测试，可以在不同环境中运行，并显示一致的行为。</p><h3 id="_4、react的请求应该放在哪个生命周期中" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#4react%E7%9A%84%E8%AF%B7%E6%B1%82%E5%BA%94%E8%AF%A5%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD" target="_blank" rel="noreferrer">4、React的请求应该放在哪个生命周期中?</a> <a class="header-anchor" href="#_4、react的请求应该放在哪个生命周期中" aria-label="Permalink to &quot;[4、React的请求应该放在哪个生命周期中?](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新面试题2021年，常见面试题及答案汇总.md#4react的请求应该放在哪个生命周期中)&quot;">​</a></h3><p>React的异步请求到底应该放在哪个生命周期里,有人认为在<code>componentWillMount</code>中可以提前进行异步请求,避免白屏,其实这个观点是有问题的.</p><p>由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 - React继续前进并继续render,没有办法“暂停”渲染以等待数据到达。</p><p>而且在<code>componentWillMount</code>请求会有一系列潜在的问题,首先,在服务器渲染时,如果在 componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造成了多余的请求,其次,在React 16进行React Fiber重写后,<code>componentWillMount</code>可能在一次渲染中多次调用.</p><p>目前官方推荐的异步请求是在<code>componentDidmount</code>中进行.</p><p>如果有特殊需求需要提前请求,也可以在特殊情况下在<code>constructor</code>中请求:</p><blockquote><p>react 17之后<code>componentWillMount</code>会被废弃,仅仅保留<code>UNSAFE_componentWillMount</code></p></blockquote><h3 id="_5、列出-redux-的组件。" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#5%E5%88%97%E5%87%BA-redux-%E7%9A%84%E7%BB%84%E4%BB%B6%E3%80%82" target="_blank" rel="noreferrer">5、列出 Redux 的组件。</a> <a class="header-anchor" href="#_5、列出-redux-的组件。" aria-label="Permalink to &quot;[5、列出 Redux 的组件。](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新面试题2021年，常见面试题及答案汇总.md#5列出-redux-的组件。)&quot;">​</a></h3><p>Redux 由以下组件组成：</p><p><strong>1、</strong> Action – 这是一个用来描述发生了什么事情的对象。</p><p><strong>2、</strong> Reducer – 这是一个确定状态将如何变化的地方。</p><p><strong>3、</strong> Store – 整个程序的状态/对象树保存在Store中。</p><p><strong>4、</strong> View – 只显示 Store 提供的数据。</p><h3 id="_6、redux异步中间件之间的优劣" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#6redux%E5%BC%82%E6%AD%A5%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%98%E5%8A%A3" target="_blank" rel="noreferrer">6、redux异步中间件之间的优劣?</a> <a class="header-anchor" href="#_6、redux异步中间件之间的优劣" aria-label="Permalink to &quot;[6、redux异步中间件之间的优劣?](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新面试题2021年，常见面试题及答案汇总.md#6redux异步中间件之间的优劣)&quot;">​</a></h3><p><strong>redux-thunk优点:</strong></p><p><strong>1、</strong> 体积小: redux-thunk的实现方式很简单,只有不到20行代码</p><p><strong>2、</strong> 使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简单</p><p><strong>redux-thunk缺陷:</strong></p><p><strong>1、</strong> 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的</p><p><strong>2、</strong> 耦合严重: 异步操作与redux的action偶合在一起,不方便管理</p><p><strong>3、</strong> 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装</p><p><strong>redux-saga优点:</strong></p><p><strong>1、</strong> 异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中</p><p><strong>2、</strong> action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满 “黑魔法” thunk function</p><p><strong>3、</strong> 异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理</p><p><strong>4、</strong> 功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者无须封装或者简单封装即可使用</p><p><strong>5、</strong> 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow</p><p><strong>6、</strong> 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等</p><p><strong>redux-saga缺陷:</strong></p><p><strong>1、</strong> 额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想</p><p><strong>2、</strong> 体积庞大: 体积略大,代码近2000行，min版25KB左右</p><p><strong>3、</strong> 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码</p><p><strong>4、</strong> ts支持不友好: yield无法返回TS类型</p><p><strong>redux-observable优点:</strong></p><p><strong>1、</strong> 功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你能想到的异步处理</p><p><strong>2、</strong> 背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而且随着rxjs的升级redux-observable也会变得更强大</p><p><strong>redux-observable缺陷:</strong></p><p>学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库</p><p>社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步流中间件这个层面redux-saga仍处于领导地位</p><h3 id="_7、如何模块化-react-中的代码" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#7%E5%A6%82%E4%BD%95%E6%A8%A1%E5%9D%97%E5%8C%96-react-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81" target="_blank" rel="noreferrer">7、如何模块化 React 中的代码？</a> <a class="header-anchor" href="#_7、如何模块化-react-中的代码" aria-label="Permalink to &quot;[7、如何模块化 React 中的代码？](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新面试题2021年，常见面试题及答案汇总.md#7如何模块化-react-中的代码)&quot;">​</a></h3><p>可以使用 export 和 import 属性来模块化代码。它们有助于在不同的文件中单独编写组件。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">//ChildComponent.jsx</span></span>
<span class="line"><span style="color:#f6f6f4;">export default class ChildComponent extends React.Component {</span></span>
<span class="line"><span style="color:#f6f6f4;">    render() {</span></span>
<span class="line"><span style="color:#f6f6f4;">        return(</span></span>
<span class="line"><span style="color:#f6f6f4;">              &lt;div&gt;</span></span>
<span class="line"><span style="color:#f6f6f4;">                  &lt;h1&gt;This is a child component&lt;/h1&gt;</span></span>
<span class="line"><span style="color:#f6f6f4;">              &lt;/div&gt;</span></span>
<span class="line"><span style="color:#f6f6f4;">        );</span></span>
<span class="line"><span style="color:#f6f6f4;">    }</span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">//ParentComponent.jsx</span></span>
<span class="line"><span style="color:#f6f6f4;">import ChildComponent from &#39;./childcomponent.js&#39;;</span></span>
<span class="line"><span style="color:#f6f6f4;">class ParentComponent extends React.Component {</span></span>
<span class="line"><span style="color:#f6f6f4;">    render() {</span></span>
<span class="line"><span style="color:#f6f6f4;">        return(</span></span>
<span class="line"><span style="color:#f6f6f4;">             &lt;div&gt;</span></span>
<span class="line"><span style="color:#f6f6f4;">                &lt;App /&gt;</span></span>
<span class="line"><span style="color:#f6f6f4;">             &lt;/div&gt;</span></span>
<span class="line"><span style="color:#f6f6f4;">        );</span></span>
<span class="line"><span style="color:#f6f6f4;">    }</span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">//ChildComponent.jsx</span></span>
<span class="line"><span style="color:#24292e;">export default class ChildComponent extends React.Component {</span></span>
<span class="line"><span style="color:#24292e;">    render() {</span></span>
<span class="line"><span style="color:#24292e;">        return(</span></span>
<span class="line"><span style="color:#24292e;">              &lt;div&gt;</span></span>
<span class="line"><span style="color:#24292e;">                  &lt;h1&gt;This is a child component&lt;/h1&gt;</span></span>
<span class="line"><span style="color:#24292e;">              &lt;/div&gt;</span></span>
<span class="line"><span style="color:#24292e;">        );</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">}</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">//ParentComponent.jsx</span></span>
<span class="line"><span style="color:#24292e;">import ChildComponent from &#39;./childcomponent.js&#39;;</span></span>
<span class="line"><span style="color:#24292e;">class ParentComponent extends React.Component {</span></span>
<span class="line"><span style="color:#24292e;">    render() {</span></span>
<span class="line"><span style="color:#24292e;">        return(</span></span>
<span class="line"><span style="color:#24292e;">             &lt;div&gt;</span></span>
<span class="line"><span style="color:#24292e;">                &lt;App /&gt;</span></span>
<span class="line"><span style="color:#24292e;">             &lt;/div&gt;</span></span>
<span class="line"><span style="color:#24292e;">        );</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><h3 id="_8、redux中间件有哪些-做什么用" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#8redux%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E5%81%9A%E4%BB%80%E4%B9%88%E7%94%A8" target="_blank" rel="noreferrer">8、redux中间件有哪些，做什么用？</a> <a class="header-anchor" href="#_8、redux中间件有哪些-做什么用" aria-label="Permalink to &quot;[8、redux中间件有哪些，做什么用？](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新面试题2021年，常见面试题及答案汇总.md#8redux中间件有哪些做什么用)&quot;">​</a></h3><p>中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。变为 action -&gt; middlewares -&gt; reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能。 常见的中间件：</p><p>redux-logger：提供日志输出</p><p>redux-thunk：处理异步操作</p><p>redux-promise：处理异步操作，actionCreator的返回值是promise</p><h3 id="_9、那你知道vue3-x响应式数据原理吗" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#9%E9%82%A3%E4%BD%A0%E7%9F%A5%E9%81%93vue3x%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86%E5%90%97" target="_blank" rel="noreferrer">9、那你知道Vue3.x响应式数据原理吗？</a> <a class="header-anchor" href="#_9、那你知道vue3-x响应式数据原理吗" aria-label="Permalink to &quot;[9、那你知道Vue3.x响应式数据原理吗？](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新面试题2021年，常见面试题及答案汇总.md#9那你知道vue3x响应式数据原理吗)&quot;">​</a></h3><p>(还好我有看，这个难不倒我)</p><p>Vue3.x改用<code>Proxy</code>替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。</p><p><strong>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？</strong></p><p>判断当前Reflect.get的返回值是否为Object，如果是则再通过<code>reactive</code>方法做代理， 这样就实现了深度观测。</p><p><strong>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</strong></p><p>我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p><p>面试官抬起了头。心里暗想</p><p>(这小子还行，比上两个强，应该是多多少少看过Vue3的源码了)</p><h3 id="_10、你对-单一事实来源-有什么理解" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%982021%E5%B9%B4%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#10%E4%BD%A0%E5%AF%B9%E2%80%9C%E5%8D%95%E4%B8%80%E4%BA%8B%E5%AE%9E%E6%9D%A5%E6%BA%90%E6%9C%89%E4%BB%80%E4%B9%88%E7%90%86%E8%A7%A3" target="_blank" rel="noreferrer">10、你对“单一事实来源”有什么理解？</a> <a class="header-anchor" href="#_10、你对-单一事实来源-有什么理解" aria-label="Permalink to &quot;[10、你对“单一事实来源”有什么理解？](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新面试题2021年，常见面试题及答案汇总.md#10你对“单一事实来源有什么理解)&quot;">​</a></h3><p>Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。</p><h3 id="_11、redux的工作流程" tabindex="-1">11、redux的工作流程? <a class="header-anchor" href="#_11、redux的工作流程" aria-label="Permalink to &quot;11、redux的工作流程?&quot;">​</a></h3><h3 id="_12、区分有状态和无状态组件。" tabindex="-1">12、区分有状态和无状态组件。 <a class="header-anchor" href="#_12、区分有状态和无状态组件。" aria-label="Permalink to &quot;12、区分有状态和无状态组件。&quot;">​</a></h3><h3 id="_13、销毁阶段" tabindex="-1">13、销毁阶段 <a class="header-anchor" href="#_13、销毁阶段" aria-label="Permalink to &quot;13、销毁阶段&quot;">​</a></h3><h3 id="_14、react组件通信如何实现" tabindex="-1">14、React组件通信如何实现？ <a class="header-anchor" href="#_14、react组件通信如何实现" aria-label="Permalink to &quot;14、React组件通信如何实现？&quot;">​</a></h3><h3 id="_15、虚拟dom的优劣如何" tabindex="-1">15、虚拟DOM的优劣如何? <a class="header-anchor" href="#_15、虚拟dom的优劣如何" aria-label="Permalink to &quot;15、虚拟DOM的优劣如何?&quot;">​</a></h3><h3 id="_16、vue2-x组件通信有哪些方式" tabindex="-1">16、Vue2.x组件通信有哪些方式？ <a class="header-anchor" href="#_16、vue2-x组件通信有哪些方式" aria-label="Permalink to &quot;16、Vue2.x组件通信有哪些方式？&quot;">​</a></h3><h3 id="_17、如何将两个或多个组件嵌入到一个组件中" tabindex="-1">17、如何将两个或多个组件嵌入到一个组件中？ <a class="header-anchor" href="#_17、如何将两个或多个组件嵌入到一个组件中" aria-label="Permalink to &quot;17、如何将两个或多个组件嵌入到一个组件中？&quot;">​</a></h3><h3 id="_18、react性能优化方案" tabindex="-1">18、react性能优化方案 <a class="header-anchor" href="#_18、react性能优化方案" aria-label="Permalink to &quot;18、react性能优化方案&quot;">​</a></h3><h3 id="_19、什么是jsx" tabindex="-1">19、什么是JSX？ <a class="header-anchor" href="#_19、什么是jsx" aria-label="Permalink to &quot;19、什么是JSX？&quot;">​</a></h3><h3 id="_20、mvc框架的主要问题是什么" tabindex="-1">20、MVC框架的主要问题是什么？ <a class="header-anchor" href="#_20、mvc框架的主要问题是什么" aria-label="Permalink to &quot;20、MVC框架的主要问题是什么？&quot;">​</a></h3><h3 id="_21、react-router与常规路由有何不同" tabindex="-1">21、React Router与常规路由有何不同？ <a class="header-anchor" href="#_21、react-router与常规路由有何不同" aria-label="Permalink to &quot;21、React Router与常规路由有何不同？&quot;">​</a></h3><h3 id="_22、解释一下-flux" tabindex="-1">22、解释一下 Flux <a class="header-anchor" href="#_22、解释一下-flux" aria-label="Permalink to &quot;22、解释一下 Flux&quot;">​</a></h3><h3 id="_23、react-redux是如何工作的" tabindex="-1">23、react-redux是如何工作的? <a class="header-anchor" href="#_23、react-redux是如何工作的" aria-label="Permalink to &quot;23、react-redux是如何工作的?&quot;">​</a></h3><h3 id="_24、什么是高阶组件-hoc" tabindex="-1">24、什么是高阶组件(HOC) <a class="header-anchor" href="#_24、什么是高阶组件-hoc" aria-label="Permalink to &quot;24、什么是高阶组件(HOC)&quot;">​</a></h3><h3 id="_25、react有什么特点" tabindex="-1">25、React有什么特点？ <a class="header-anchor" href="#_25、react有什么特点" aria-label="Permalink to &quot;25、React有什么特点？&quot;">​</a></h3><h3 id="_26、说一下vue的生命周期" tabindex="-1">26、说一下Vue的生命周期 <a class="header-anchor" href="#_26、说一下vue的生命周期" aria-label="Permalink to &quot;26、说一下Vue的生命周期&quot;">​</a></h3><h3 id="_27、redux中如何进行异步操作" tabindex="-1">27、redux中如何进行异步操作? <a class="header-anchor" href="#_27、redux中如何进行异步操作" aria-label="Permalink to &quot;27、redux中如何进行异步操作?&quot;">​</a></h3>`,81),r=[o];function l(c,p,d,E,i,u){return a(),t("div",null,r)}const A=e(n,[["render",l]]);export{B as __pageData,A as default};
