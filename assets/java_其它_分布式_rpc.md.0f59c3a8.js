import{_ as e,o as a,c as o,V as r}from"./chunks/framework.c6d8cbec.js";const _=JSON.parse('{"title":"Dubbo","description":"","frontmatter":{},"headers":[],"relativePath":"java/其它/分布式/rpc.md","filePath":"java/其它/分布式/rpc.md"}'),t={name:"java/其它/分布式/rpc.md"},l=r('<h1 id="dubbo" tabindex="-1">Dubbo <a class="header-anchor" href="#dubbo" aria-label="Permalink to &quot;Dubbo&quot;">​</a></h1><h3 id="rpc" tabindex="-1">RPC <a class="header-anchor" href="#rpc" aria-label="Permalink to &quot;RPC&quot;">​</a></h3><p>RPC(Remote Procedure Call)：远程过程调用，即通过网络从远程计算机程序上请求服务，更多技术思想而非一种规范或协议。而不需要了解底层网络技术。</p><h3 id="什么是垂直架构" tabindex="-1">什么是垂直架构 <a class="header-anchor" href="#什么是垂直架构" aria-label="Permalink to &quot;什么是垂直架构&quot;">​</a></h3><p>所有功能模块在一个项目中编写，并集中部署。</p><p>缺点：项目耦合度高，不利于团队开发，也不利于后期升级和维护。</p><h3 id="什么是-soa-架构" tabindex="-1">什么是 SOA 架构 <a class="header-anchor" href="#什么是-soa-架构" aria-label="Permalink to &quot;什么是 SOA 架构&quot;">​</a></h3><p>SOA：面向服务架构，也叫分布式架构。</p><p>将产品 Controller 层和 Service 层分离，其中每个功能模块都作为一个项目开发并单独部署，之间互不依赖，模块与模块之间通过服务的形式传递数据。</p><p>用户在访问前台系统(Tomcat) 时，接受相应的 Controller 会向指定的服务器调用相应的 Service 执行。</p><h3 id="集群和负载均衡" tabindex="-1">集群和负载均衡 <a class="header-anchor" href="#集群和负载均衡" aria-label="Permalink to &quot;集群和负载均衡&quot;">​</a></h3><p>当大量用户同时访问同一个系统时，系统会因为访问量过大而宕机。因此高并发的项目中，往往有多个相同功能的 Controller (Tomcat)部署在不同的服务器同时工作，形成系统集群。</p><p>为防止某一个系统因访问量过大而宕机，需要把所有的请求尽可能均匀地分配给所有的系统。这叫做负载均衡。</p><h3 id="如何做负载均衡" tabindex="-1">如何做负载均衡 <a class="header-anchor" href="#如何做负载均衡" aria-label="Permalink to &quot;如何做负载均衡&quot;">​</a></h3><p>Nginx 服务器对高并发非常擅长，多用于负载均衡。用户请求会先把请求发给 Nginx 负载均衡器，再将请求分配给合适的系统。</p><p>当并发量更大的时候，还需要在硬件层对用户请求进行负载均衡，再把请求转发给合适的 Nginx 负载均衡器。这需要的昂贵的专业仪器，而不由软件工程师负责。</p><h3 id="什么是-dubbo" tabindex="-1">什么是 Dubbo <a class="header-anchor" href="#什么是-dubbo" aria-label="Permalink to &quot;什么是 Dubbo&quot;">​</a></h3><p>阿里巴巴开发的开源跨服务器调用服务，用于系统(controller)对服务(service)的远程调用。</p><p>Dubbo是基于RPC实现的：JDK底层的远程调用协议，由 Dubbo 实现。</p><p>【同类型的还有Spring Cloud。】</p><h3 id="dubbo-的具体实现" tabindex="-1">Dubbo 的具体实现 <a class="header-anchor" href="#dubbo-的具体实现" aria-label="Permalink to &quot;Dubbo 的具体实现&quot;">​</a></h3><ul><li>Controller层 使用 @reference 注解 (Dubbo包内！)</li><li>Service层 使用 @service 注解 (Dubbo包内！)</li></ul><p>注意 POJO 类的网络传输是序列化后完成的，所以实体类必须实现序列化。</p><h3 id="什么是-zookeeper" tabindex="-1">什么是 ZooKeeper <a class="header-anchor" href="#什么是-zookeeper" aria-label="Permalink to &quot;什么是 ZooKeeper&quot;">​</a></h3><p>Service 服务启动后，会向 ZooKeeper 注册自己的IP和端口号。</p><p>Controller 系统通过访问 ZooKeeper 注册中心查找请求的服务IP和端口号，然后通过 Dubbo 实现对服务中方法的调用。</p><h3 id="linux-下安装-zookeeper" tabindex="-1">Linux 下安装 ZooKeeper <a class="header-anchor" href="#linux-下安装-zookeeper" aria-label="Permalink to &quot;Linux 下安装 ZooKeeper&quot;">​</a></h3>',27),i=[l];function n(p,b,c,h,d,u){return a(),o("div",null,i)}const m=e(t,[["render",n]]);export{_ as __pageData,m as default};
