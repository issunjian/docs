import{_ as s,o as a,c as e,V as n}from"./chunks/framework.c6d8cbec.js";const l="/docs/assets/class-object-2f47490c-70b8-41b8-9551-42c2f98eea91.82feab20.png",j=JSON.parse('{"title":"Java 中，先有Class还是先有Object？","description":"Java程序员进阶之路，小白的零基础Java教程，从入门到进阶，Java 中，先有Class还是先有Object？","frontmatter":{"title":"Java 中，先有Class还是先有Object？","shortTitle":"先有Class还是先有Object？","category":["Java核心"],"tag":["Java重要知识点"],"description":"Java程序员进阶之路，小白的零基础Java教程，从入门到进阶，Java 中，先有Class还是先有Object？","head":[["meta",{"name":"keywords","content":"Java,Java SE,Java基础,Java教程,Java程序员进阶之路,Java进阶之路,Java入门,教程,java,class,object"}]]},"headers":[],"relativePath":"backend/tobetter/basic-extra-meal/class-object.md","filePath":"backend/tobetter/basic-extra-meal/class-object.md"}'),t={name:"backend/tobetter/basic-extra-meal/class-object.md"},o=n('<p>Java 对象模型中：</p><ul><li>所有的类都是Class类的实例，Object是类，那么Object也是Class类的一个实例。</li><li>所有的类都最终继承自Object类，Class是类，那么Class也继承自Object。</li></ul><p>那到底是先有Class还是先有Object？ JVM 是怎么处理这个“鸡·蛋”问题呢？</p><img src="'+l+`"><p>针对这个问题，我在知乎上看到了 R 大的一个回答，正好解答了我心中的疑惑，就分享出来给各位小伙伴一个参考和启发~</p><blockquote><p>作者：RednaxelaFX，整理：沉默王二，参考链接：<a href="https://www.zhihu.com/question/30301819/answer/47539163" target="_blank" rel="noreferrer">https://www.zhihu.com/question/30301819/answer/47539163</a></p></blockquote><hr><p>“鸡・蛋”问题通常都是通过一种叫“自举”（bootstrap）的过程来解决的。</p><p>“鸡蛋问题”的根本矛盾就在于假定了“鸡”或“蛋”的其中一个要先进入“完全可用”的状态。而许多现实中被简化为“鸡蛋问题”的情况实际可以在“混沌”中把“鸡”和“蛋”都初始化好，而不存在先后问题；在它们初始化的过程中，两者都不处于“完全可用”状态，而完成初始化后它们就同时都进入了可用状态。</p><p>打个比方，番茄炒蛋。并不是要先把番茄完全炒好，然后把鸡蛋完全炒好，然后把它们混起来；而是先炒番茄炒到半熟，再炒鸡蛋炒到半熟，然后把两个半熟的部分混在一起同时炒熟。</p><p>对于<strong>先有Class还是先有Object</strong>这个问题来说，题主假设所有的类都是Class类的实例，Object是类，那么Object也是Class类的一个实例，这个假设就是错的。</p><p><code>java.lang.Object</code>是一个Java类，但并不是<code>java.lang.Class</code>的一个实例。后者只是一个用于描述Java类与接口的、用于支持反射操作的类型。这点上Java跟其它一些更纯粹的面向对象语言（例如Python和Ruby）不同。</p><p>第二个假设“所有的类都最终继承自Object类，Class是类，那么Class也继承自Object”是对的，<code>java.lang.Class</code>是<code>java.lang.Object</code>的派生类，前者继承自后者。</p><p>虽然第1个假设不对，但“鸡蛋问题”仍然存在：在一个已经启动完毕、可以使用的Java对象系统里，必须要有一个<code>java.lang.Class</code>实例对应<code>java.lang.Object</code>这个类；而<code>java.lang.Class</code>是<code>java.lang.Object</code>的派生类，按“一般思维”，前者应该要在后者完成初始化之后才可以初始化…</p><p>事实是：这些相互依赖的核心类型完全可以在“混沌”中一口气都初始化好，然后对象系统的状态才叫做完成了“bootstrap”，后面就可以按照Java对象系统的一般规则去运行。JVM、JavaScript、Python、Ruby等的运行时都有这样的bootstrap过程。</p><p>在“混沌”（boostrap过程）里，JVM可以为对象系统中最重要的一些核心类型先分配好内存空间，让它们进入[已分配空间]但[尚未完全初始化]状态。</p><p>此时这些对象虽然已经分配了空间，但因为状态还不完整所以尚不可使用。然后，通过这些分配好的空间把这些核心类型之间的引用关系串好。</p><p>到此为止所有动作都由JVM完成，尚未执行任何Java字节码。然后这些核心类型就进入了[完全初始化]状态，对象系统就可以开始自我运行下去，也就是可以开始执行Java字节码来进一步完成Java系统的初始化了。</p><p>在HotSpot VM里，有一个叫做“Universe”的C++类用于记录对象系统的总体状态。它有这么两个有趣的字段记录当前是处于bootstrapping阶段还是已经完全初始化好：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">static bool is_bootstrapping()                      { return _bootstrapping; }</span></span>
<span class="line"><span style="color:#f6f6f4;">static bool is_fully_initialized()                  { return _fully_initialized; }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">static bool is_bootstrapping()                      { return _bootstrapping; }</span></span>
<span class="line"><span style="color:#24292e;">static bool is_fully_initialized()                  { return _fully_initialized; }</span></span></code></pre></div><p>然后<code>Universe::genesis()</code>函数会在bootstrap阶段中创建核心类型的对象模型，其中会调用<code>SystemDictionary::initialize()</code>来初始化对象系统的核心类型，其中会进一步跑到<code>SystemDictionary::initialize_preloaded_classes()</code>来创建<code>java.lang.Object</code>、<code>java.lang.Class</code>等核心类型。</p><p>这个函数在加载了<code>java.lang.Object</code>、<code>java.lang.Class</code>等核心类型后会调用<code>Universe::fixup_mirrors()</code>来完成前面说的“把引用关系串起来”的动作：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">// Fixup mirrors for classes loaded before java.lang.Class.</span></span>
<span class="line"><span style="color:#f6f6f4;">// These calls iterate over the objects currently in the perm gen</span></span>
<span class="line"><span style="color:#f6f6f4;">// so calling them at this point is matters (not before when there</span></span>
<span class="line"><span style="color:#f6f6f4;">// are fewer objects and not later after there are more objects</span></span>
<span class="line"><span style="color:#f6f6f4;">// in the perm gen.</span></span>
<span class="line"><span style="color:#f6f6f4;">Universe::initialize_basic_type_mirrors(CHECK);</span></span>
<span class="line"><span style="color:#f6f6f4;">Universe::fixup_mirrors(CHECK);</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">void Universe::fixup_mirrors(TRAPS) {</span></span>
<span class="line"><span style="color:#f6f6f4;">  // Bootstrap problem: all classes gets a mirror (java.lang.Class instance) assigned eagerly,</span></span>
<span class="line"><span style="color:#f6f6f4;">  // but we cannot do that for classes created before java.lang.Class is loaded. Here we simply</span></span>
<span class="line"><span style="color:#f6f6f4;">  // walk over permanent objects created so far (mostly classes) and fixup their mirrors. Note</span></span>
<span class="line"><span style="color:#f6f6f4;">  // that the number of objects allocated at this point is very small.</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">  // ...</span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">// Fixup mirrors for classes loaded before java.lang.Class.</span></span>
<span class="line"><span style="color:#24292e;">// These calls iterate over the objects currently in the perm gen</span></span>
<span class="line"><span style="color:#24292e;">// so calling them at this point is matters (not before when there</span></span>
<span class="line"><span style="color:#24292e;">// are fewer objects and not later after there are more objects</span></span>
<span class="line"><span style="color:#24292e;">// in the perm gen.</span></span>
<span class="line"><span style="color:#24292e;">Universe::initialize_basic_type_mirrors(CHECK);</span></span>
<span class="line"><span style="color:#24292e;">Universe::fixup_mirrors(CHECK);</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">void Universe::fixup_mirrors(TRAPS) {</span></span>
<span class="line"><span style="color:#24292e;">  // Bootstrap problem: all classes gets a mirror (java.lang.Class instance) assigned eagerly,</span></span>
<span class="line"><span style="color:#24292e;">  // but we cannot do that for classes created before java.lang.Class is loaded. Here we simply</span></span>
<span class="line"><span style="color:#24292e;">  // walk over permanent objects created so far (mostly classes) and fixup their mirrors. Note</span></span>
<span class="line"><span style="color:#24292e;">  // that the number of objects allocated at this point is very small.</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">  // ...</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>就是这样：“<strong>Object里有一个成员变量指向Class类实例c，c保存这个Object成员、方法的名字和地址的Map映射用作反射</strong>。”涉及到主类有这么几个：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/ade5be2b1758/src/share/vm/memory/universe.hpp#l399</span></span>
<span class="line"><span style="color:#f6f6f4;">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/ade5be2b1758/src/share/vm/memory/universe.cpp#l259</span></span>
<span class="line"><span style="color:#f6f6f4;">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/ade5be2b1758/src/share/vm/classfile/systemDictionary.cpp#l1814</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/ade5be2b1758/src/share/vm/memory/universe.hpp#l399</span></span>
<span class="line"><span style="color:#24292e;">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/ade5be2b1758/src/share/vm/memory/universe.cpp#l259</span></span>
<span class="line"><span style="color:#24292e;">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/ade5be2b1758/src/share/vm/classfile/systemDictionary.cpp#l1814</span></span></code></pre></div><p>分享的最后，二哥要简单说两句，每次看 R 大的内容，总是感觉膝盖忍不住要跪一下，只能说写过 JVM 的男人就是不一样。喜欢研究 CPP 源码的话小伙伴可以再深入学习下，一定会有所收获。</p><hr>`,27),p=[o];function c(r,i,d,f,b,v){return a(),e("div",null,p)}const y=s(t,[["render",c]]);export{j as __pageData,y as default};
