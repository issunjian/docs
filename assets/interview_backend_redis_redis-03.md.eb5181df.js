import{_ as e,o as s,c as a,V as i}from"./chunks/framework.c6d8cbec.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/redis/redis-03.md","filePath":"interview/backend/redis/redis-03.md"}'),r={name:"interview/backend/redis/redis-03.md"},d=i(`<h3 id="_1、一个redis实例最多能存放多少的keys-list、set、sorted-set他们最多能存放多少元素" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#1%E4%B8%80%E4%B8%AAredis%E5%AE%9E%E4%BE%8B%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E7%9A%84keyslistsetsorted-set%E4%BB%96%E4%BB%AC%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E5%85%83%E7%B4%A0" target="_blank" rel="noreferrer">1、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？</a> <a class="header-anchor" href="#_1、一个redis实例最多能存放多少的keys-list、set、sorted-set他们最多能存放多少元素" aria-label="Permalink to &quot;[1、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis最新2021年面试题附答案解析，大汇总.md#1一个redis实例最多能存放多少的keyslistsetsorted-set他们最多能存放多少元素)&quot;">​</a></h3><p>理论上Redis可以处理多达232的keys，并且在实际中进行了测试，每个实例至少存放了2亿5千万的keys。我们正在测试一些较大的值。任何list、set、和sorted set都可以放232个元素。换句话说，Redis的存储极限是系统中的可用内存值。</p><h3 id="_2、为什么要做redis分区" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9Aredis%E5%88%86%E5%8C%BA" target="_blank" rel="noreferrer">2、为什么要做Redis分区？</a> <a class="header-anchor" href="#_2、为什么要做redis分区" aria-label="Permalink to &quot;[2、为什么要做Redis分区？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis最新2021年面试题附答案解析，大汇总.md#2为什么要做redis分区)&quot;">​</a></h3><p>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p><h3 id="_3、定时删除" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#3%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4" target="_blank" rel="noreferrer">3、定时删除</a> <a class="header-anchor" href="#_3、定时删除" aria-label="Permalink to &quot;[3、定时删除](https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis最新2021年面试题附答案解析，大汇总.md#3定时删除)&quot;">​</a></h3><p>优点：对内存友好，定时删除策略可以保证过期键会尽可能快地被删除，并释放国期间所占用的内存</p><p>缺点：对cpu时间不友好，在过期键比较多时，删除任务会占用很大一部分cpu时间，在内存不紧张但cpu时间紧张的情况下，将cpu时间用在删除和当前任务无关的过期键上，影响服务器的响应时间和吞吐量</p><h3 id="_4、怎么理解redis事务" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#4%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3redis%E4%BA%8B%E5%8A%A1" target="_blank" rel="noreferrer">4、怎么理解Redis事务？</a> <a class="header-anchor" href="#_4、怎么理解redis事务" aria-label="Permalink to &quot;[4、怎么理解Redis事务？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis最新2021年面试题附答案解析，大汇总.md#4怎么理解redis事务)&quot;">​</a></h3><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><h3 id="_5、什么是redis" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#5%E4%BB%80%E4%B9%88%E6%98%AFredis" target="_blank" rel="noreferrer">5、什么是Redis？</a> <a class="header-anchor" href="#_5、什么是redis" aria-label="Permalink to &quot;[5、什么是Redis？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis最新2021年面试题附答案解析，大汇总.md#5什么是redis)&quot;">​</a></h3><p>Redis本质上是一个Key-Value类型的内存数据库，很像Memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。</p><p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 Memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的Memcached来用。</p><p>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h3 id="_6、redis分布式锁实现" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#6redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0" target="_blank" rel="noreferrer">6、Redis分布式锁实现</a> <a class="header-anchor" href="#_6、redis分布式锁实现" aria-label="Permalink to &quot;[6、Redis分布式锁实现](https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis最新2021年面试题附答案解析，大汇总.md#6redis分布式锁实现)&quot;">​</a></h3><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！</p><h3 id="_7、redis做异步队列" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#7redis%E5%81%9A%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97" target="_blank" rel="noreferrer">7、Redis做异步队列</a> <a class="header-anchor" href="#_7、redis做异步队列" aria-label="Permalink to &quot;[7、Redis做异步队列](https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis最新2021年面试题附答案解析，大汇总.md#7redis做异步队列)&quot;">​</a></h3><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</p><h3 id="_8、reids常用5种数据类型" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#8reids%E5%B8%B8%E7%94%A85%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noreferrer">8、Reids常用5种数据类型</a> <a class="header-anchor" href="#_8、reids常用5种数据类型" aria-label="Permalink to &quot;[8、Reids常用5种数据类型](https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis最新2021年面试题附答案解析，大汇总.md#8reids常用5种数据类型)&quot;">​</a></h3><p>string，list，set，sorted set，hash</p><h3 id="_9、redis-事务相关的命令有哪几个" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#9redis-%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA" target="_blank" rel="noreferrer">9、Redis 事务相关的命令有哪几个？</a> <a class="header-anchor" href="#_9、redis-事务相关的命令有哪几个" aria-label="Permalink to &quot;[9、Redis 事务相关的命令有哪几个？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis最新2021年面试题附答案解析，大汇总.md#9redis-事务相关的命令有哪几个)&quot;">​</a></h3><p>MULTI、EXEC、DISCARD、WATCH</p><h3 id="_10、watch命令和基于cas的乐观锁" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#10watch%E5%91%BD%E4%BB%A4%E5%92%8C%E5%9F%BA%E4%BA%8Ecas%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A" target="_blank" rel="noreferrer">10、WATCH命令和基于CAS的乐观锁：</a> <a class="header-anchor" href="#_10、watch命令和基于cas的乐观锁" aria-label="Permalink to &quot;[10、WATCH命令和基于CAS的乐观锁：](https://gitee.com/souyunku/DevBooks/blob/master/docs/Redis/Redis最新2021年面试题附答案解析，大汇总.md#10watch命令和基于cas的乐观锁：)&quot;">​</a></h3><p>在Redis的事务中，WATCH命令可用于提供CAS(check-and-set)功能。假设我们通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Null multi-bulk应答以通知调用者事务</p><p>执行失败。例如，我们再次假设Redis中并未提供incr命令来完成键值的原子性递增，如果要实现该功能，我们只能自行编写相应的代码。其伪码如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">val = GET mykey</span></span>
<span class="line"><span style="color:#f6f6f4;">val = val + 1</span></span>
<span class="line"><span style="color:#f6f6f4;">SET mykey $val</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">val = GET mykey</span></span>
<span class="line"><span style="color:#24292e;">val = val + 1</span></span>
<span class="line"><span style="color:#24292e;">SET mykey $val</span></span></code></pre></div><p>以上代码只有在单连接的情况下才可以保证执行结果是正确的，因为如果在同一时刻有多个客户端在同时执行该段代码，那么就会出现多线程程序中经常出现的一种错误场景--竞态争用(race condition)。</p><p>比如，客户端A和B都在同一时刻读取了mykey的原有值，假设该值为10，此后两个客户端又均将该值加一后set回Redis服务器，这样就会导致mykey的结果为11，而不是我们认为的12。为了解决类似的问题，我们需要借助WATCH命令的帮助，见如下代码：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">WATCH mykey</span></span>
<span class="line"><span style="color:#f6f6f4;">val = GET mykey</span></span>
<span class="line"><span style="color:#f6f6f4;">val = val + 1</span></span>
<span class="line"><span style="color:#f6f6f4;">MULTI</span></span>
<span class="line"><span style="color:#f6f6f4;">SET mykey $val</span></span>
<span class="line"><span style="color:#f6f6f4;">EXEC</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">WATCH mykey</span></span>
<span class="line"><span style="color:#24292e;">val = GET mykey</span></span>
<span class="line"><span style="color:#24292e;">val = val + 1</span></span>
<span class="line"><span style="color:#24292e;">MULTI</span></span>
<span class="line"><span style="color:#24292e;">SET mykey $val</span></span>
<span class="line"><span style="color:#24292e;">EXEC</span></span></code></pre></div><p>和此前代码不同的是，新代码在获取mykey的值之前先通过WATCH命令监控了该键，此后又将set命令包围在事务中，这样就可以有效的保证每个连接在执行EXEC之前，如果当前连接获取的mykey的值被其它连接的客户端修改，那么当前连接的EXEC命令将执行失败。这样调用者在判断返回值后就可以获悉val是否被重新设置成功。</p><h3 id="_11、怎么理解-redis-事务" tabindex="-1">11、怎么理解 Redis 事务？ <a class="header-anchor" href="#_11、怎么理解-redis-事务" aria-label="Permalink to &quot;11、怎么理解 Redis 事务？&quot;">​</a></h3><h3 id="_12、mysql-里有-2000w-数据-redis-中只存-20w-的数据-如何保证redis-中的数据都是热点数据" tabindex="-1">12、MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？ <a class="header-anchor" href="#_12、mysql-里有-2000w-数据-redis-中只存-20w-的数据-如何保证redis-中的数据都是热点数据" aria-label="Permalink to &quot;12、MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？&quot;">​</a></h3><h3 id="_13、redis的缓存失效策略和主键失效机制" tabindex="-1">13、Redis的缓存失效策略和主键失效机制 <a class="header-anchor" href="#_13、redis的缓存失效策略和主键失效机制" aria-label="Permalink to &quot;13、Redis的缓存失效策略和主键失效机制&quot;">​</a></h3><h3 id="_14、布隆过滤器" tabindex="-1">14、布隆过滤器 <a class="header-anchor" href="#_14、布隆过滤器" aria-label="Permalink to &quot;14、布隆过滤器&quot;">​</a></h3><h3 id="_15、判断key是否存在" tabindex="-1">15、判断key是否存在 <a class="header-anchor" href="#_15、判断key是否存在" aria-label="Permalink to &quot;15、判断key是否存在&quot;">​</a></h3><h3 id="_16、redis与其他key-value存储有什么不同" tabindex="-1">16、Redis与其他key-value存储有什么不同？ <a class="header-anchor" href="#_16、redis与其他key-value存储有什么不同" aria-label="Permalink to &quot;16、Redis与其他key-value存储有什么不同？&quot;">​</a></h3><h3 id="_17、redis回收进程如何工作的" tabindex="-1">17、Redis回收进程如何工作的？ <a class="header-anchor" href="#_17、redis回收进程如何工作的" aria-label="Permalink to &quot;17、Redis回收进程如何工作的？&quot;">​</a></h3><h3 id="_18、rdb和aof的优缺点" tabindex="-1">18、RDB和AOF的优缺点 <a class="header-anchor" href="#_18、rdb和aof的优缺点" aria-label="Permalink to &quot;18、RDB和AOF的优缺点&quot;">​</a></h3><h3 id="_19、redis是单进程单线程的" tabindex="-1">19、Redis是单进程单线程的 <a class="header-anchor" href="#_19、redis是单进程单线程的" aria-label="Permalink to &quot;19、Redis是单进程单线程的&quot;">​</a></h3><h3 id="_20、为什么需要持久化" tabindex="-1">20、为什么需要持久化？ <a class="header-anchor" href="#_20、为什么需要持久化" aria-label="Permalink to &quot;20、为什么需要持久化？&quot;">​</a></h3><h3 id="_21、redis-的数据类型" tabindex="-1">21、Redis 的数据类型？ <a class="header-anchor" href="#_21、redis-的数据类型" aria-label="Permalink to &quot;21、Redis 的数据类型？&quot;">​</a></h3><h3 id="_22、redis提供了哪几种持久化方式" tabindex="-1">22、Redis提供了哪几种持久化方式？ <a class="header-anchor" href="#_22、redis提供了哪几种持久化方式" aria-label="Permalink to &quot;22、Redis提供了哪几种持久化方式？&quot;">​</a></h3><h3 id="_23、redis内存模型" tabindex="-1">23、Redis内存模型 <a class="header-anchor" href="#_23、redis内存模型" aria-label="Permalink to &quot;23、Redis内存模型&quot;">​</a></h3><h3 id="_24、redis缓存被击穿处理机制" tabindex="-1">24、Redis缓存被击穿处理机制 <a class="header-anchor" href="#_24、redis缓存被击穿处理机制" aria-label="Permalink to &quot;24、Redis缓存被击穿处理机制&quot;">​</a></h3><h3 id="_25、redis的全称是什么" tabindex="-1">25、Redis的全称是什么？ <a class="header-anchor" href="#_25、redis的全称是什么" aria-label="Permalink to &quot;25、Redis的全称是什么？&quot;">​</a></h3><h3 id="_26、什么是redis" tabindex="-1">26、什么是Redis? <a class="header-anchor" href="#_26、什么是redis" aria-label="Permalink to &quot;26、什么是Redis?&quot;">​</a></h3><h3 id="_27、持久化策略选择" tabindex="-1">27、持久化策略选择 <a class="header-anchor" href="#_27、持久化策略选择" aria-label="Permalink to &quot;27、持久化策略选择&quot;">​</a></h3><h3 id="_28、redis中的管道有什么用" tabindex="-1">28、Redis中的管道有什么用？ <a class="header-anchor" href="#_28、redis中的管道有什么用" aria-label="Permalink to &quot;28、Redis中的管道有什么用？&quot;">​</a></h3><h3 id="_29、redis的内存占用情况怎么样" tabindex="-1">29、Redis的内存占用情况怎么样？ <a class="header-anchor" href="#_29、redis的内存占用情况怎么样" aria-label="Permalink to &quot;29、Redis的内存占用情况怎么样？&quot;">​</a></h3><h3 id="_30、手写一个-lru-算法" tabindex="-1">30、手写一个 LRU 算法 <a class="header-anchor" href="#_30、手写一个-lru-算法" aria-label="Permalink to &quot;30、手写一个 LRU 算法&quot;">​</a></h3>`,50),t=[d];function o(l,n,E,h,c,p){return s(),a("div",null,t)}const B=e(r,[["render",o]]);export{u as __pageData,B as default};
