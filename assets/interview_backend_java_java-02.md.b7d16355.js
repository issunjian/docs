import{_ as a,o as e,c as t,V as o}from"./chunks/framework.c6d8cbec.js";const B=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/java/java-02.md","filePath":"interview/backend/java/java-02.md"}'),s={name:"interview/backend/java/java-02.md"},r=o(`<h3 id="_1、什么是threadpoolexecutor" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#1%E4%BB%80%E4%B9%88%E6%98%AFthreadpoolexecutor" target="_blank" rel="noreferrer">1、什么是ThreadPoolExecutor？</a> <a class="header-anchor" href="#_1、什么是threadpoolexecutor" aria-label="Permalink to &quot;[1、什么是ThreadPoolExecutor？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题，2021年及答案汇总.md#1什么是threadpoolexecutor)&quot;">​</a></h3><p><strong>ThreadPoolExecutor就是线程池</strong></p><p>ThreadPoolExecutor其实也是JAVA的一个类，我们一般通过Executors工厂类的方法，通过传入不同的参数，就可以构造出适用于不同应用场景下的ThreadPoolExecutor（线程池）</p><p>构造参数图：</p><p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/045/42/87_6.png#alt=87%5C_6.png" alt=""><code>构造参数参数介绍：</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">corePoolSize 核心线程数量</span></span>
<span class="line"><span style="color:#f6f6f4;">maximumPoolSize 最大线程数量</span></span>
<span class="line"><span style="color:#f6f6f4;">keepAliveTime 线程保持时间，N个时间单位</span></span>
<span class="line"><span style="color:#f6f6f4;">unit 时间单位（比如秒，分）</span></span>
<span class="line"><span style="color:#f6f6f4;">workQueue 阻塞队列</span></span>
<span class="line"><span style="color:#f6f6f4;">threadFactory 线程工厂</span></span>
<span class="line"><span style="color:#f6f6f4;">handler 线程池拒绝策略</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">corePoolSize 核心线程数量</span></span>
<span class="line"><span style="color:#24292e;">maximumPoolSize 最大线程数量</span></span>
<span class="line"><span style="color:#24292e;">keepAliveTime 线程保持时间，N个时间单位</span></span>
<span class="line"><span style="color:#24292e;">unit 时间单位（比如秒，分）</span></span>
<span class="line"><span style="color:#24292e;">workQueue 阻塞队列</span></span>
<span class="line"><span style="color:#24292e;">threadFactory 线程工厂</span></span>
<span class="line"><span style="color:#24292e;">handler 线程池拒绝策略</span></span></code></pre></div><h3 id="_2、invokedynamic-指令是干什么的" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#2invokedynamic-%E6%8C%87%E4%BB%A4%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84" target="_blank" rel="noreferrer">2、invokedynamic 指令是干什么的？</a> <a class="header-anchor" href="#_2、invokedynamic-指令是干什么的" aria-label="Permalink to &quot;[2、invokedynamic 指令是干什么的？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题，2021年及答案汇总.md#2invokedynamic-指令是干什么的)&quot;">​</a></h3><p>Java 7 开始，新引入的字节码指令，可以实现一些动态类型语言的功能。Java 8 的 Lambda 表达式就是通过 invokedynamic 指令实现，使用方法句柄实现。</p><h3 id="_3、synchronized、volatile、cas-比较" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#3synchronizedvolatilecas-%E6%AF%94%E8%BE%83" target="_blank" rel="noreferrer">3、synchronized、volatile、CAS 比较</a> <a class="header-anchor" href="#_3、synchronized、volatile、cas-比较" aria-label="Permalink to &quot;[3、synchronized、volatile、CAS 比较](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题，2021年及答案汇总.md#3synchronizedvolatilecas-比较)&quot;">​</a></h3><p><strong>1、</strong> synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。</p><p><strong>2、</strong> volatile 提供多线程共享变量可见性和禁止指令重排序优化。</p><p><strong>3、</strong> CAS 是基于冲突检测的乐观锁（非阻塞）</p><h3 id="_4、iterator-怎么使用-有什么特点" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#4iterator-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9" target="_blank" rel="noreferrer">4、Iterator 怎么使用？有什么特点？</a> <a class="header-anchor" href="#_4、iterator-怎么使用-有什么特点" aria-label="Permalink to &quot;[4、Iterator 怎么使用？有什么特点？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题，2021年及答案汇总.md#4iterator-怎么使用有什么特点)&quot;">​</a></h3><p>Iterator 使用代码如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#f6f6f4;">Iterator&lt;String&gt; it = list、iterator();</span></span>
<span class="line"><span style="color:#f6f6f4;">while(it、hasNext()){</span></span>
<span class="line"><span style="color:#f6f6f4;">  String obj = it、next();</span></span>
<span class="line"><span style="color:#f6f6f4;">  System、out、println(obj);</span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292e;">Iterator&lt;String&gt; it = list、iterator();</span></span>
<span class="line"><span style="color:#24292e;">while(it、hasNext()){</span></span>
<span class="line"><span style="color:#24292e;">  String obj = it、next();</span></span>
<span class="line"><span style="color:#24292e;">  System、out、println(obj);</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h3 id="_5、被引用的对象就一定能存活吗" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#5%E8%A2%AB%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%83%BD%E5%AD%98%E6%B4%BB%E5%90%97" target="_blank" rel="noreferrer">5、被引用的对象就一定能存活吗？</a> <a class="header-anchor" href="#_5、被引用的对象就一定能存活吗" aria-label="Permalink to &quot;[5、被引用的对象就一定能存活吗？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题，2021年及答案汇总.md#5被引用的对象就一定能存活吗)&quot;">​</a></h3><p>不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收。</p><h3 id="_6、列出一些你常见的运行时异常" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#6%E5%88%97%E5%87%BA%E4%B8%80%E4%BA%9B%E4%BD%A0%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8" target="_blank" rel="noreferrer">6、列出一些你常见的运行时异常？</a> <a class="header-anchor" href="#_6、列出一些你常见的运行时异常" aria-label="Permalink to &quot;[6、列出一些你常见的运行时异常？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题，2021年及答案汇总.md#6列出一些你常见的运行时异常)&quot;">​</a></h3><p><strong>1、</strong> ArithmeticException（算术异常）</p><p><strong>2、</strong> ClassCastException （类转换异常）</p><p><strong>3、</strong> IllegalArgumentException （非法参数异常）</p><p><strong>4、</strong> IndexOutOfBoundsException （下标越界异常）</p><p><strong>5、</strong> NullPointerException （空指针异常）</p><p><strong>6、</strong> SecurityException （安全异常）</p><h3 id="_7、servlet生命周期内调用的方法过程" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#7servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%86%85%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%87%E7%A8%8B" target="_blank" rel="noreferrer">7、Servlet生命周期内调用的方法过程？</a> <a class="header-anchor" href="#_7、servlet生命周期内调用的方法过程" aria-label="Permalink to &quot;[7、Servlet生命周期内调用的方法过程？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题，2021年及答案汇总.md#7servlet生命周期内调用的方法过程)&quot;">​</a></h3><p><strong>1、</strong> Init()</p><p><strong>2、</strong> Service()</p><p><strong>3、</strong> doGet或者doPost</p><p><strong>4、</strong> destroy</p><h3 id="_8、阐述静态变量和实例变量的区别。" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#8%E9%98%90%E8%BF%B0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82" target="_blank" rel="noreferrer">8、阐述静态变量和实例变量的区别。</a> <a class="header-anchor" href="#_8、阐述静态变量和实例变量的区别。" aria-label="Permalink to &quot;[8、阐述静态变量和实例变量的区别。](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题，2021年及答案汇总.md#8阐述静态变量和实例变量的区别。)&quot;">​</a></h3><p>静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p><blockquote><p>补充：在Java开发中，上下文类和工具类中通常会有大量的静态成员。</p></blockquote><h3 id="_9、类加载器双亲委派模型机制" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#9%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%9C%BA%E5%88%B6" target="_blank" rel="noreferrer">9、类加载器双亲委派模型机制？</a> <a class="header-anchor" href="#_9、类加载器双亲委派模型机制" aria-label="Permalink to &quot;[9、类加载器双亲委派模型机制？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题，2021年及答案汇总.md#9类加载器双亲委派模型机制)&quot;">​</a></h3><p><strong>基本定义：</strong></p><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器没有找到所需的类时，子加载器才会尝试去加载该类。</p><p><strong>双亲委派机制:</strong></p><p><strong>1、</strong> 当 AppClassLoader 加载一个 class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。</p><p><strong>2、</strong> 当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。</p><p><strong>3、</strong> 如果 BootStrapClassLoader 加载失败，会使用 ExtClassLoader 来尝试加载；</p><p><strong>4、</strong> 若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常 ClassNotFoundException。</p><p><strong>如下图所示：</strong></p><p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/05/34/39_4.png#alt=39%5C_4.png" alt=""></p><p><strong>双亲委派作用：</strong></p><p><strong>1、</strong> 通过带有优先级的层级关可以避免类的重复加载；</p><p><strong>2、</strong> 保证 Java 程序安全稳定运行，Java 核心 API 定义类型不会被随意替换。</p><h3 id="_10、抽象的-abstract-方法是否可同时是静态的-static-是否可同时是本地方法-native-是否可同时被synchronized修饰" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#10%E6%8A%BD%E8%B1%A1%E7%9A%84abstract%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84static,%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AF%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95native%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E8%A2%ABsynchronized%E4%BF%AE%E9%A5%B0" target="_blank" rel="noreferrer">10、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？</a> <a class="header-anchor" href="#_10、抽象的-abstract-方法是否可同时是静态的-static-是否可同时是本地方法-native-是否可同时被synchronized修饰" aria-label="Permalink to &quot;[10、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题，2021年及答案汇总.md#10抽象的abstract方法是否可同时是静态的static,是否可同时是本地方法native是否可同时被synchronized修饰)&quot;">​</a></h3><p>都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p><h3 id="_11、老年代" tabindex="-1">11、老年代 <a class="header-anchor" href="#_11、老年代" aria-label="Permalink to &quot;11、老年代&quot;">​</a></h3><h3 id="_12、如何停止一个正在运行的线程" tabindex="-1">12、如何停止一个正在运行的线程？ <a class="header-anchor" href="#_12、如何停止一个正在运行的线程" aria-label="Permalink to &quot;12、如何停止一个正在运行的线程？&quot;">​</a></h3><h3 id="_13、常用jvm基本配置参数" tabindex="-1">13、常用JVM基本配置参数 <a class="header-anchor" href="#_13、常用jvm基本配置参数" aria-label="Permalink to &quot;13、常用JVM基本配置参数&quot;">​</a></h3><h3 id="_14、线程池都有哪些状态" tabindex="-1">14、线程池都有哪些状态？ <a class="header-anchor" href="#_14、线程池都有哪些状态" aria-label="Permalink to &quot;14、线程池都有哪些状态？&quot;">​</a></h3><h3 id="_15、怎么确保一个集合不能被修改" tabindex="-1">15、怎么确保一个集合不能被修改？ <a class="header-anchor" href="#_15、怎么确保一个集合不能被修改" aria-label="Permalink to &quot;15、怎么确保一个集合不能被修改？&quot;">​</a></h3><h3 id="_16、怎么检测一个线程是否拥有锁" tabindex="-1">16、怎么检测一个线程是否拥有锁？ <a class="header-anchor" href="#_16、怎么检测一个线程是否拥有锁" aria-label="Permalink to &quot;16、怎么检测一个线程是否拥有锁？&quot;">​</a></h3><h3 id="_17、启动一个线程是调用run-还是start-方法" tabindex="-1">17、启动一个线程是调用run()还是start()方法？ <a class="header-anchor" href="#_17、启动一个线程是调用run-还是start-方法" aria-label="Permalink to &quot;17、启动一个线程是调用run()还是start()方法？&quot;">​</a></h3><h3 id="_18、react组件通信如何实现" tabindex="-1">18、React组件通信如何实现? <a class="header-anchor" href="#_18、react组件通信如何实现" aria-label="Permalink to &quot;18、React组件通信如何实现?&quot;">​</a></h3><h3 id="_19、java-中-weakreference-与-softreference的区别" tabindex="-1">19、Java 中 WeakReference 与 SoftReference的区别？ <a class="header-anchor" href="#_19、java-中-weakreference-与-softreference的区别" aria-label="Permalink to &quot;19、Java 中 WeakReference 与 SoftReference的区别？&quot;">​</a></h3><h3 id="_20、常用并发列队的介绍" tabindex="-1">20、常用并发列队的介绍： <a class="header-anchor" href="#_20、常用并发列队的介绍" aria-label="Permalink to &quot;20、常用并发列队的介绍：&quot;">​</a></h3><h3 id="_21、什么是数据结构" tabindex="-1">21、什么是数据结构？ <a class="header-anchor" href="#_21、什么是数据结构" aria-label="Permalink to &quot;21、什么是数据结构？&quot;">​</a></h3><h3 id="_22、遇到过堆外内存溢出吗" tabindex="-1">22、遇到过堆外内存溢出吗？ <a class="header-anchor" href="#_22、遇到过堆外内存溢出吗" aria-label="Permalink to &quot;22、遇到过堆外内存溢出吗？&quot;">​</a></h3><h3 id="_23、会话跟踪技术有那些" tabindex="-1">23、会话跟踪技术有那些？ <a class="header-anchor" href="#_23、会话跟踪技术有那些" aria-label="Permalink to &quot;23、会话跟踪技术有那些？&quot;">​</a></h3><h3 id="_24、抽象类和接口的区别" tabindex="-1">24、抽象类和接口的区别? <a class="header-anchor" href="#_24、抽象类和接口的区别" aria-label="Permalink to &quot;24、抽象类和接口的区别?&quot;">​</a></h3><h3 id="_25、java中用到的线程调度算法是什么" tabindex="-1">25、Java中用到的线程调度算法是什么？ <a class="header-anchor" href="#_25、java中用到的线程调度算法是什么" aria-label="Permalink to &quot;25、Java中用到的线程调度算法是什么？&quot;">​</a></h3><h3 id="_26、如何使session失效" tabindex="-1">26、如何使session失效 <a class="header-anchor" href="#_26、如何使session失效" aria-label="Permalink to &quot;26、如何使session失效&quot;">​</a></h3><h3 id="_27、存储过程与函数的区别" tabindex="-1">27、存储过程与函数的区别 <a class="header-anchor" href="#_27、存储过程与函数的区别" aria-label="Permalink to &quot;27、存储过程与函数的区别&quot;">​</a></h3><h3 id="_28、spring支持的事务管理类型有哪些-你在项目中使用哪种方式" tabindex="-1">28、Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？ <a class="header-anchor" href="#_28、spring支持的事务管理类型有哪些-你在项目中使用哪种方式" aria-label="Permalink to &quot;28、Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？&quot;">​</a></h3><h3 id="_29、用java写一个折半查找。" tabindex="-1">29、用Java写一个折半查找。 <a class="header-anchor" href="#_29、用java写一个折半查找。" aria-label="Permalink to &quot;29、用Java写一个折半查找。&quot;">​</a></h3><h3 id="_30、对象都是优先分配在年轻代上的吗" tabindex="-1">30、对象都是优先分配在年轻代上的吗？ <a class="header-anchor" href="#_30、对象都是优先分配在年轻代上的吗" aria-label="Permalink to &quot;30、对象都是优先分配在年轻代上的吗？&quot;">​</a></h3><h3 id="_31、本地方法区-线程私有" tabindex="-1">31、本地方法区(线程私有) <a class="header-anchor" href="#_31、本地方法区-线程私有" aria-label="Permalink to &quot;31、本地方法区(线程私有)&quot;">​</a></h3><h3 id="_32、单例模式了解吗-给我解释一下双重检验锁方式实现单例模式" tabindex="-1">32、单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！” <a class="header-anchor" href="#_32、单例模式了解吗-给我解释一下双重检验锁方式实现单例模式" aria-label="Permalink to &quot;32、单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！”&quot;">​</a></h3><h3 id="_33、jvm-有哪些运行时内存区域" tabindex="-1">33、JVM 有哪些运行时内存区域？ <a class="header-anchor" href="#_33、jvm-有哪些运行时内存区域" aria-label="Permalink to &quot;33、JVM 有哪些运行时内存区域？&quot;">​</a></h3><h3 id="_34、为什么thread类的sleep-和yield-方法是静态的" tabindex="-1">34、为什么Thread类的sleep()和yield ()方法是静态的？ <a class="header-anchor" href="#_34、为什么thread类的sleep-和yield-方法是静态的" aria-label="Permalink to &quot;34、为什么Thread类的sleep()和yield ()方法是静态的？&quot;">​</a></h3><h3 id="_35、如何用java代码列出一个目录下所有的文件" tabindex="-1">35、如何用Java代码列出一个目录下所有的文件？ <a class="header-anchor" href="#_35、如何用java代码列出一个目录下所有的文件" aria-label="Permalink to &quot;35、如何用Java代码列出一个目录下所有的文件？&quot;">​</a></h3><h3 id="_36、java中notify-和-notifyall有什么区别" tabindex="-1">36、Java中notify 和 notifyAll有什么区别？ <a class="header-anchor" href="#_36、java中notify-和-notifyall有什么区别" aria-label="Permalink to &quot;36、Java中notify 和 notifyAll有什么区别？&quot;">​</a></h3><h3 id="_37、为什么使用executor框架" tabindex="-1">37、为什么使用Executor框架？ <a class="header-anchor" href="#_37、为什么使用executor框架" aria-label="Permalink to &quot;37、为什么使用Executor框架？&quot;">​</a></h3><h3 id="_38、如何判断两个类是否相等" tabindex="-1">38、如何判断两个类是否相等？ <a class="header-anchor" href="#_38、如何判断两个类是否相等" aria-label="Permalink to &quot;38、如何判断两个类是否相等？&quot;">​</a></h3><h3 id="_39、虚拟dom实现原理" tabindex="-1">39、虚拟DOM实现原理? <a class="header-anchor" href="#_39、虚拟dom实现原理" aria-label="Permalink to &quot;39、虚拟DOM实现原理?&quot;">​</a></h3><h3 id="_40、a-a-b-与-a-b-的区别" tabindex="-1">40、a = a + b 与 a += b 的区别 <a class="header-anchor" href="#_40、a-a-b-与-a-b-的区别" aria-label="Permalink to &quot;40、a = a + b 与 a += b 的区别&quot;">​</a></h3>`,78),n=[r];function l(i,c,h,p,E,d){return e(),t("div",null,n)}const b=a(s,[["render",l]]);export{B as __pageData,b as default};
