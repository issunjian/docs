import{_ as e,o as t,c as a,V as r}from"./chunks/framework.c6d8cbec.js";const f=JSON.parse('{"title":"类型系统","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/ts/ch3.md","filePath":"frontend/ts/ch3.md"}'),o={name:"frontend/ts/ch3.md"},n=r('<h1 id="类型系统" tabindex="-1">类型系统 <a class="header-anchor" href="#类型系统" aria-label="Permalink to &quot;类型系统&quot;">​</a></h1><h2 id="函数类型" tabindex="-1">函数类型 <a class="header-anchor" href="#函数类型" aria-label="Permalink to &quot;函数类型&quot;">​</a></h2><p>如何对两个函数类型进行兼容性比较？</p><p>即比较它们的参数类型是否是反向的父子类型关系，返回值是否是正向的父子类型关系。</p><blockquote><p>也就是判断参数类型是否遵循类型逆变，返回值类型是否遵循类型协变。</p></blockquote><p>我们可以通过 TypeScript ESLint 的规则以及 <code>strictFunctionTypes</code> 配置，来为 interface 内的函数声明启用严格的检查模式。</p><p>如果项目内配置了 TypeScript ESLint，可以加上 <a href="https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/method-signature-style.md" target="_blank" rel="noreferrer">method-signature-style</a> 这条规则提升代码质量。</p>',7),s=[n];function c(i,p,l,d,_,h){return t(),a("div",null,s)}const m=e(o,[["render",c]]);export{f as __pageData,m as default};
