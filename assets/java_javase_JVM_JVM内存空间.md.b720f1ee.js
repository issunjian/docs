import{_ as s,o as a,c as n,V as o}from"./chunks/framework.c6d8cbec.js";const l="/docs/assets/内存.775580c5.png",g=JSON.parse('{"title":"JVM","description":"","frontmatter":{},"headers":[],"relativePath":"java/javase/JVM/JVM内存空间.md","filePath":"java/javase/JVM/JVM内存空间.md"}'),p={name:"java/javase/JVM/JVM内存空间.md"},t=o('<h1 id="jvm" tabindex="-1">JVM <a class="header-anchor" href="#jvm" aria-label="Permalink to &quot;JVM&quot;">​</a></h1><p>Java 程序中的内存分配和回收都由 JVM 管理，不支持程序员直接对内存地址进行操作。不容易出现内存泄漏和内存溢出问题。</p><hr><h2 id="内存空间" tabindex="-1">内存空间 <a class="header-anchor" href="#内存空间" aria-label="Permalink to &quot;内存空间&quot;">​</a></h2><p>进程是分配资源的基本单位。除方法区外，所有数据均存放在给进程分配的内存块中。</p><p>Java 程序的内存空间主要分为以下几个区域：</p><p><img src="'+l+`" alt=""></p><h3 id="方法区" tabindex="-1">方法区 <a class="header-anchor" href="#方法区" aria-label="Permalink to &quot;方法区&quot;">​</a></h3><p>(Method Area) 存放 <strong>Java 程序的二进制代码，即类的信息</strong>。</p><p>在虚拟机启动时直接存入系统内存中，大小只受系统内存的限制。</p><h3 id="堆区" tabindex="-1">堆区 <a class="header-anchor" href="#堆区" aria-label="Permalink to &quot;堆区&quot;">​</a></h3><p>(Heap) 存放进程创建的<strong>对象实例和数组</strong>。</p><p>由线程共享，在虚拟机启动时为进程创建，是占用内存最大的区域。</p><h4 id="常量池" tabindex="-1">常量池 <a class="header-anchor" href="#常量池" aria-label="Permalink to &quot;常量池&quot;">​</a></h4><p>存放 <strong>final 常量、static 变量和方法，以及 String 和部分包装类型的对象（一经赋值不再改变）</strong>。</p><blockquote><p>JDK 1.7 后 JVM 将常量池从方法区中移出，改为在堆中开辟空间存放。</p></blockquote><h3 id="栈区" tabindex="-1">栈区 <a class="header-anchor" href="#栈区" aria-label="Permalink to &quot;栈区&quot;">​</a></h3><p>(Stack) 存放线程执行 Java 方法调用的内存数据。线程每执行一个方法都会创建一个栈帧放入栈区，在方法执行结束后弹出。栈帧中储存局部变量表、操作数栈、动态链接、方法出口信息。其中局部变量表存放<strong>线程和方法的参数、方法中定义的基础类型变量和对象引用</strong>。</p><p>由线程私有。生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><p><em>栈区分为虚拟机栈（执行 java 方法）和本地方法栈（执行 native 方法，底层用 C 实现），但在 HotSpot 虚拟机中两者合二为一。</em></p><h3 id="程序计数器" tabindex="-1">程序计数器 <a class="header-anchor" href="#程序计数器" aria-label="Permalink to &quot;程序计数器&quot;">​</a></h3><p>用来记录线程的运行状态、管理线程的运行。</p><ol><li><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p></li><li><p>在多线程的情况下程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够继续运行。</p></li></ol><p>由线程私有。生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><hr><h2 id="对象的内存分配" tabindex="-1">对象的内存分配 <a class="header-anchor" href="#对象的内存分配" aria-label="Permalink to &quot;对象的内存分配&quot;">​</a></h2><h3 id="分配空间" tabindex="-1">分配空间 <a class="header-anchor" href="#分配空间" aria-label="Permalink to &quot;分配空间&quot;">​</a></h3><p>Hotspot 虚拟机中，对象在内存中分为 3 块区域：对象头、实例数据和对齐填充。</p><ul><li>对象头负责记录对象信息，包括对象运行数据（哈希码、GC 分代年龄、锁状态标志等）和 类型指针（对象所属的类）。</li><li>对象起止地址必须是 8 字节整数倍，空余部分将使用对齐填充来补全。</li></ul><h3 id="分配过程" tabindex="-1">分配过程 <a class="header-anchor" href="#分配过程" aria-label="Permalink to &quot;分配过程&quot;">​</a></h3><p>在 Java 中创建对象，需要经过以下过程：</p><p><strong>Step 1. 类加载检查</strong></p><pre><code>JVM 接收到 new 指令，首先检查该类是否在常量池中，然后检查该类是否已被加载、解析和初始化。

如果没有则先加载类，类加载器会将类的字节码文件放入 JVM 解析。
</code></pre><p><strong>Step 2. 分配内存</strong></p><pre><code>类加载后，会从 Java 堆中划分一块固定大小的内存区域分配给对象。
</code></pre><p><strong>Step 3. 半初始化</strong></p><pre><code>内存分配完成后，虚拟机将对象的实例数据都半初始化为默认值。此时对象已经可用。
</code></pre><p><strong>Step 4. 设置对象头</strong></p><pre><code>初始化内存空间后，虚拟机要对对象进行必要的设置，把信息存放在对象头中。
</code></pre><p><strong>Step 5.初始化对象</strong></p><pre><code>新的对象已经产生，但所有的字段都为默认值。接下执行 init 方法，将对象的实例数据赋值。
</code></pre><p><strong>Step 6. 建立关联</strong></p><pre><code>将对象引用指向创建的对象。该对象可以通过引用被使用。
</code></pre><p><em>在创建对象的过程中可能会发生指令重排序。如果尚未完全初始化就建立了关联，其他线程读取该对象可能会读取到默认值。</em></p><h3 id="分配方式" tabindex="-1">分配方式 <a class="header-anchor" href="#分配方式" aria-label="Permalink to &quot;分配方式&quot;">​</a></h3><p>内存划分有以下两种分配方式：</p><ul><li>指针碰撞：（内存规整时） 已使用内存和未使用内存用指针隔开，需要分配内存时将指针移动一定位置。</li><li>空闲列表：（内存不规整时）虚拟机维护一个列表记录空闲内存块，需要分配内存时选择合适的内存块。</li></ul><p>Java 堆是否规整，取决于垃圾收集算法是否整理内存。</p><hr><h2 id="常量池内存分配" tabindex="-1">常量池内存分配 <a class="header-anchor" href="#常量池内存分配" aria-label="Permalink to &quot;常量池内存分配&quot;">​</a></h2><h3 id="string-类" tabindex="-1">String 类 <a class="header-anchor" href="#string-类" aria-label="Permalink to &quot;String 类&quot;">​</a></h3><p>String 对象创建后一经赋值不再改变，有以下两种创建方式：</p><ol><li><p>直接赋值：如果常量池没有，则在常量池新建对象。否则直接使用常量池中已有对象，<strong>引用指向常量池。</strong></p></li><li><p>构造方法：如果常量池没有，则在常量池新建对象。无论如何一定会在堆区创建对象，<strong>引用指向堆区。</strong></p></li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">String</span><span style="color:#F6F6F4;"> str1 </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">string</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">;                       </span><span style="color:#7B7F8B;">// 引用指向常量池</span></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">String</span><span style="color:#F6F6F4;"> str2 </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">str</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">+</span><span style="color:#F6F6F4;"> </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">ing</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">;                  </span><span style="color:#7B7F8B;">// 引用指向常量池</span></span>
<span class="line"></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">String</span><span style="color:#F6F6F4;"> str3 </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">String</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">string</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);           </span><span style="color:#7B7F8B;">// 引用指向堆区</span></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">String</span><span style="color:#F6F6F4;"> str4 </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> str1 </span><span style="color:#F286C4;">+</span><span style="color:#F6F6F4;"> str2;                    </span><span style="color:#7B7F8B;">// 引用指向堆区</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(str1 </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> str2);             </span><span style="color:#7B7F8B;">// true</span></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(str1 </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> str3);             </span><span style="color:#7B7F8B;">// false</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">String str1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;string&quot;</span><span style="color:#24292E;">;                       </span><span style="color:#6A737D;">// 引用指向常量池</span></span>
<span class="line"><span style="color:#24292E;">String str2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;str&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;ing&quot;</span><span style="color:#24292E;">;                  </span><span style="color:#6A737D;">// 引用指向常量池</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">String str3 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;string&quot;</span><span style="color:#24292E;">);           </span><span style="color:#6A737D;">// 引用指向堆区</span></span>
<span class="line"><span style="color:#24292E;">String str4 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> str1 </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> str2;                    </span><span style="color:#6A737D;">// 引用指向堆区</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(str1 </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> str2);             </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(str1 </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> str3);             </span><span style="color:#6A737D;">// false</span></span></code></pre></div><h3 id="包装类型" tabindex="-1">包装类型 <a class="header-anchor" href="#包装类型" aria-label="Permalink to &quot;包装类型&quot;">​</a></h3><p>JVM 将部分常用的包装类型数据提前缓存在常量池中，用户创建该类对象时直接在常量池取用，而不用真正新建对象。</p><ul><li><p><strong>布尔包装类 Boolean</strong>：将全部缓存数据保存在常量池中。</p></li><li><p><strong>字符包装类 Character</strong>：将 ASCII 字符(0-127) 数据缓存保存在常量池中。如果是汉字等其他字符仍然会创建对象。</p></li><li><p><strong>整型包装类 Byte/Short/Integer/Long</strong>：将数值 [-128，127] 内的数据缓存保存在常量池中。但是超出此范围仍然会去创建新的对象。</p></li><li><p><strong>浮点数类型包装类 Float/Double</strong>： 没有实现常量池技术。</p></li></ul><hr><h2 id="内存过载" tabindex="-1">内存过载 <a class="header-anchor" href="#内存过载" aria-label="Permalink to &quot;内存过载&quot;">​</a></h2><p>随着 Java 程序的使用，所占用和分配的内存将会越来越大。如果 JVM 已无法分配足够的内存，将会抛出 OutOfMemoryError 导致程序崩溃。</p><p>同时为了更合理地使用内存，Java 会由虚拟机对堆区内存空间自动进行垃圾回收。</p>`,61),e=[t];function r(c,i,y,h,F,d){return a(),n("div",null,e)}const E=s(p,[["render",r]]);export{g as __pageData,E as default};
