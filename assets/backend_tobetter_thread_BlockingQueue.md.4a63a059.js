import{_ as s,o as n,c as a,V as l}from"./chunks/framework.c6d8cbec.js";const p="/docs/assets/BlockingQueue-01.00d827c7.png",o="/docs/assets/BlockingQueue-02.e6659bf8.png",e="/docs/assets/BlockingQueue-03.da86d0b2.png",h=JSON.parse('{"title":"吊打Java并发面试官之BlockingQueue","description":"吊打Java并发面试官之BlockingQueue","frontmatter":{"title":"吊打Java并发面试官之BlockingQueue","shortTitle":"BlockingQueue","description":"吊打Java并发面试官之BlockingQueue","category":["Java核心"],"tag":["Java并发编程"],"head":[["meta",{"name":"keywords","content":"Java,并发编程,多线程,Thread,BlockingQueue"}]]},"headers":[],"relativePath":"backend/tobetter/thread/BlockingQueue.md","filePath":"backend/tobetter/thread/BlockingQueue.md"}'),t={name:"backend/tobetter/thread/BlockingQueue.md"},c=l('<p>最常用的&quot;<strong>生产者-消费者</strong>&quot;问题中，队列通常被视作线程间操作的数据容器，这样，可以对各个模块的业务功能进行解耦，生产者将“生产”出来的数据放置在数据容器中，而消费者仅仅只需要在“数据容器”中进行获取数据即可，这样生产者线程和消费者线程就能够进行解耦，只专注于自己的业务功能即可。</p><p>阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。<strong>当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止</strong>。</p><h2 id="基本操作" tabindex="-1">基本操作 <a class="header-anchor" href="#基本操作" aria-label="Permalink to &quot;基本操作&quot;">​</a></h2><p>BlockingQueue基本操作总结如下（此图来源于JAVA API文档）：</p><img src="'+p+`"><p>BlockingQueue继承于Queue接口，因此，对数据元素的基本操作有：</p><p>1）插入元素</p><ol><li>add(E e) ：往队列插入数据，当队列满时，插入元素时会抛出IllegalStateException异常；</li><li>offer(E e)：当往队列插入数据时，插入成功返回<code>true</code>，否则则返回<code>false</code>。当队列满时不会抛出异常；</li></ol><p>2）删除元素</p><ol><li>remove(Object o)：从队列中删除数据，成功则返回<code>true</code>，否则为<code>false</code></li><li>poll：删除数据，当队列为空时，返回null；</li></ol><p>3）查看元素</p><ol><li>element：获取队头元素，如果队列为空时则抛出NoSuchElementException异常；</li><li>peek：获取队头元素，如果队列为空则抛出NoSuchElementException异常</li></ol><p>BlockingQueue具有的特殊操作：</p><p>1）插入数据：</p><ol><li>put：当阻塞队列容量已经满时，往阻塞队列插入数据的线程会被阻塞，直至阻塞队列已经有空余的容量可供使用；</li><li><code>offer(E e, long timeout, TimeUnit unit)</code>：若阻塞队列已经满时，同样会阻塞插入数据的线程，直至阻塞队列已经有空余的地方，与put方法不同的是，该方法会有一个超时时间，若超过当前给定的超时时间，插入数据的线程会退出；</li></ol><p>2）删除数据</p><ol><li><code>take()</code>：当阻塞队列为空时，获取队头数据的线程会被阻塞；</li><li><code>poll(long timeout, TimeUnit unit)</code>：当阻塞队列为空时，获取数据的线程会被阻塞，另外，如果被阻塞的线程超过了给定的时长，该线程会退出</li></ol><h2 id="常用的blockingqueue" tabindex="-1">常用的BlockingQueue <a class="header-anchor" href="#常用的blockingqueue" aria-label="Permalink to &quot;常用的BlockingQueue&quot;">​</a></h2><p>实现BlockingQueue接口的有<code>ArrayBlockingQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue, LinkedTransferQueue, PriorityBlockingQueue, SynchronousQueue</code>，而这几种常见的阻塞队列也是在实际编程中会常用的，下面对这几种常见的阻塞队列进行说明：</p><h3 id="arrayblockingqueue" tabindex="-1">ArrayBlockingQueue <a class="header-anchor" href="#arrayblockingqueue" aria-label="Permalink to &quot;ArrayBlockingQueue&quot;">​</a></h3><p><strong>ArrayBlockingQueue</strong>是由数组实现的有界阻塞队列。该队列命令元素FIFO（先进先出）。因此，对头元素时队列中存在时间最长的数据元素，而对尾数据则是当前队列最新的数据元素。ArrayBlockingQueue可作为“有界数据缓冲区”，生产者插入数据到队列容器中，并由消费者提取。ArrayBlockingQueue一旦创建，容量不能改变。</p><p>当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p><p>ArrayBlockingQueue默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到ArrayBlockingQueue。而非公平性则是指访问ArrayBlockingQueue的顺序不是遵守严格的时间顺序，有可能存在，一旦ArrayBlockingQueue可以被访问时，长时间阻塞的线程依然无法访问到ArrayBlockingQueue。<strong>如果保证公平性，通常会降低吞吐量</strong>。如果需要获得公平性的ArrayBlockingQueue，可采用如下代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">private</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">static</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">ArrayBlockingQueue</span><span style="color:#F6F6F4;">&lt;Integer&gt; blockingQueue </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">ArrayBlockingQueue</span><span style="color:#F6F6F4;">&lt;Integer&gt;(</span><span style="color:#BF9EEE;">10</span><span style="color:#F6F6F4;">,</span><span style="color:#BF9EEE;">true</span><span style="color:#F6F6F4;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> ArrayBlockingQueue&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; blockingQueue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayBlockingQueue&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt;(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">true</span><span style="color:#24292E;">);</span></span></code></pre></div><p>ArrayBlockingQueue的主要属性如下:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#7B7F8B;">/** The queued items */</span></span>
<span class="line"><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Object</span><span style="color:#F6F6F4;">[] items;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">/** items index for next take, poll, peek or remove */</span></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> takeIndex;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">/** items index for next put, offer, or add */</span></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> putIndex;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">/** Number of elements in the queue */</span></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> count;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">/*</span></span>
<span class="line"><span style="color:#7B7F8B;"> * Concurrency control uses the classic two-condition algorithm</span></span>
<span class="line"><span style="color:#7B7F8B;"> * found in any textbook.</span></span>
<span class="line"><span style="color:#7B7F8B;"> */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">/** Main lock guarding all access */</span></span>
<span class="line"><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">ReentrantLock</span><span style="color:#F6F6F4;"> lock;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">/** Condition for waiting takes */</span></span>
<span class="line"><span style="color:#F286C4;">private</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Condition</span><span style="color:#F6F6F4;"> notEmpty;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">/** Condition for waiting puts */</span></span>
<span class="line"><span style="color:#F286C4;">private</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Condition</span><span style="color:#F6F6F4;"> notFull;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/** The queued items */</span></span>
<span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] items;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/** items index for next take, poll, peek or remove */</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> takeIndex;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/** items index for next put, offer, or add */</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> putIndex;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/** Number of elements in the queue */</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> count;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;"> * Concurrency control uses the classic two-condition algorithm</span></span>
<span class="line"><span style="color:#6A737D;"> * found in any textbook.</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/** Main lock guarding all access */</span></span>
<span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/** Condition for waiting takes */</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Condition notEmpty;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/** Condition for waiting puts */</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Condition notFull;</span></span></code></pre></div><p>从源码中可以看出ArrayBlockingQueue内部是采用数组进行数据存储的（<code>属性items</code>），为了保证线程安全，采用的是<code>ReentrantLock lock</code>，为了保证可阻塞式的插入删除数据利用的是Condition，当获取数据的消费者线程被阻塞时会将该线程放置到notEmpty等待队列中，当插入数据的生产者线程被阻塞时，会将该线程放置到notFull等待队列中。而notEmpty和notFull等中要属性在构造方法中进行创建：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">public</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">ArrayBlockingQueue</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> capacity, </span><span style="color:#97E1F1;font-style:italic;">boolean</span><span style="color:#F6F6F4;"> fair) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (capacity </span><span style="color:#F286C4;">&lt;=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">)</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">throw</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">IllegalArgumentException</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">.items </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Object</span><span style="color:#F6F6F4;">[capacity];</span></span>
<span class="line"><span style="color:#F6F6F4;">    lock </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">ReentrantLock</span><span style="color:#F6F6F4;">(fair);</span></span>
<span class="line"><span style="color:#F6F6F4;">    notEmpty </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> lock.</span><span style="color:#62E884;">newCondition</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    notFull </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;">  lock.</span><span style="color:#62E884;">newCondition</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ArrayBlockingQueue</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> capacity, </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> fair) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (capacity </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IllegalArgumentException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.items </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[capacity];</span></span>
<span class="line"><span style="color:#24292E;">    lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReentrantLock</span><span style="color:#24292E;">(fair);</span></span>
<span class="line"><span style="color:#24292E;">    notEmpty </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> lock.</span><span style="color:#6F42C1;">newCondition</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    notFull </span><span style="color:#D73A49;">=</span><span style="color:#24292E;">  lock.</span><span style="color:#6F42C1;">newCondition</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>接下来，主要看看可阻塞式的put和take方法是怎样实现的。</p><h4 id="_1-put方法详解" tabindex="-1">1）put方法详解 <a class="header-anchor" href="#_1-put方法详解" aria-label="Permalink to &quot;1）put方法详解&quot;">​</a></h4><p><code> put(E e)</code>方法源码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">public</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">void</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">E</span><span style="color:#F6F6F4;"> e) throws InterruptedException {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#62E884;">checkNotNull</span><span style="color:#F6F6F4;">(e);</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">ReentrantLock</span><span style="color:#F6F6F4;"> lock </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">.lock;</span></span>
<span class="line"><span style="color:#F6F6F4;">    lock.</span><span style="color:#62E884;">lockInterruptibly</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">try</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">		</span><span style="color:#7B7F8B;">//如果当前队列已满，将线程移入到notFull等待队列中</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">while</span><span style="color:#F6F6F4;"> (count </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> items.length)</span></span>
<span class="line"><span style="color:#F6F6F4;">            notFull.</span><span style="color:#62E884;">await</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">		</span><span style="color:#7B7F8B;">//满足插入数据的要求，直接进行入队操作</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#62E884;">enqueue</span><span style="color:#F6F6F4;">(e);</span></span>
<span class="line"><span style="color:#F6F6F4;">    } </span><span style="color:#F286C4;">finally</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">        lock.</span><span style="color:#62E884;">unlock</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(E e) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">checkNotNull</span><span style="color:#24292E;">(e);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lock;</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">lockInterruptibly</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6A737D;">//如果当前队列已满，将线程移入到notFull等待队列中</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (count </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> items.length)</span></span>
<span class="line"><span style="color:#24292E;">            notFull.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6A737D;">//满足插入数据的要求，直接进行入队操作</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">enqueue</span><span style="color:#24292E;">(e);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>该方法的逻辑很简单，当队列已满时（<code>count == items.length</code>）将线程移入到notFull等待队列中，如果当前满足插入数据的条件，就可以直接调用<code> enqueue(e)</code>插入数据元素。enqueue方法源码为：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">private</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">void</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">enqueue</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">E</span><span style="color:#F6F6F4;"> x) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// assert lock.getHoldCount() == 1;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// assert items[putIndex] == null;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Object</span><span style="color:#F6F6F4;">[] items </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">.items;</span></span>
<span class="line"><span style="color:#F6F6F4;">	</span><span style="color:#7B7F8B;">//插入数据</span></span>
<span class="line"><span style="color:#F6F6F4;">    items[putIndex] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> x;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (</span><span style="color:#F286C4;">++</span><span style="color:#F6F6F4;">putIndex </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> items.length)</span></span>
<span class="line"><span style="color:#F6F6F4;">        putIndex </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">    count</span><span style="color:#F286C4;">++</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">	</span><span style="color:#7B7F8B;">//通知消费者线程，当前队列中有数据可供消费</span></span>
<span class="line"><span style="color:#F6F6F4;">    notEmpty.</span><span style="color:#62E884;">signal</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">enqueue</span><span style="color:#24292E;">(E x) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// assert lock.getHoldCount() == 1;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// assert items[putIndex] == null;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] items </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.items;</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">//插入数据</span></span>
<span class="line"><span style="color:#24292E;">    items[putIndex] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> x;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">putIndex </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> items.length)</span></span>
<span class="line"><span style="color:#24292E;">        putIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    count</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">//通知消费者线程，当前队列中有数据可供消费</span></span>
<span class="line"><span style="color:#24292E;">    notEmpty.</span><span style="color:#6F42C1;">signal</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>enqueue方法的逻辑同样也很简单，先完成插入数据，即往数组中添加数据（<code>items[putIndex] = x</code>），然后通知被阻塞的消费者线程，当前队列中有数据可供消费（<code>notEmpty.signal()</code>）。</p><h4 id="_2-take方法详解" tabindex="-1">2）take方法详解 <a class="header-anchor" href="#_2-take方法详解" aria-label="Permalink to &quot;2）take方法详解&quot;">​</a></h4><p>take方法源码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">public</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">E</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">take</span><span style="color:#F6F6F4;">() throws InterruptedException {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">ReentrantLock</span><span style="color:#F6F6F4;"> lock </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">.lock;</span></span>
<span class="line"><span style="color:#F6F6F4;">    lock.</span><span style="color:#62E884;">lockInterruptibly</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">try</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">		</span><span style="color:#7B7F8B;">//如果队列为空，没有数据，将消费者线程移入等待队列中</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">while</span><span style="color:#F6F6F4;"> (count </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">)</span></span>
<span class="line"><span style="color:#F6F6F4;">            notEmpty.</span><span style="color:#62E884;">await</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">		</span><span style="color:#7B7F8B;">//获取数据</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">dequeue</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    } </span><span style="color:#F286C4;">finally</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">        lock.</span><span style="color:#62E884;">unlock</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> E </span><span style="color:#6F42C1;">take</span><span style="color:#24292E;">() throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lock;</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">lockInterruptibly</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6A737D;">//如果队列为空，没有数据，将消费者线程移入等待队列中</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (count </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            notEmpty.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6A737D;">//获取数据</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dequeue</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>take方法也主要做了两步：</p><ol><li>如果当前队列为空的话，则将获取数据的消费者线程移入到等待队列中；</li><li>若队列不为空则获取数据，即完成出队操作<code>dequeue</code>。dequeue方法源码为：</li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">private</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">E</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">dequeue</span><span style="color:#F6F6F4;">() {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// assert lock.getHoldCount() == 1;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// assert items[takeIndex] != null;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Object</span><span style="color:#F6F6F4;">[] items </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">.items;</span></span>
<span class="line"><span style="color:#F6F6F4;">    @</span><span style="color:#97E1F1;font-style:italic;">SuppressWarnings</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">unchecked</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">)</span></span>
<span class="line"><span style="color:#F6F6F4;">	</span><span style="color:#7B7F8B;">//获取数据</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">E</span><span style="color:#F6F6F4;"> x </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (E) items[takeIndex];</span></span>
<span class="line"><span style="color:#F6F6F4;">    items[takeIndex] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (</span><span style="color:#F286C4;">++</span><span style="color:#F6F6F4;">takeIndex </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> items.length)</span></span>
<span class="line"><span style="color:#F6F6F4;">        takeIndex </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">    count</span><span style="color:#F286C4;">--</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (itrs </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">)</span></span>
<span class="line"><span style="color:#F6F6F4;">        itrs.</span><span style="color:#62E884;">elementDequeued</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">//通知被阻塞的生产者线程</span></span>
<span class="line"><span style="color:#F6F6F4;">	notFull.</span><span style="color:#62E884;">signal</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> x;</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> E </span><span style="color:#6F42C1;">dequeue</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// assert lock.getHoldCount() == 1;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// assert items[takeIndex] != null;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] items </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.items;</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">SuppressWarnings</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;unchecked&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">//获取数据</span></span>
<span class="line"><span style="color:#24292E;">    E x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (E) items[takeIndex];</span></span>
<span class="line"><span style="color:#24292E;">    items[takeIndex] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">takeIndex </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> items.length)</span></span>
<span class="line"><span style="color:#24292E;">        takeIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    count</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (itrs </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        itrs.</span><span style="color:#6F42C1;">elementDequeued</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//通知被阻塞的生产者线程</span></span>
<span class="line"><span style="color:#24292E;">	notFull.</span><span style="color:#6F42C1;">signal</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> x;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>dequeue方法也主要做了两件事情：</p><ol><li>获取队列中的数据，即获取数组中的数据元素（<code>(E) items[takeIndex]</code>）；</li><li>通知notFull等待队列中的线程，使其由等待队列移入到同步队列中，使其能够有机会获得lock，并执行完成功退出。</li></ol><p>从以上分析，可以看出put和take方法主要是通过condition的通知机制来完成可阻塞式的插入数据和获取数据。在理解ArrayBlockingQueue后再去理解LinkedBlockingQueue就很容易了。</p><h3 id="linkedblockingqueue" tabindex="-1">LinkedBlockingQueue <a class="header-anchor" href="#linkedblockingqueue" aria-label="Permalink to &quot;LinkedBlockingQueue&quot;">​</a></h3><p>LinkedBlockingQueue是用链表实现的有界阻塞队列，同样满足FIFO的特性，与ArrayBlockingQueue相比起来具有更高的吞吐量，为了防止LinkedBlockingQueue容量迅速增，损耗大量内存。通常在创建LinkedBlockingQueue对象时，会指定其大小，如果未指定，容量等于Integer.MAX_VALUE</p><p>LinkedBlockingQueue的主要属性有：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#7B7F8B;">/** Current number of elements */</span></span>
<span class="line"><span style="color:#F286C4;">private</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">AtomicInteger</span><span style="color:#F6F6F4;"> count </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">AtomicInteger</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">/**</span></span>
<span class="line"><span style="color:#7B7F8B;"> * Head of linked list.</span></span>
<span class="line"><span style="color:#7B7F8B;"> * Invariant: head.item == null</span></span>
<span class="line"><span style="color:#7B7F8B;"> */</span></span>
<span class="line"><span style="color:#F286C4;">transient</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;E&gt; head;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">/**</span></span>
<span class="line"><span style="color:#7B7F8B;"> * Tail of linked list.</span></span>
<span class="line"><span style="color:#7B7F8B;"> * Invariant: last.next == null</span></span>
<span class="line"><span style="color:#7B7F8B;"> */</span></span>
<span class="line"><span style="color:#F286C4;">private</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">transient</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;E&gt; last;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">/** Lock held by take, poll, etc */</span></span>
<span class="line"><span style="color:#F286C4;">private</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">ReentrantLock</span><span style="color:#F6F6F4;"> takeLock </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">ReentrantLock</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">/** Wait queue for waiting takes */</span></span>
<span class="line"><span style="color:#F286C4;">private</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Condition</span><span style="color:#F6F6F4;"> notEmpty </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> takeLock.</span><span style="color:#62E884;">newCondition</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">/** Lock held by put, offer, etc */</span></span>
<span class="line"><span style="color:#F286C4;">private</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">ReentrantLock</span><span style="color:#F6F6F4;"> putLock </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">ReentrantLock</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">/** Wait queue for waiting puts */</span></span>
<span class="line"><span style="color:#F286C4;">private</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Condition</span><span style="color:#F6F6F4;"> notFull </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> putLock.</span><span style="color:#62E884;">newCondition</span><span style="color:#F6F6F4;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/** Current number of elements */</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> AtomicInteger count </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AtomicInteger</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * Head of linked list.</span></span>
<span class="line"><span style="color:#6A737D;"> * Invariant: head.item == null</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> Node&lt;</span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt; head;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * Tail of linked list.</span></span>
<span class="line"><span style="color:#6A737D;"> * Invariant: last.next == null</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> Node&lt;</span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt; last;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/** Lock held by take, poll, etc */</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock takeLock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReentrantLock</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/** Wait queue for waiting takes */</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Condition notEmpty </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> takeLock.</span><span style="color:#6F42C1;">newCondition</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/** Lock held by put, offer, etc */</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock putLock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReentrantLock</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/** Wait queue for waiting puts */</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Condition notFull </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> putLock.</span><span style="color:#6F42C1;">newCondition</span><span style="color:#24292E;">();</span></span></code></pre></div><p>可以看出与ArrayBlockingQueue主要的区别是，LinkedBlockingQueue在插入数据和删除数据时分别是由两个不同的lock（<code>takeLock</code>和<code>putLock</code>）来控制线程安全的，因此，也由这两个lock生成了两个对应的condition（<code>notEmpty</code>和<code>notFull</code>）来实现可阻塞的插入和删除数据。并且，采用了链表的数据结构来实现队列，Node结点的定义为：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">static</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">class</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">Node</span><span style="color:#F6F6F4;">&lt;E&gt; {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">E</span><span style="color:#F6F6F4;"> item;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">    /**</span></span>
<span class="line"><span style="color:#7B7F8B;">     * One of:</span></span>
<span class="line"><span style="color:#7B7F8B;">     * - the real successor Node</span></span>
<span class="line"><span style="color:#7B7F8B;">     * - this Node, meaning the successor is head.next</span></span>
<span class="line"><span style="color:#7B7F8B;">     * - null, meaning there is no successor (this is the last node)</span></span>
<span class="line"><span style="color:#7B7F8B;">     */</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;E&gt; next;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#62E884;">Node</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">E</span><span style="color:#F6F6F4;"> </span><span style="color:#FFB86C;font-style:italic;">x</span><span style="color:#F6F6F4;">) { item </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> x; }</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#24292E;">    E item;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    /**</span></span>
<span class="line"><span style="color:#6A737D;">     * One of:</span></span>
<span class="line"><span style="color:#6A737D;">     * - the real successor Node</span></span>
<span class="line"><span style="color:#6A737D;">     * - this Node, meaning the successor is head.next</span></span>
<span class="line"><span style="color:#6A737D;">     * - null, meaning there is no successor (this is the last node)</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#24292E;">    Node&lt;</span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt; next;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;">(E </span><span style="color:#E36209;">x</span><span style="color:#24292E;">) { item </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> x; }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>接下来，我们也同样来看看put方法和take方法的实现。</p><h4 id="_1-put方法详解-1" tabindex="-1">1）put方法详解 <a class="header-anchor" href="#_1-put方法详解-1" aria-label="Permalink to &quot;1）put方法详解&quot;">​</a></h4><p>put方法源码为:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">public</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">void</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">E</span><span style="color:#F6F6F4;"> e) throws InterruptedException {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (e </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) </span><span style="color:#F286C4;">throw</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">NullPointerException</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// Note: convention in all put/take/etc is to preset local var</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// holding count negative to indicate failure unless set.</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> c </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">-</span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;E&gt; node </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Node</span><span style="color:#F6F6F4;">&lt;E&gt;(e);</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">ReentrantLock</span><span style="color:#F6F6F4;"> putLock </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">.putLock;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">AtomicInteger</span><span style="color:#F6F6F4;"> count </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">.count;</span></span>
<span class="line"><span style="color:#F6F6F4;">    putLock.</span><span style="color:#62E884;">lockInterruptibly</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">try</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#7B7F8B;">/*</span></span>
<span class="line"><span style="color:#7B7F8B;">         * Note that count is used in wait guard even though it is</span></span>
<span class="line"><span style="color:#7B7F8B;">         * not protected by lock. This works because count can</span></span>
<span class="line"><span style="color:#7B7F8B;">         * only decrease at this point (all other puts are shut</span></span>
<span class="line"><span style="color:#7B7F8B;">         * out by lock), and we (or some other waiting put) are</span></span>
<span class="line"><span style="color:#7B7F8B;">         * signalled if it ever changes from capacity. Similarly</span></span>
<span class="line"><span style="color:#7B7F8B;">         * for all other uses of count in other wait guards.</span></span>
<span class="line"><span style="color:#7B7F8B;">         */</span></span>
<span class="line"><span style="color:#F6F6F4;">		</span><span style="color:#7B7F8B;">//如果队列已满，则阻塞当前线程，将其移入等待队列</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">while</span><span style="color:#F6F6F4;"> (count.</span><span style="color:#62E884;">get</span><span style="color:#F6F6F4;">() </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> capacity) {</span></span>
<span class="line"><span style="color:#F6F6F4;">            notFull.</span><span style="color:#62E884;">await</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">        }</span></span>
<span class="line"><span style="color:#F6F6F4;">		</span><span style="color:#7B7F8B;">//入队操作，插入数据</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#62E884;">enqueue</span><span style="color:#F6F6F4;">(node);</span></span>
<span class="line"><span style="color:#F6F6F4;">        c </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> count.</span><span style="color:#62E884;">getAndIncrement</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">		</span><span style="color:#7B7F8B;">//若队列满足插入数据的条件，则通知被阻塞的生产者线程</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (c </span><span style="color:#F286C4;">+</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> capacity)</span></span>
<span class="line"><span style="color:#F6F6F4;">            notFull.</span><span style="color:#62E884;">signal</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    } </span><span style="color:#F286C4;">finally</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">        putLock.</span><span style="color:#62E884;">unlock</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (c </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">)</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#62E884;">signalNotEmpty</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(E e) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (e </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NullPointerException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// Note: convention in all put/take/etc is to preset local var</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// holding count negative to indicate failure unless set.</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    Node&lt;</span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt; node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Node&lt;</span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt;(e);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock putLock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.putLock;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> AtomicInteger count </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.count;</span></span>
<span class="line"><span style="color:#24292E;">    putLock.</span><span style="color:#6F42C1;">lockInterruptibly</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;">         * Note that count is used in wait guard even though it is</span></span>
<span class="line"><span style="color:#6A737D;">         * not protected by lock. This works because count can</span></span>
<span class="line"><span style="color:#6A737D;">         * only decrease at this point (all other puts are shut</span></span>
<span class="line"><span style="color:#6A737D;">         * out by lock), and we (or some other waiting put) are</span></span>
<span class="line"><span style="color:#6A737D;">         * signalled if it ever changes from capacity. Similarly</span></span>
<span class="line"><span style="color:#6A737D;">         * for all other uses of count in other wait guards.</span></span>
<span class="line"><span style="color:#6A737D;">         */</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6A737D;">//如果队列已满，则阻塞当前线程，将其移入等待队列</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (count.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> capacity) {</span></span>
<span class="line"><span style="color:#24292E;">            notFull.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6A737D;">//入队操作，插入数据</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">enqueue</span><span style="color:#24292E;">(node);</span></span>
<span class="line"><span style="color:#24292E;">        c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> count.</span><span style="color:#6F42C1;">getAndIncrement</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6A737D;">//若队列满足插入数据的条件，则通知被阻塞的生产者线程</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (c </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> capacity)</span></span>
<span class="line"><span style="color:#24292E;">            notFull.</span><span style="color:#6F42C1;">signal</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        putLock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (c </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">signalNotEmpty</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>put方法的逻辑也同样很容易理解，可见注释。基本上和ArrayBlockingQueue的put方法一样。</p><h4 id="_2-take方法" tabindex="-1">2）take方法 <a class="header-anchor" href="#_2-take方法" aria-label="Permalink to &quot;2）take方法&quot;">​</a></h4><p>源码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">public</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">E</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">take</span><span style="color:#F6F6F4;">() throws InterruptedException {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">E</span><span style="color:#F6F6F4;"> x;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> c </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">-</span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">AtomicInteger</span><span style="color:#F6F6F4;"> count </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">.count;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">ReentrantLock</span><span style="color:#F6F6F4;"> takeLock </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">.takeLock;</span></span>
<span class="line"><span style="color:#F6F6F4;">    takeLock.</span><span style="color:#62E884;">lockInterruptibly</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">try</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">		</span><span style="color:#7B7F8B;">//当前队列为空，则阻塞当前线程，将其移入到等待队列中，直至满足条件</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">while</span><span style="color:#F6F6F4;"> (count.</span><span style="color:#62E884;">get</span><span style="color:#F6F6F4;">() </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#F6F6F4;">            notEmpty.</span><span style="color:#62E884;">await</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">        }</span></span>
<span class="line"><span style="color:#F6F6F4;">		</span><span style="color:#7B7F8B;">//移除队头元素，获取数据</span></span>
<span class="line"><span style="color:#F6F6F4;">        x </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">dequeue</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">        c </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> count.</span><span style="color:#62E884;">getAndDecrement</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#7B7F8B;">//如果当前满足移除元素的条件，则通知被阻塞的消费者线程</span></span>
<span class="line"><span style="color:#F6F6F4;">		</span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (c </span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">)</span></span>
<span class="line"><span style="color:#F6F6F4;">            notEmpty.</span><span style="color:#62E884;">signal</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    } </span><span style="color:#F286C4;">finally</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">        takeLock.</span><span style="color:#62E884;">unlock</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (c </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> capacity)</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#62E884;">signalNotFull</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> x;</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> E </span><span style="color:#6F42C1;">take</span><span style="color:#24292E;">() throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    E x;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> AtomicInteger count </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.count;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock takeLock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.takeLock;</span></span>
<span class="line"><span style="color:#24292E;">    takeLock.</span><span style="color:#6F42C1;">lockInterruptibly</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6A737D;">//当前队列为空，则阻塞当前线程，将其移入到等待队列中，直至满足条件</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (count.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            notEmpty.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6A737D;">//移除队头元素，获取数据</span></span>
<span class="line"><span style="color:#24292E;">        x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dequeue</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> count.</span><span style="color:#6F42C1;">getAndDecrement</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">//如果当前满足移除元素的条件，则通知被阻塞的消费者线程</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (c </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            notEmpty.</span><span style="color:#6F42C1;">signal</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        takeLock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (c </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> capacity)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">signalNotFull</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> x;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>take方法的主要逻辑请见于注释，也很容易理解。</p><p>** ArrayBlockingQueue与LinkedBlockingQueue的比较**</p><p><strong>相同点</strong>：ArrayBlockingQueue和LinkedBlockingQueue都是通过condition通知机制来实现可阻塞式插入和删除元素，并满足线程安全的特性；</p><p><strong>不同点</strong>：</p><ol><li>ArrayBlockingQueue底层是采用的数组进行实现，而LinkedBlockingQueue则是采用链表数据结构；</li><li>ArrayBlockingQueue插入和删除数据，只采用了一个lock，而LinkedBlockingQueue则是在插入和删除分别采用了<code>putLock</code>和<code>takeLock</code>，这样可以降低线程由于线程无法获取到lock而进入WAITING状态的可能性，从而提高了线程并发执行的效率。</li></ol><h3 id="priorityblockingqueue" tabindex="-1">PriorityBlockingQueue <a class="header-anchor" href="#priorityblockingqueue" aria-label="Permalink to &quot;PriorityBlockingQueue&quot;">​</a></h3><p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现compareTo()方法来指定元素排序规则，或者初始化时通过构造器参数Comparator来指定排序规则。</p><h3 id="synchronousqueue" tabindex="-1">SynchronousQueue <a class="header-anchor" href="#synchronousqueue" aria-label="Permalink to &quot;SynchronousQueue&quot;">​</a></h3><p>SynchronousQueue每个插入操作必须等待另一个线程进行相应的删除操作，因此，SynchronousQueue实际上没有存储任何数据元素，因为只有线程在删除数据时，其他线程才能插入数据，同样的，如果当前有线程在插入数据时，线程才能删除数据。SynchronousQueue也可以通过构造器参数来为其指定公平性。</p><h3 id="linkedtransferqueue" tabindex="-1">LinkedTransferQueue <a class="header-anchor" href="#linkedtransferqueue" aria-label="Permalink to &quot;LinkedTransferQueue&quot;">​</a></h3><p>LinkedTransferQueue是一个由链表数据结构构成的无界阻塞队列，由于该队列实现了TransferQueue接口，与其他阻塞队列相比主要有以下不同的方法：</p><p><strong>transfer(E e)</strong> 如果当前有线程（消费者）正在调用take()方法或者可延时的poll()方法进行消费数据时，生产者线程可以调用transfer方法将数据传递给消费者线程。如果当前没有消费者线程的话，生产者线程就会将数据插入到队尾，直到有消费者能够进行消费才能退出；</p><p><strong>tryTransfer(E e)</strong> tryTransfer方法如果当前有消费者线程（调用take方法或者具有超时特性的poll方法）正在消费数据的话，该方法可以将数据立即传送给消费者线程，如果当前没有消费者线程消费数据的话，就立即返回<code>false</code>。因此，与transfer方法相比，transfer方法是必须等到有消费者线程消费数据时，生产者线程才能够返回。而tryTransfer方法能够立即返回结果退出。</p><p><code>tryTransfer(E e,long timeout,imeUnit unit)</code> 与transfer基本功能一样，只是增加了超时特性，如果数据才规定的超时时间内没有消费者进行消费的话，就返回<code>false</code>。</p><h3 id="linkedblockingdeque" tabindex="-1">LinkedBlockingDeque <a class="header-anchor" href="#linkedblockingdeque" aria-label="Permalink to &quot;LinkedBlockingDeque&quot;">​</a></h3><p>LinkedBlockingDeque是基于链表数据结构的有界阻塞双端队列，如果在创建对象时为指定大小时，其默认大小为Integer.MAX_VALUE。与LinkedBlockingQueue相比，主要的不同点在于，LinkedBlockingDeque具有双端队列的特性。LinkedBlockingDeque基本操作如下图所示（来源于java文档）</p><img src="`+o+'"><p>如上图所示，LinkedBlockingDeque的基本操作可以分为四种类型：</p><ol><li>特殊情况，抛出异常；</li><li>特殊情况，返回特殊值如null或者false；</li><li>当线程不满足操作条件时，线程会被阻塞直至条件满足；</li><li>操作具有超时特性。</li></ol><p>另外，LinkedBlockingDeque实现了BlockingDueue接口而LinkedBlockingQueue实现的是BlockingQueue，这两个接口的主要区别如下图所示（来源于java文档）：</p><img src="'+e+'"><p>从上图可以看出，两个接口的功能是可以等价使用的，比如BlockingQueue的add方法和BlockingDeque的addLast方法的功能是一样的。</p><h3 id="delayqueue" tabindex="-1">DelayQueue <a class="header-anchor" href="#delayqueue" aria-label="Permalink to &quot;DelayQueue&quot;">​</a></h3><p>DelayQueue是一个存放实现Delayed接口的数据的无界阻塞队列，只有当数据对象的延时时间达到时才能插入到队列进行存储。如果当前所有的数据都还没有达到创建时所指定的延时期，则队列没有队头，并且线程通过poll等方法获取数据元素则返回null。所谓数据延时期满时，则是通过Delayed接口的<code>getDelay(TimeUnit.NANOSECONDS)</code>来进行判定，如果该方法返回的是小于等于0则说明该数据元素的延时期已满。</p><hr><blockquote><p>内容大部分来源以下三个开源仓库：</p><ul><li><a href="http://concurrent.redspider.group/" target="_blank" rel="noreferrer">深入浅出 Java 多线程</a></li><li><a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noreferrer">并发编程知识总结</a></li><li><a href="https://github.com/CoderLeixiaoshuai/java-eight-part" target="_blank" rel="noreferrer">Java八股文</a></li></ul></blockquote><hr>',85),r=[c];function y(F,i,u,E,d,k){return n(),a("div",null,r)}const C=s(t,[["render",y]]);export{h as __pageData,C as default};
