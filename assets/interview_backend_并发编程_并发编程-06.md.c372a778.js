import{_ as a,o as e,c as r,V as o}from"./chunks/framework.c6d8cbec.js";const A=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/并发编程/并发编程-06.md","filePath":"interview/backend/并发编程/并发编程-06.md"}'),t={name:"interview/backend/并发编程/并发编程-06.md"},n=o('<h3 id="_1、如何在-windows-和-linux-上查找哪个线程cpu利用率最高" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#1%E5%A6%82%E4%BD%95%E5%9C%A8-windows-%E5%92%8C-linux-%E4%B8%8A%E6%9F%A5%E6%89%BE%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8Bcpu%E5%88%A9%E7%94%A8%E7%8E%87%E6%9C%80%E9%AB%98" target="_blank" rel="noreferrer">1、如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</a> <a class="header-anchor" href="#_1、如何在-windows-和-linux-上查找哪个线程cpu利用率最高" aria-label="Permalink to &quot;[1、如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程面试题大汇总，2021年附答案解析.md#1如何在-windows-和-linux-上查找哪个线程cpu利用率最高)&quot;">​</a></h3><p>windows上面用任务管理器看，linux下可以用 top 这个工具看。</p><p><strong>1、</strong> 找出cpu耗用厉害的进程pid， 终端执行top命令，然后按下shift+p (shift+m是找出消耗内存最高)查找出cpu利用最厉害的pid号</p><p><strong>2、</strong> 根据上面第一步拿到的pid号，top -H -p pid 。然后按下shift+p，查找出cpu利用率最厉害的线程号，比如top -H -p 1328</p><p><strong>3、</strong> 将获取到的线程号转换成16进制，去百度转换一下就行</p><p><strong>4、</strong> 使用jstack工具将进程信息打印输出，jstack pid号 &gt; /tmp/t.dat，比如jstack 31365 &gt; /tmp/t.dat</p><p><strong>5、</strong> 编辑/tmp/t.dat文件，查找线程号对应的信息</p><p>或者直接使用JDK自带的工具查看“jconsole” 、“visualVm”，这都是JDK自带的，可以直接在JDK的bin目录下找到直接使用</p><h3 id="_2、堆-heap-线程共享-运行时数据区" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#2%E5%A0%86heap-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB--%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA" target="_blank" rel="noreferrer">2、堆（Heap-线程共享） -运行时数据区</a> <a class="header-anchor" href="#_2、堆-heap-线程共享-运行时数据区" aria-label="Permalink to &quot;[2、堆（Heap-线程共享） -运行时数据区](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程面试题大汇总，2021年附答案解析.md#2堆heap-线程共享--运行时数据区)&quot;">​</a></h3><p>是被线程共享的一块内存区域， 创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。</p><h3 id="_3、java中的readwritelock是什么" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#3java%E4%B8%AD%E7%9A%84readwritelock%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noreferrer">3、Java中的ReadWriteLock是什么？</a> <a class="header-anchor" href="#_3、java中的readwritelock是什么" aria-label="Permalink to &quot;[3、Java中的ReadWriteLock是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程面试题大汇总，2021年附答案解析.md#3java中的readwritelock是什么)&quot;">​</a></h3><p>读写锁是用来提升并发程序性能的锁分离技术的成果。</p><h3 id="_4、gc的回收流程是怎样的" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#4gc%E7%9A%84%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84" target="_blank" rel="noreferrer">4、GC的回收流程是怎样的？</a> <a class="header-anchor" href="#_4、gc的回收流程是怎样的" aria-label="Permalink to &quot;[4、GC的回收流程是怎样的？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程面试题大汇总，2021年附答案解析.md#4gc的回收流程是怎样的)&quot;">​</a></h3><p><strong>GC回收流程如下：</strong></p><p><strong>1、</strong> 对于整个的GC流程里面，那么最需要处理的就是新生代和老年代的内存清理操作，而元空间（永久代）都不在GC范围内</p><p><strong>2、</strong> 当现在有一个新的对象产生，那么对象一定需要内存空间，平均每个栈内存存4k，每个堆内存存8k，那么对象一定需要进行堆空间的申请</p><p><strong>3、</strong> 首先会判断Eden区是否有内存空间，如果此时有内存空间，则直接将新对象保存在伊甸园区。</p><p><strong>4、</strong> 但是如果此时在伊甸园区内存不足，那么会自动执行一个Minor GC 操作，将伊甸园区的无用内存空间进行清理，Minor GC的清理范围只在Eden园区，清理之后会继续判断Eden园区的内存空间是否充足？如果内存空间充足，则将新对象直接在Eden园区进行空间分配。</p><p><strong>5、</strong> 如果执行Minor GC 之后发现伊甸园区的内存空间依然不足，那么这个时候会执行存活区的判断，如果存活区有剩余空间，则将Eden园区部分活跃对象保存在存活区，那么随后继续判断Eden园区的内存空间是否充足，如果充足怎则将新对象直接在Eden园区进行空间分配。</p><p><strong>6、</strong> 此时如果存活区没有内存空间，则继续判断老年区。则将部分存活对象保存在老年代，而后存活区将有空余空间。</p><p><strong>7、</strong> 如果这个时候老年代也满了，那么这个时候将产生Major GC（Full GC）,那么这个时候将进行老年代的清理</p><p><strong>8、</strong> 如果老年代执行Full GC之后，无法进行对象的保存，则会产生OOM异常,OutOfMemoryError异常</p><h3 id="_5、java弱引用" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#5java%E5%BC%B1%E5%BC%95%E7%94%A8" target="_blank" rel="noreferrer">5、JAVA弱引用</a> <a class="header-anchor" href="#_5、java弱引用" aria-label="Permalink to &quot;[5、JAVA弱引用](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程面试题大汇总，2021年附答案解析.md#5java弱引用)&quot;">​</a></h3><p>弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。</p><h3 id="_6、生产环境用的什么jdk-如何配置的垃圾收集器" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#6%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88jdk%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8" target="_blank" rel="noreferrer">6、生产环境用的什么JDK？如何配置的垃圾收集器？</a> <a class="header-anchor" href="#_6、生产环境用的什么jdk-如何配置的垃圾收集器" aria-label="Permalink to &quot;[6、生产环境用的什么JDK？如何配置的垃圾收集器？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程面试题大汇总，2021年附答案解析.md#6生产环境用的什么jdk如何配置的垃圾收集器)&quot;">​</a></h3><p><strong>Oracle JDK 1.8</strong></p><p>JDK 1.8 中有 Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1，默认使用 Parallel Scavenge + Parallel Old。</p><p><strong>1、</strong> Serial 系列是单线程垃圾收集器，处理效率很高，适合小内存、客户端场景使用，使用参数 -XX:+UseSerialGC 显式启用。</p><p><strong>2、</strong> Parallel 系列相当于并发版的 Serial，追求高吞吐量，适用于较大内存并且有多核CPU的环境，默认或显式使用参数 -XX:+UseParallelGC 启用。可以使用 -XX:MaxGCPauseMillis 参数指定最大垃圾收集暂停毫秒数，收集器会尽量达到目标；使用 -XX:GCTimeRatio 指定期望吞吐量大小，默认 99，用户代码运行时间:垃圾收集时间=99:1。</p><p><strong>3、</strong> CMS，追求垃圾收集暂停时间尽可能短，适用于服务端较大内存且多 CPU 的应用，使用参数 -XX:+UseConcMarkSweepGC 显式开启，会同时作用年轻代与老年代，但有浮动垃圾和内存碎片化的问题。</p><p><strong>4、</strong> G1，主要面向服务端应用的垃圾收集器，适用于具有大内存的多核 CPU 的服务器，追求较小的垃圾收集暂停时间和较高的吞吐量。首创局部内存回收设计思路，采用不同策略实现分代，不再使用固定大小、固定数量的堆内存分代区域划分，而是基于 Region 内存布局，优先回收价收益最大的 Region。使用参数 -XX:+UseG1GC 开启。</p><p><strong>我们生产环境使用了 G1 收集器，相关配置如下</strong></p><p><strong>1、</strong> -Xmx12g</p><p><strong>2、</strong> -Xms12g</p><p><strong>3、</strong> -XX:+UseG1GC</p><p><strong>4、</strong> -XX:InitiatingHeapOccupancyPercent=45</p><p><strong>5、</strong> -XX:MaxGCPauseMillis=200</p><p><strong>6、</strong> -XX:MetaspaceSize=256m</p><p><strong>7、</strong> -XX:MaxMetaspaceSize=256m</p><p><strong>8、</strong> -XX:MaxDirectMemorySize=512m</p><p><strong>9、</strong> -XX:G1HeapRegionSize 未指定</p><p><strong>核心思路：</strong></p><p><strong>1、</strong> 每个内存区域设置上限，避免溢出</p><p><strong>2、</strong> 堆设置为操作系统的 70%左右，超过 8 G，首选 G1</p><p><strong>3、</strong> 根据老年代对象提升速度，调整新生代与老年代之间的内存比例</p><p><strong>4、</strong> 等过 GC 信息，针对项目敏感指标优化，比如访问延迟、吞吐量等</p><h3 id="_7、线上常用的-jvm-参数有哪些" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#7%E7%BA%BF%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84-jvm-%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B" target="_blank" rel="noreferrer">7、线上常用的 JVM 参数有哪些？</a> <a class="header-anchor" href="#_7、线上常用的-jvm-参数有哪些" aria-label="Permalink to &quot;[7、线上常用的 JVM 参数有哪些？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程面试题大汇总，2021年附答案解析.md#7线上常用的-jvm-参数有哪些)&quot;">​</a></h3><p><strong>数据区设置</strong></p><p><strong>1、</strong> Xms：初始堆大小</p><p><strong>2、</strong> Xmx：最大堆大小</p><p><strong>3、</strong> Xss:Java 每个线程的Stack大小</p><p><strong>4、</strong> XX:NewSize=n：设置年轻代大小</p><p><strong>5、</strong> XX:NewRatio=n：设置年轻代和年老代的比值。如：为 3，表示年轻代与年老代比值为 1:3，年轻代占整个年轻代年老代和的 1/4。</p><p><strong>6、</strong> XX：SurvivorRatio=n：年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。如：3，表示 Eden：Survivor=3：2，一个 Survivor 区占整个年轻代的 1/5。</p><p><strong>7、</strong> XX：MaxPermSize=n：设置持久代大小。</p><p><strong>收集器设置</strong></p><p><strong>1、</strong> XX:+UseSerialGC：设置串行收集器</p><p><strong>2、</strong> XX:+UseParallelGC:：设置并行收集器</p><p><strong>3、</strong> XX:+UseParalledlOldGC：设置并行年老代收集器</p><p><strong>4、</strong> XX:+UseConcMarkSweepGC：设置并发收集器</p><p><strong>GC日志打印设置</strong></p><p><strong>1、</strong> XX:+PrintGC：打印 GC 的简要信息</p><p><strong>2、</strong> XX:+PrintGCDetails：打印 GC 详细信息</p><p><strong>3、</strong> XX:+PrintGCTimeStamps：输出 GC 的时间戳</p><h3 id="_8、一个线程运行时发生异常会怎样" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%E4%BC%9A%E6%80%8E%E6%A0%B7" target="_blank" rel="noreferrer">8、一个线程运行时发生异常会怎样？</a> <a class="header-anchor" href="#_8、一个线程运行时发生异常会怎样" aria-label="Permalink to &quot;[8、一个线程运行时发生异常会怎样？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程面试题大汇总，2021年附答案解析.md#8一个线程运行时发生异常会怎样)&quot;">​</a></h3><p>如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p><h3 id="_9、为什么wait-notify-和-notifyall这些方法不在thread类里面" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#9%E4%B8%BA%E4%BB%80%E4%B9%88wait,-notify-%E5%92%8C-notifyall%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%8D%E5%9C%A8thread%E7%B1%BB%E9%87%8C%E9%9D%A2" target="_blank" rel="noreferrer">9、为什么wait, notify 和 notifyAll这些方法不在thread类里面？</a> <a class="header-anchor" href="#_9、为什么wait-notify-和-notifyall这些方法不在thread类里面" aria-label="Permalink to &quot;[9、为什么wait, notify 和 notifyAll这些方法不在thread类里面？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程面试题大汇总，2021年附答案解析.md#9为什么wait,-notify-和-notifyall这些方法不在thread类里面)&quot;">​</a></h3><p>一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p><h3 id="_10、在老年代-标记整理算法" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#10%E5%9C%A8%E8%80%81%E5%B9%B4%E4%BB%A3-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95" target="_blank" rel="noreferrer">10、在老年代-标记整理算法</a> <a class="header-anchor" href="#_10、在老年代-标记整理算法" aria-label="Permalink to &quot;[10、在老年代-标记整理算法](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程面试题大汇总，2021年附答案解析.md#10在老年代-标记整理算法)&quot;">​</a></h3><p>因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理” 算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。</p><h3 id="_11、线程类的构造方法、静态块是被哪个线程调用的" tabindex="-1">11、线程类的构造方法、静态块是被哪个线程调用的 <a class="header-anchor" href="#_11、线程类的构造方法、静态块是被哪个线程调用的" aria-label="Permalink to &quot;11、线程类的构造方法、静态块是被哪个线程调用的&quot;">​</a></h3><h3 id="_12、栈" tabindex="-1">12、栈 <a class="header-anchor" href="#_12、栈" aria-label="Permalink to &quot;12、栈&quot;">​</a></h3><h3 id="_13、强引用、软引用、弱引用、虚引用是什么-有什么区别" tabindex="-1">13、强引用、软引用、弱引用、虚引用是什么，有什么区别？ <a class="header-anchor" href="#_13、强引用、软引用、弱引用、虚引用是什么-有什么区别" aria-label="Permalink to &quot;13、强引用、软引用、弱引用、虚引用是什么，有什么区别？&quot;">​</a></h3><h3 id="_14、为什么要使用并发编程" tabindex="-1">14、为什么要使用并发编程 <a class="header-anchor" href="#_14、为什么要使用并发编程" aria-label="Permalink to &quot;14、为什么要使用并发编程&quot;">​</a></h3><h3 id="_15、重排序遵守的规则" tabindex="-1">15、重排序遵守的规则 <a class="header-anchor" href="#_15、重排序遵守的规则" aria-label="Permalink to &quot;15、重排序遵守的规则&quot;">​</a></h3><h3 id="_16、64-位-jvm-中-int-的长度是多数" tabindex="-1">16、64 位 JVM 中，int 的长度是多数？ <a class="header-anchor" href="#_16、64-位-jvm-中-int-的长度是多数" aria-label="Permalink to &quot;16、64 位 JVM 中，int 的长度是多数？&quot;">​</a></h3><h3 id="_17、谈谈动态年龄判断" tabindex="-1">17、谈谈动态年龄判断 <a class="header-anchor" href="#_17、谈谈动态年龄判断" aria-label="Permalink to &quot;17、谈谈动态年龄判断&quot;">​</a></h3><h3 id="_18、遇到过元空间溢出吗" tabindex="-1">18、遇到过元空间溢出吗？ <a class="header-anchor" href="#_18、遇到过元空间溢出吗" aria-label="Permalink to &quot;18、遇到过元空间溢出吗？&quot;">​</a></h3><h3 id="_19、如何写一段简单的死锁代码" tabindex="-1">19、如何写一段简单的死锁代码？ <a class="header-anchor" href="#_19、如何写一段简单的死锁代码" aria-label="Permalink to &quot;19、如何写一段简单的死锁代码？&quot;">​</a></h3><h3 id="_20、并发关键字-synchronized" tabindex="-1">20、并发关键字 synchronized ？ <a class="header-anchor" href="#_20、并发关键字-synchronized" aria-label="Permalink to &quot;20、并发关键字 synchronized ？&quot;">​</a></h3><h3 id="_21、jvm-的内存模型是什么" tabindex="-1">21、JVM 的内存模型是什么？ <a class="header-anchor" href="#_21、jvm-的内存模型是什么" aria-label="Permalink to &quot;21、JVM 的内存模型是什么？&quot;">​</a></h3><h3 id="_22、java-堆的结构是什么样子的-什么是堆中的永久代-perm-gen-space" tabindex="-1">22、Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space） <a class="header-anchor" href="#_22、java-堆的结构是什么样子的-什么是堆中的永久代-perm-gen-space" aria-label="Permalink to &quot;22、Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）&quot;">​</a></h3><h3 id="_23、你知道哪些垃圾收集器" tabindex="-1">23、你知道哪些垃圾收集器？ <a class="header-anchor" href="#_23、你知道哪些垃圾收集器" aria-label="Permalink to &quot;23、你知道哪些垃圾收集器？&quot;">​</a></h3><h3 id="_24、synchronized的作用" tabindex="-1">24、synchronized的作用？ <a class="header-anchor" href="#_24、synchronized的作用" aria-label="Permalink to &quot;24、synchronized的作用？&quot;">​</a></h3><h3 id="_25、lock-接口和synchronized-对比同步它有什么优势" tabindex="-1">25、Lock 接口和synchronized 对比同步它有什么优势？ <a class="header-anchor" href="#_25、lock-接口和synchronized-对比同步它有什么优势" aria-label="Permalink to &quot;25、Lock 接口和synchronized 对比同步它有什么优势？&quot;">​</a></h3><h3 id="_26、当一个线程进入某个对象的一个synchronized的实例方法后-其它线程是否可进入此对象的其它方法" tabindex="-1">26、当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？ <a class="header-anchor" href="#_26、当一个线程进入某个对象的一个synchronized的实例方法后-其它线程是否可进入此对象的其它方法" aria-label="Permalink to &quot;26、当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？&quot;">​</a></h3><h3 id="_27、什么是方法区" tabindex="-1">27、什么是方法区 <a class="header-anchor" href="#_27、什么是方法区" aria-label="Permalink to &quot;27、什么是方法区&quot;">​</a></h3><h3 id="_28、什么是自旋" tabindex="-1">28、什么是自旋 <a class="header-anchor" href="#_28、什么是自旋" aria-label="Permalink to &quot;28、什么是自旋&quot;">​</a></h3><h3 id="_29、java-中堆和栈有什么区别" tabindex="-1">29、Java 中堆和栈有什么区别？ <a class="header-anchor" href="#_29、java-中堆和栈有什么区别" aria-label="Permalink to &quot;29、Java 中堆和栈有什么区别？&quot;">​</a></h3><h3 id="_30、你说你做过jvm参数调优和参数配置-请问如何查看jvm系统默认值" tabindex="-1">30、你说你做过JVM参数调优和参数配置，请问如何查看JVM系统默认值 <a class="header-anchor" href="#_30、你说你做过jvm参数调优和参数配置-请问如何查看jvm系统默认值" aria-label="Permalink to &quot;30、你说你做过JVM参数调优和参数配置，请问如何查看JVM系统默认值&quot;">​</a></h3><h3 id="_31、你知道哪些内存分配与回收策略" tabindex="-1">31、你知道哪些内存分配与回收策略？ <a class="header-anchor" href="#_31、你知道哪些内存分配与回收策略" aria-label="Permalink to &quot;31、你知道哪些内存分配与回收策略？&quot;">​</a></h3>',91),E=[n];function s(i,l,B,h,d,p){return e(),r("div",null,E)}const u=a(t,[["render",s]]);export{A as __pageData,u as default};
