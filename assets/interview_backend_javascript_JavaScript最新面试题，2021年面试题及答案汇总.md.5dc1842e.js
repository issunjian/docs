import{_ as a,o as s,c as e,V as n}from"./chunks/framework.c6d8cbec.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/javascript/JavaScript最新面试题，2021年面试题及答案汇总.md","filePath":"interview/backend/javascript/JavaScript最新面试题，2021年面试题及答案汇总.md"}'),o={name:"interview/backend/javascript/JavaScript最新面试题，2021年面试题及答案汇总.md"},l=n(`<h3 id="_1、什么是作用域" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#1%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F" target="_blank" rel="noreferrer">1、什么是作用域？</a> <a class="header-anchor" href="#_1、什么是作用域" aria-label="Permalink to &quot;[1、什么是作用域？](https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript最新面试题，2021年面试题及答案汇总.md#1什么是作用域)&quot;">​</a></h3><p>JavaScript 中的作用域是我们可以有效访问变量或函数的区域。JS 有三种类型的作用域：<strong>全局作用域</strong>、<strong>函数作用域</strong>和<strong>块作用域(ES6)</strong>。</p><p><strong>全局作用域</strong>——在全局命名空间中声明的变量或函数位于全局作用域中，因此在代码中的任何地方都可以访问它们。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">//global namespace</span></span>
<span class="line"><span style="color:#f6f6f4;">var g = &quot;global&quot;;</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">function globalFunc(){</span></span>
<span class="line"><span style="color:#f6f6f4;">  function innerFunc(){</span></span>
<span class="line"><span style="color:#f6f6f4;">    console.log(g); // can access &quot;g&quot; because &quot;g&quot; is a global variable</span></span>
<span class="line"><span style="color:#f6f6f4;">  }</span></span>
<span class="line"><span style="color:#f6f6f4;"> innerFunc();</span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">//global namespace</span></span>
<span class="line"><span style="color:#24292e;">var g = &quot;global&quot;;</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">function globalFunc(){</span></span>
<span class="line"><span style="color:#24292e;">  function innerFunc(){</span></span>
<span class="line"><span style="color:#24292e;">    console.log(g); // can access &quot;g&quot; because &quot;g&quot; is a global variable</span></span>
<span class="line"><span style="color:#24292e;">  }</span></span>
<span class="line"><span style="color:#24292e;"> innerFunc();</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p><strong>函数作用域</strong>——在函数中声明的变量、函数和参数可以在函数内部访问，但不能在函数外部访问。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">function myFavoriteFunc(a) {</span></span>
<span class="line"><span style="color:#f6f6f4;">  if (true) {</span></span>
<span class="line"><span style="color:#f6f6f4;">    var b = &quot;Hello &quot; + a;</span></span>
<span class="line"><span style="color:#f6f6f4;">  }</span></span>
<span class="line"><span style="color:#f6f6f4;">  return b;</span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">myFavoriteFunc(&quot;World&quot;);</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">console.log(a); // Throws a ReferenceError &quot;a&quot; is not defined</span></span>
<span class="line"><span style="color:#f6f6f4;">console.log(b); // does not continue here</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">function myFavoriteFunc(a) {</span></span>
<span class="line"><span style="color:#24292e;">  if (true) {</span></span>
<span class="line"><span style="color:#24292e;">    var b = &quot;Hello &quot; + a;</span></span>
<span class="line"><span style="color:#24292e;">  }</span></span>
<span class="line"><span style="color:#24292e;">  return b;</span></span>
<span class="line"><span style="color:#24292e;">}</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">myFavoriteFunc(&quot;World&quot;);</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">console.log(a); // Throws a ReferenceError &quot;a&quot; is not defined</span></span>
<span class="line"><span style="color:#24292e;">console.log(b); // does not continue here</span></span></code></pre></div><ul><li><strong>块作用域</strong>-在块<code>{}</code>中声明的变量（<code>let，const</code>）只能在其中访问。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">function testBlock(){</span></span>
<span class="line"><span style="color:#f6f6f4;">   if(true){</span></span>
<span class="line"><span style="color:#f6f6f4;">     let z = 5;</span></span>
<span class="line"><span style="color:#f6f6f4;">   }</span></span>
<span class="line"><span style="color:#f6f6f4;">   return z; </span></span>
<span class="line"><span style="color:#f6f6f4;"> }</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;"> testBlock(); // Throws a ReferenceError &quot;z&quot; is not defined</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">function testBlock(){</span></span>
<span class="line"><span style="color:#24292e;">   if(true){</span></span>
<span class="line"><span style="color:#24292e;">     let z = 5;</span></span>
<span class="line"><span style="color:#24292e;">   }</span></span>
<span class="line"><span style="color:#24292e;">   return z; </span></span>
<span class="line"><span style="color:#24292e;"> }</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;"> testBlock(); // Throws a ReferenceError &quot;z&quot; is not defined</span></span></code></pre></div><p>作用域也是一组用于查找变量的规则。如果变量在当前作用域中不存在，它将向外部作用域中查找并搜索，如果该变量不存在，它将再次查找直到到达全局作用域，如果找到，则可以使用它，否则引发错误，这种查找过程也称为<strong>作用域链</strong>。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">/* 作用域链</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;"> 内部作用域-&gt;外部作用域-&gt; 全局作用域</span></span>
<span class="line"><span style="color:#f6f6f4;">*/</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">// 全局作用域</span></span>
<span class="line"><span style="color:#f6f6f4;">var variable1 = &quot;Comrades&quot;;   </span></span>
<span class="line"><span style="color:#f6f6f4;">var variable2 = &quot;Sayonara&quot;;</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">function outer(){</span></span>
<span class="line"><span style="color:#f6f6f4;">// 外部作用域</span></span>
<span class="line"><span style="color:#f6f6f4;">var variable1 = &quot;World&quot;;</span></span>
<span class="line"><span style="color:#f6f6f4;">function inner(){</span></span>
<span class="line"><span style="color:#f6f6f4;">// 内部作用域</span></span>
<span class="line"><span style="color:#f6f6f4;">  var variable2 = &quot;Hello&quot;;</span></span>
<span class="line"><span style="color:#f6f6f4;">  console.log(variable2 + &quot; &quot; + variable1);</span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span>
<span class="line"><span style="color:#f6f6f4;">inner();</span></span>
<span class="line"><span style="color:#f6f6f4;">}  </span></span>
<span class="line"><span style="color:#f6f6f4;">outer(); // Hello World</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">/* 作用域链</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;"> 内部作用域-&gt;外部作用域-&gt; 全局作用域</span></span>
<span class="line"><span style="color:#24292e;">*/</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">// 全局作用域</span></span>
<span class="line"><span style="color:#24292e;">var variable1 = &quot;Comrades&quot;;   </span></span>
<span class="line"><span style="color:#24292e;">var variable2 = &quot;Sayonara&quot;;</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">function outer(){</span></span>
<span class="line"><span style="color:#24292e;">// 外部作用域</span></span>
<span class="line"><span style="color:#24292e;">var variable1 = &quot;World&quot;;</span></span>
<span class="line"><span style="color:#24292e;">function inner(){</span></span>
<span class="line"><span style="color:#24292e;">// 内部作用域</span></span>
<span class="line"><span style="color:#24292e;">  var variable2 = &quot;Hello&quot;;</span></span>
<span class="line"><span style="color:#24292e;">  console.log(variable2 + &quot; &quot; + variable1);</span></span>
<span class="line"><span style="color:#24292e;">}</span></span>
<span class="line"><span style="color:#24292e;">inner();</span></span>
<span class="line"><span style="color:#24292e;">}  </span></span>
<span class="line"><span style="color:#24292e;">outer(); // Hello World</span></span></code></pre></div><h3 id="_2、ajax-和-jsonp" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#2ajax-%E5%92%8C-jsonp-" target="_blank" rel="noreferrer">2、ajax 和 jsonp ？</a> <a class="header-anchor" href="#_2、ajax-和-jsonp" aria-label="Permalink to &quot;[2、ajax 和 jsonp ？](https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript最新面试题，2021年面试题及答案汇总.md#2ajax-和-jsonp-)&quot;">​</a></h3><p><strong>ajax和jsonp的区别：</strong></p><p>相同点：都是请求一个url</p><p>不同点：ajax的核心是通过xmlHttpRequest获取内容</p><p>jsonp的核心则是动态添加</p><h3 id="_3、js延迟加载的方式有哪些" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#3js%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B" target="_blank" rel="noreferrer">3、js延迟加载的方式有哪些？</a> <a class="header-anchor" href="#_3、js延迟加载的方式有哪些" aria-label="Permalink to &quot;[3、js延迟加载的方式有哪些？](https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript最新面试题，2021年面试题及答案汇总.md#3js延迟加载的方式有哪些)&quot;">​</a></h3><p><code>defer</code>和<code>async</code>、动态创建<code>DOM</code>方式（用得最多）、按需异步载入<code>js</code></p><h3 id="_4、object-seal-和-object-freeze-方法之间有什么区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#4objectseal-%E5%92%8C-objectfreeze-%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">4、Object.seal 和 Object.freeze 方法之间有什么区别？</a> <a class="header-anchor" href="#_4、object-seal-和-object-freeze-方法之间有什么区别" aria-label="Permalink to &quot;[4、Object.seal 和 Object.freeze 方法之间有什么区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript最新面试题，2021年面试题及答案汇总.md#4objectseal-和-objectfreeze-方法之间有什么区别)&quot;">​</a></h3><p><strong>Object.freeze()</strong></p><p><code>Object.freeze()</code> 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改<code>。freeze()</code> 返回和传入的参数相同的对象。</p><p><strong>Object.seal()</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">Object.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Object.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。</span></span></code></pre></div><p>方法的相同点：</p><p><strong>1、</strong> ES5新增。</p><p><strong>2、</strong> 对象不可能扩展，也就是不能再添加新的属性或者方法。</p><p><strong>3、</strong> 对象已有属性不允许被删除。</p><p><strong>4、</strong> 对象属性特性不可以重新配置。</p><p>方法不同点：</p><ul><li><code>Object.seal</code>方法生成的密封对象，如果属性是可写的，那么可以修改属性值。<code>* Object.freeze</code>方法生成的冻结对象，属性都是不可写的，也就是属性值无法更改。</li></ul><h3 id="_5、jq中如何实现多库并存" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#5jq%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%BA%93%E5%B9%B6%E5%AD%98" target="_blank" rel="noreferrer">5、Jq中如何实现多库并存?</a> <a class="header-anchor" href="#_5、jq中如何实现多库并存" aria-label="Permalink to &quot;[5、Jq中如何实现多库并存?](https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript最新面试题，2021年面试题及答案汇总.md#5jq中如何实现多库并存)&quot;">​</a></h3><p>Noconfict 多库共存就是“$ ”符号的冲突。</p><p><strong>方法一</strong>：</p><p>利用jQuery的实用函数$$.noConflict();这个函数归还$$的名称控制权给另一个库，因此可以在页面上使用其他库。这时，我们可以用&quot;jQuery &quot;这个名称调用jQuery的功能。 $.noConflict();</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">jQuery(&#39;\\#id&#39;).hide();</span></span>
<span class="line"><span style="color:#f6f6f4;">.....</span></span>
<span class="line"><span style="color:#f6f6f4;">//或者给jQuery一个别名</span></span>
<span class="line"><span style="color:#f6f6f4;">var $j=jQuery</span></span>
<span class="line"><span style="color:#f6f6f4;">$j(&#39;\\#id&#39;).hide();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">jQuery(&#39;\\#id&#39;).hide();</span></span>
<span class="line"><span style="color:#24292e;">.....</span></span>
<span class="line"><span style="color:#24292e;">//或者给jQuery一个别名</span></span>
<span class="line"><span style="color:#24292e;">var $j=jQuery</span></span>
<span class="line"><span style="color:#24292e;">$j(&#39;\\#id&#39;).hide();</span></span></code></pre></div><p><strong>方法二</strong>： <code>(function($)\\{\\})(jQuery)</code></p><p><strong>方法三</strong>： <code>jQuery(function($)\\{\\})</code></p><p>通过传递一个函数作为jQuery的参数，因此把这个函数声明为就绪函数。 我们声明$为就绪函数的参数，因为jQuery总是吧jQuery对象的引用作为第一个参数传递，所以就保证了函数的执行。</p><h3 id="_6、怎么理解promise对象" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#6%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3promise%E5%AF%B9%E8%B1%A1" target="_blank" rel="noreferrer">6、怎么理解Promise对象？</a> <a class="header-anchor" href="#_6、怎么理解promise对象" aria-label="Permalink to &quot;[6、怎么理解Promise对象？](https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript最新面试题，2021年面试题及答案汇总.md#6怎么理解promise对象)&quot;">​</a></h3><p><strong><code>Promise</code>对象有如下两个特点：</strong></p><p><strong>1、</strong> 对象的状态不受外界影响。<code>Promise</code>对象共有三种状态<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>。状态值只会被异步结果决定，其他任何操作无法改变。</p><p><strong>2、</strong> 状态一旦成型，就不会再变，且任何时候都可得到这个结果。状态值会由<code>pending</code>变为<code>fulfilled</code>或<code>rejected</code>，这时即为<code>resolved</code>。</p><p><strong>Promise的缺点有如下三个缺点：</strong></p><p><strong>1、</strong> <code>Promise</code>一旦执行便无法被取消；</p><p><strong>2、</strong> 不可设置回调函数，其内部发生的错误无法捕获；</p><p><strong>3、</strong> 当处于<code>pending</code>状态时，无法得知其具体发展到了哪个阶段。</p><p><strong><code>Pomise</code>中常用的方法有：</strong></p><p><strong>1、</strong> <code>Promise.prototype.then()</code>：<code>Promise</code>实例的状态发生改变时，会调用<code>then</code>内部的回调函数。<code>then</code>方法接受两个参数（第一个为<code>resolved</code>状态时时执行的回调，第一个为<code>rejected</code>状态时时执行的回调）</p><p><strong>2、</strong> <code>Promise.prototype.catch()</code>：<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><h3 id="_7、in-运算符和-object-hasownproperty-方法有什么区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#7in-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C-objecthasownproperty-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">7、<code>in</code> 运算符和 <code>Object.hasOwnProperty</code> 方法有什么区别？</a> <a class="header-anchor" href="#_7、in-运算符和-object-hasownproperty-方法有什么区别" aria-label="Permalink to &quot;[7、\`in\` 运算符和 \`Object.hasOwnProperty\` 方法有什么区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript最新面试题，2021年面试题及答案汇总.md#7in-运算符和-objecthasownproperty-方法有什么区别)&quot;">​</a></h3><p><strong>hasOwnPropert方法</strong></p><p><code>hasOwnPropert()</code>方法返回值是一个布尔值，指示对象自身属性中是否具有指定的属性，因此这个方法会忽略掉那些从原型链上继承到的属性。</p><p>看下面的例子：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">Object.prototype.phone= &#39;15345025546&#39;;</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">let obj = {</span></span>
<span class="line"><span style="color:#f6f6f4;">  name: &#39;kyle&#39;,</span></span>
<span class="line"><span style="color:#f6f6f4;">  age: &#39;28&#39;</span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span>
<span class="line"><span style="color:#f6f6f4;">console.log(obj.hasOwnProperty(&#39;phone&#39;)) // false</span></span>
<span class="line"><span style="color:#f6f6f4;">console.log(obj.hasOwnProperty(&#39;name&#39;)) // true</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Object.prototype.phone= &#39;15345025546&#39;;</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">let obj = {</span></span>
<span class="line"><span style="color:#24292e;">  name: &#39;kyle&#39;,</span></span>
<span class="line"><span style="color:#24292e;">  age: &#39;28&#39;</span></span>
<span class="line"><span style="color:#24292e;">}</span></span>
<span class="line"><span style="color:#24292e;">console.log(obj.hasOwnProperty(&#39;phone&#39;)) // false</span></span>
<span class="line"><span style="color:#24292e;">console.log(obj.hasOwnProperty(&#39;name&#39;)) // true</span></span></code></pre></div><p>可以看到，如果在函数原型上定义一个变量<code>phone</code>，<code>hasOwnProperty</code>方法会直接忽略掉。</p><p><strong>in 运算符</strong></p><p>如果指定的属性在指定的对象或其原型链中，则<code>in</code> 运算符返回<code>true</code>。</p><p>还是用上面的例子来演示：</p><p><code>console.log(&#39;phone&#39; in obj) // true</code></p><p>可以看到<code>in</code>运算符会检查它或者其原型链是否包含具有指定名称的属性。</p><h3 id="_8、同步和异步的区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#8%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">8、同步和异步的区别?</a> <a class="header-anchor" href="#_8、同步和异步的区别" aria-label="Permalink to &quot;[8、同步和异步的区别?](https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript最新面试题，2021年面试题及答案汇总.md#8同步和异步的区别)&quot;">​</a></h3><p><strong>1、</strong> 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</p><p><strong>2、</strong> 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</p><h3 id="_9、说说严格模式的限制" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#9%E8%AF%B4%E8%AF%B4%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6" target="_blank" rel="noreferrer">9、说说严格模式的限制</a> <a class="header-anchor" href="#_9、说说严格模式的限制" aria-label="Permalink to &quot;[9、说说严格模式的限制](https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript最新面试题，2021年面试题及答案汇总.md#9说说严格模式的限制)&quot;">​</a></h3><p><strong>1、</strong> 变量必须声明后再使用</p><p><strong>2、</strong> 函数的参数不能有同名属性，否则报错</p><p><strong>3、</strong> 不能使用<code>with</code>语句</p><p><strong>4、</strong> 禁止<code>this</code>指向全局对象</p><h3 id="_10、常见兼容性问题" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#10%E5%B8%B8%E8%A7%81%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98" target="_blank" rel="noreferrer">10、常见兼容性问题？</a> <a class="header-anchor" href="#_10、常见兼容性问题" aria-label="Permalink to &quot;[10、常见兼容性问题？](https://gitee.com/souyunku/DevBooks/blob/master/docs/JavaScript/JavaScript最新面试题，2021年面试题及答案汇总.md#10常见兼容性问题)&quot;">​</a></h3><p><strong>1、</strong> <code>png24</code>位的图片在iE6浏览器上出现背景，解决方案是做成<code>PNG8</code></p><p><strong>2、</strong> 浏览器默认的<code>margin</code>和<code>padding</code>不同。解决方案是加一个全局的<code>*{margin:0;padding:0;}</code>来统一,，但是全局效率很低，一般是如下这样解决：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p{</span></span>
<span class="line"><span style="color:#f6f6f4;">    margin:0;</span></span>
<span class="line"><span style="color:#f6f6f4;">    padding:0;</span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p{</span></span>
<span class="line"><span style="color:#24292e;">    margin:0;</span></span>
<span class="line"><span style="color:#24292e;">    padding:0;</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p><code>IE</code>下,<code>event</code>对象有<code>x</code>,<code>y</code>属性,但是没有<code>pageX</code>,<code>pageY</code>属性</p><p><code>Firefox</code>下,<code>event</code>对象有<code>pageX</code>,<code>pageY</code>属性,但是没有<code>x,y</code>属性.</p><h3 id="_11、jq绑定事件的几种方式-on-bind" tabindex="-1">11、Jq绑定事件的几种方式？on bind ? <a class="header-anchor" href="#_11、jq绑定事件的几种方式-on-bind" aria-label="Permalink to &quot;11、Jq绑定事件的几种方式？on bind ?&quot;">​</a></h3><h3 id="_12、call-apply-两者之间的区别" tabindex="-1">12、call &amp; apply 两者之间的区别### <a class="header-anchor" href="#_12、call-apply-两者之间的区别" aria-label="Permalink to &quot;12、call &amp; apply 两者之间的区别###&quot;">​</a></h3><h3 id="_13、同步和异步的区别" tabindex="-1">13、同步和异步的区别? <a class="header-anchor" href="#_13、同步和异步的区别" aria-label="Permalink to &quot;13、同步和异步的区别?&quot;">​</a></h3><h3 id="_14、什么是-event-currenttarget" tabindex="-1">14、什么是 event.currentTarget？？ <a class="header-anchor" href="#_14、什么是-event-currenttarget" aria-label="Permalink to &quot;14、什么是 event.currentTarget？？&quot;">​</a></h3><h3 id="_15、typeof-typeof-返回数据类型是" tabindex="-1">15、typeof？typeof [ ]返回数据类型是？ <a class="header-anchor" href="#_15、typeof-typeof-返回数据类型是" aria-label="Permalink to &quot;15、typeof？typeof [ ]返回数据类型是？&quot;">​</a></h3><h3 id="_16、如何知道是否在元素中使用了event-preventdefault-方法" tabindex="-1">16、如何知道是否在元素中使用了<code>event.preventDefault()</code>方法？ <a class="header-anchor" href="#_16、如何知道是否在元素中使用了event-preventdefault-方法" aria-label="Permalink to &quot;16、如何知道是否在元素中使用了\`event.preventDefault()\`方法？&quot;">​</a></h3><h3 id="_17、promise-是什么" tabindex="-1">17、Promise 是什么？ <a class="header-anchor" href="#_17、promise-是什么" aria-label="Permalink to &quot;17、Promise 是什么？&quot;">​</a></h3><h3 id="_18、eval是做什么的" tabindex="-1">18、eval是做什么的？ <a class="header-anchor" href="#_18、eval是做什么的" aria-label="Permalink to &quot;18、eval是做什么的？&quot;">​</a></h3><h3 id="_19、判断数据类型的方法有哪些" tabindex="-1">19、判断数据类型的方法有哪些？ <a class="header-anchor" href="#_19、判断数据类型的方法有哪些" aria-label="Permalink to &quot;19、判断数据类型的方法有哪些？&quot;">​</a></h3><h3 id="_20、-和-有什么区别" tabindex="-1">20、== 和 === 有什么区别？ <a class="header-anchor" href="#_20、-和-有什么区别" aria-label="Permalink to &quot;20、== 和 === 有什么区别？&quot;">​</a></h3><h3 id="_21、javascript有哪些方法定义对象" tabindex="-1">21、javascript有哪些方法定义对象 <a class="header-anchor" href="#_21、javascript有哪些方法定义对象" aria-label="Permalink to &quot;21、javascript有哪些方法定义对象&quot;">​</a></h3><h3 id="_22、如何通过原生js-判断一个元素当前是显示还是隐藏状态" tabindex="-1">22、如何通过原生js 判断一个元素当前是显示还是隐藏状态? <a class="header-anchor" href="#_22、如何通过原生js-判断一个元素当前是显示还是隐藏状态" aria-label="Permalink to &quot;22、如何通过原生js 判断一个元素当前是显示还是隐藏状态?&quot;">​</a></h3><h3 id="_23、与深拷贝有何区别-如何实现" tabindex="-1">23、与深拷贝有何区别？如何实现？ <a class="header-anchor" href="#_23、与深拷贝有何区别-如何实现" aria-label="Permalink to &quot;23、与深拷贝有何区别？如何实现？&quot;">​</a></h3><h3 id="_24、事件流-事件捕获-事件冒泡" tabindex="-1">24、事件流?事件捕获？事件冒泡？ <a class="header-anchor" href="#_24、事件流-事件捕获-事件冒泡" aria-label="Permalink to &quot;24、事件流?事件捕获？事件冒泡？&quot;">​</a></h3><h3 id="_25、ajax-是什么" tabindex="-1">25、ajax 是什么? <a class="header-anchor" href="#_25、ajax-是什么" aria-label="Permalink to &quot;25、ajax 是什么?&quot;">​</a></h3><h3 id="_26、变量作用域" tabindex="-1">26、变量作用域? <a class="header-anchor" href="#_26、变量作用域" aria-label="Permalink to &quot;26、变量作用域?&quot;">​</a></h3><h3 id="_27、promise" tabindex="-1">27、promise### <a class="header-anchor" href="#_27、promise" aria-label="Permalink to &quot;27、promise###&quot;">​</a></h3><h3 id="_28、什么是事件捕获" tabindex="-1">28、什么是事件捕获？ <a class="header-anchor" href="#_28、什么是事件捕获" aria-label="Permalink to &quot;28、什么是事件捕获？&quot;">​</a></h3><h3 id="_29、如何解决跨域问题" tabindex="-1">29、如何解决跨域问题? <a class="header-anchor" href="#_29、如何解决跨域问题" aria-label="Permalink to &quot;29、如何解决跨域问题?&quot;">​</a></h3>`,92),p=[l];function t(c,r,i,d,f,u){return s(),e("div",null,p)}const y=a(o,[["render",t]]);export{E as __pageData,y as default};
