import{_ as s,o as a,c as n,V as l}from"./chunks/framework.c6d8cbec.js";const d=JSON.parse('{"title":"Java TreeMap详解：从源码分析到实践应用","description":"本文详细解析了 Java TreeMap 的实现原理、功能特点以及源码，为您提供了 TreeMap 的实际应用示例和性能优化建议。阅读本文，将帮助您更深入地理解 TreeMap，从而在实际编程中充分发挥其优势。","frontmatter":{"title":"Java TreeMap详解：从源码分析到实践应用","shortTitle":"TreeMap详解（附源码）","category":["Java核心"],"tag":["集合框架（容器）"],"description":"本文详细解析了 Java TreeMap 的实现原理、功能特点以及源码，为您提供了 TreeMap 的实际应用示例和性能优化建议。阅读本文，将帮助您更深入地理解 TreeMap，从而在实际编程中充分发挥其优势。","head":[["meta",{"name":"keywords","content":"Java,TreeMap,java treemap, 源码分析, 实现原理"}]]},"headers":[],"relativePath":"backend/tobetter/collection/treemap.md","filePath":"backend/tobetter/collection/treemap.md"}'),p={name:"backend/tobetter/collection/treemap.md"},o=l(`<h1 id="_6-11-treemap详解-附源码" tabindex="-1">6.11 TreeMap详解（附源码） <a class="header-anchor" href="#_6-11-treemap详解-附源码" aria-label="Permalink to &quot;6.11 TreeMap详解（附源码）&quot;">​</a></h1><blockquote><p>下面有请王老师上台，来给大家讲一讲 TreeMap，鼓掌了！</p></blockquote><p>之前 <a href="https://tobebetterjavaer.com/collection/linkedhashmap.html" target="_blank" rel="noreferrer">LinkedHashMap</a> 那篇文章里提到过了，HashMap 是无序的，所以有了 LinkedHashMap，加上了双向链表后，就可以保持元素的插入顺序和访问顺序，那 TreeMap 呢？</p><p>TreeMap 由红黑树实现，可以保持元素的自然顺序，或者实现了 Comparator 接口的自定义顺序。</p><p>可能有些同学不了解红黑树，我这里来普及一下：</p><blockquote><p>红黑树（英语：Red–black tree）是一种自平衡的二叉查找树（Binary Search Tree），结构复杂，但却有着良好的性能，完成查找、插入和删除的<a href="https://tobebetterjavaer.com/collection/time-complexity.html" target="_blank" rel="noreferrer">时间复杂度</a>均为 log(n)。</p></blockquote><p>二叉查找树是一种常见的树形结构，它的每个节点都包含一个键值对。每个节点的左子树节点的键值小于该节点的键值，右子树节点的键值大于该节点的键值，这个特性使得二叉查找树非常适合进行数据的查找和排序操作。</p><p>下面是一个简单的手绘图，展示了一个二叉查找树的结构：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">8</span></span>
<span class="line"><span style="color:#f6f6f4;">      /   \\</span></span>
<span class="line"><span style="color:#f6f6f4;">     3     10</span></span>
<span class="line"><span style="color:#f6f6f4;">    / \\      \\</span></span>
<span class="line"><span style="color:#f6f6f4;">   1   6     14</span></span>
<span class="line"><span style="color:#f6f6f4;">      / \\    /</span></span>
<span class="line"><span style="color:#f6f6f4;">     4   7  13</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">8</span></span>
<span class="line"><span style="color:#24292e;">      /   \\</span></span>
<span class="line"><span style="color:#24292e;">     3     10</span></span>
<span class="line"><span style="color:#24292e;">    / \\      \\</span></span>
<span class="line"><span style="color:#24292e;">   1   6     14</span></span>
<span class="line"><span style="color:#24292e;">      / \\    /</span></span>
<span class="line"><span style="color:#24292e;">     4   7  13</span></span></code></pre></div><p>在上面这个二叉查找树中，根节点是 8，左子树节点包括 3、1、6、4 和 7，右子树节点包括 10、14 和 13。</p><ul><li>3&lt;8&lt;10</li><li>1&lt;3&lt;6</li><li>4&lt;6&lt;7</li><li>10&lt;14</li><li>13&lt;14</li></ul><p>这是一颗典型的二叉查找树：</p><ul><li>1）左子树上所有节点的值均小于或等于它的根结点的值。</li><li>2）右子树上所有节点的值均大于或等于它的根结点的值。</li><li>3）左、右子树也分别为二叉查找树。</li></ul><p>二叉查找树用来查找非常方面，从根节点开始遍历，如果当前节点的键值等于要查找的键值，则查找成功；如果要查找的键值小于当前节点的键值，则继续遍历左子树；如果要查找的键值大于当前节点的键值，则继续遍历右子树。如果遍历到叶子节点仍然没有找到，则查找失败。</p><p>插入操作也非常简单，从根节点开始遍历，如果要插入的键值小于当前节点的键值，则将其插入到左子树中；如果要插入的键值大于当前节点的键值，则将其插入到右子树中。如果要插入的键值已经存在于树中，则更新该节点的值。</p><p>删除操作稍微复杂一些，需要考虑多种情况，包括要删除的节点是叶子节点、要删除的节点只有一个子节点、要删除的节点有两个子节点等等。</p><p>总之，二叉查找树是一种非常常用的数据结构，它可以帮助我们实现数据的查找、排序和删除等操作。</p><p>理解二叉查找树了吧？</p><p>不过，二叉查找树有一个明显的不足，就是容易变成瘸子，就是一侧多，一侧少，比如说这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">6</span></span>
<span class="line"><span style="color:#f6f6f4;">      /   \\</span></span>
<span class="line"><span style="color:#f6f6f4;">     4     8</span></span>
<span class="line"><span style="color:#f6f6f4;">    /     / \\</span></span>
<span class="line"><span style="color:#f6f6f4;">   3     7   9</span></span>
<span class="line"><span style="color:#f6f6f4;">  /</span></span>
<span class="line"><span style="color:#f6f6f4;"> 1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">6</span></span>
<span class="line"><span style="color:#24292e;">      /   \\</span></span>
<span class="line"><span style="color:#24292e;">     4     8</span></span>
<span class="line"><span style="color:#24292e;">    /     / \\</span></span>
<span class="line"><span style="color:#24292e;">   3     7   9</span></span>
<span class="line"><span style="color:#24292e;">  /</span></span>
<span class="line"><span style="color:#24292e;"> 1</span></span></code></pre></div><p>在上面这个不平衡的二叉查找树中，左子树比右子树高。根节点是 6，左子树节点包括 4、3 和 1，右子树节点包括 8、7 和 9。</p><p>由于左子树比右子树高，这个不平衡的二叉查找树可能会导致查找、插入和删除操作的效率下降。</p><p>来一个更极端的情况。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">1</span></span>
<span class="line"><span style="color:#f6f6f4;">     \\</span></span>
<span class="line"><span style="color:#f6f6f4;">      2</span></span>
<span class="line"><span style="color:#f6f6f4;">       \\</span></span>
<span class="line"><span style="color:#f6f6f4;">        3</span></span>
<span class="line"><span style="color:#f6f6f4;">         \\</span></span>
<span class="line"><span style="color:#f6f6f4;">          4</span></span>
<span class="line"><span style="color:#f6f6f4;">           \\</span></span>
<span class="line"><span style="color:#f6f6f4;">            5</span></span>
<span class="line"><span style="color:#f6f6f4;">             \\</span></span>
<span class="line"><span style="color:#f6f6f4;">              6</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1</span></span>
<span class="line"><span style="color:#24292e;">     \\</span></span>
<span class="line"><span style="color:#24292e;">      2</span></span>
<span class="line"><span style="color:#24292e;">       \\</span></span>
<span class="line"><span style="color:#24292e;">        3</span></span>
<span class="line"><span style="color:#24292e;">         \\</span></span>
<span class="line"><span style="color:#24292e;">          4</span></span>
<span class="line"><span style="color:#24292e;">           \\</span></span>
<span class="line"><span style="color:#24292e;">            5</span></span>
<span class="line"><span style="color:#24292e;">             \\</span></span>
<span class="line"><span style="color:#24292e;">              6</span></span></code></pre></div><p>在上面这个极度不平衡的二叉查找树中，所有节点都只有一个右子节点，根节点是 1，右子树节点包括 2、3、4、5 和 6。</p><p>这种极度不平衡的二叉查找树会导致查找、插入和删除操作的效率急剧下降，因为每次操作都只能在右子树中进行，而左子树几乎没有被利用到。</p><p>查找的效率就要从 log(n) 变成 o(n) 了（戳<a href="https://tobebetterjavaer.com/collection/time-complexity.html" target="_blank" rel="noreferrer">这里</a>了解时间复杂度），对吧？</p><p>必须要平衡一下，对吧？于是就有了平衡二叉树，左右两个子树的高度差的绝对值不超过 1，就像下图这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">8</span></span>
<span class="line"><span style="color:#f6f6f4;">      /   \\</span></span>
<span class="line"><span style="color:#f6f6f4;">     4     12</span></span>
<span class="line"><span style="color:#f6f6f4;">    / \\    / \\</span></span>
<span class="line"><span style="color:#f6f6f4;">   2   6  10  14</span></span>
<span class="line"><span style="color:#f6f6f4;">      / \\    / \\</span></span>
<span class="line"><span style="color:#f6f6f4;">     5   7  13  15</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">8</span></span>
<span class="line"><span style="color:#24292e;">      /   \\</span></span>
<span class="line"><span style="color:#24292e;">     4     12</span></span>
<span class="line"><span style="color:#24292e;">    / \\    / \\</span></span>
<span class="line"><span style="color:#24292e;">   2   6  10  14</span></span>
<span class="line"><span style="color:#24292e;">      / \\    / \\</span></span>
<span class="line"><span style="color:#24292e;">     5   7  13  15</span></span></code></pre></div><p>根节点是 8，左子树节点包括 4、2、6、5 和 7，右子树节点包括 12、10、14、13 和 15。左子树和右子树的高度差不超过1，因此它是一个平衡二叉查找树。</p><p>平衡二叉树就像是一棵树形秤，它的左右两边的重量要尽可能的平衡。当我们往平衡二叉树中插入一个节点时，平衡二叉树会自动调整节点的位置，以保证树的左右两边的高度差不超过1。类似地，当我们删除一个节点时，平衡二叉树也会自动调整节点的位置，以保证树的左右两边的高度差不超过1。</p><p>常见的平衡二叉树包括AVL树、红黑树等等，它们都是通过旋转操作来调整树的平衡，使得左子树和右子树的高度尽可能接近。</p><p>AVL树的示意图：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">8</span></span>
<span class="line"><span style="color:#f6f6f4;">         /   \\</span></span>
<span class="line"><span style="color:#f6f6f4;">        4     12</span></span>
<span class="line"><span style="color:#f6f6f4;">       / \\   /  \\</span></span>
<span class="line"><span style="color:#f6f6f4;">      2   6 10  14</span></span>
<span class="line"><span style="color:#f6f6f4;">         / \\</span></span>
<span class="line"><span style="color:#f6f6f4;">        5   7</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">8</span></span>
<span class="line"><span style="color:#24292e;">         /   \\</span></span>
<span class="line"><span style="color:#24292e;">        4     12</span></span>
<span class="line"><span style="color:#24292e;">       / \\   /  \\</span></span>
<span class="line"><span style="color:#24292e;">      2   6 10  14</span></span>
<span class="line"><span style="color:#24292e;">         / \\</span></span>
<span class="line"><span style="color:#24292e;">        5   7</span></span></code></pre></div><p>AVL树是一种高度平衡的二叉查找树，它要求左子树和右子树的高度差不超过1。由于AVL树的平衡度比较高，因此在进行插入和删除操作时需要进行更多的旋转操作来保持平衡，但是在查找操作时效率较高。AVL树适用于读操作比较多的场景。</p><p>例如，对于一个需要频繁进行查找操作的场景，如字典树、哈希表等数据结构，可以使用AVL树来进行优化。另外，AVL树也适用于需要保证数据有序性的场景，如数据库中的索引。</p><p>AVL树最初由两位苏联的计算机科学家，Adelson-Velskii和Landis，于1962年提出。因此，AVL树就以他们两人名字的首字母缩写命名了。</p><p>AVL树的发明对计算机科学的发展有着重要的影响，不仅为后来的平衡二叉树提供了基础，而且为其他领域的数据结构和算法提供了启示。</p><p>红黑树的示意图（R 即 Red「红」、B 即 Black「黑」）：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">8B</span></span>
<span class="line"><span style="color:#f6f6f4;">         /   \\</span></span>
<span class="line"><span style="color:#f6f6f4;">        4R    12R</span></span>
<span class="line"><span style="color:#f6f6f4;">       / \\   /  \\</span></span>
<span class="line"><span style="color:#f6f6f4;">      2B 6B 10B 14B</span></span>
<span class="line"><span style="color:#f6f6f4;">         / \\</span></span>
<span class="line"><span style="color:#f6f6f4;">        5R 7R</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">8B</span></span>
<span class="line"><span style="color:#24292e;">         /   \\</span></span>
<span class="line"><span style="color:#24292e;">        4R    12R</span></span>
<span class="line"><span style="color:#24292e;">       / \\   /  \\</span></span>
<span class="line"><span style="color:#24292e;">      2B 6B 10B 14B</span></span>
<span class="line"><span style="color:#24292e;">         / \\</span></span>
<span class="line"><span style="color:#24292e;">        5R 7R</span></span></code></pre></div><p>红黑树，顾名思义，就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持二叉树的平衡，它要求任意一条路径上的黑色节点数目相同，同时还需要满足一些其他特定的条件，如红色节点的父节点必须为黑色节点等。</p><ul><li>1）每个节点都只能是红色或者黑色</li><li>2）根节点是黑色</li><li>3）每个叶节点（NIL 节点，空节点）是黑色的。</li><li>4）如果一个节点是红色的，则它两个子节点都是黑色的。也就是说在一条路径上不能出现相邻的两个红色节点。</li><li>5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ul><p>由于红黑树的平衡度比AVL树稍低，因此在进行插入和删除操作时需要进行的旋转操作较少，但是在查找操作时效率仍然较高。红黑树适用于读写操作比较均衡的场景。</p><p>那，关于红黑树，同学们就先了解到这，脑子里有个大概的印象，知道 TreeMap 是个什么玩意。</p><h3 id="_01、自然顺序" tabindex="-1">01、自然顺序 <a class="header-anchor" href="#_01、自然顺序" aria-label="Permalink to &quot;01、自然顺序&quot;">​</a></h3><p>默认情况下，TreeMap 是根据 key 的自然顺序排列的。比如说整数，就是升序，1、2、3、4、5。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">TreeMap</span><span style="color:#F6F6F4;">&lt;Integer,String&gt; mapInt </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">TreeMap</span><span style="color:#F6F6F4;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#F6F6F4;">mapInt.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">3</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">mapInt.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">2</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">mapInt.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">mapInt.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">5</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">mapInt.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">4</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(mapInt);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">TreeMap&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; mapInt </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> TreeMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">mapInt.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">mapInt.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">mapInt.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">mapInt.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">mapInt.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(mapInt);</span></span></code></pre></div><p>输出结果如下所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">{1=沉默王二, 2=沉默王二, 3=沉默王二, 4=沉默王二, 5=沉默王二}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">{1=沉默王二, 2=沉默王二, 3=沉默王二, 4=沉默王二, 5=沉默王二}</span></span></code></pre></div><p>TreeMap 是怎么做到的呢？想一探究竟，就得上源码了，来看 TreeMap 的 <code>put()</code> 方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">public</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">V</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">K</span><span style="color:#F6F6F4;"> key, </span><span style="color:#97E1F1;font-style:italic;">V</span><span style="color:#F6F6F4;"> value) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">&lt;K,V&gt; t </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> root; </span><span style="color:#7B7F8B;">// 将根节点赋值给变量t</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (t </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) { </span><span style="color:#7B7F8B;">// 如果根节点为null，说明TreeMap为空</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#62E884;">compare</span><span style="color:#F6F6F4;">(key, key); </span><span style="color:#7B7F8B;">// type (and possibly null) check，检查key的类型是否合法</span></span>
<span class="line"><span style="color:#F6F6F4;">        root </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">&lt;&gt;(key, value, </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">); </span><span style="color:#7B7F8B;">// 创建一个新节点作为根节点</span></span>
<span class="line"><span style="color:#F6F6F4;">        size </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">; </span><span style="color:#7B7F8B;">// size设置为1</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">; </span><span style="color:#7B7F8B;">// 返回null，表示插入成功</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> cmp;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">&lt;K,V&gt; parent;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// split comparator and comparable paths，根据使用的比较方法进行查找</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Comparator</span><span style="color:#F6F6F4;">&lt;</span><span style="color:#97E1F1;font-style:italic;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">super</span><span style="color:#F6F6F4;"> K&gt; cpr </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> comparator; </span><span style="color:#7B7F8B;">// 获取比较器</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (cpr </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) { </span><span style="color:#7B7F8B;">// 如果使用了Comparator</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">do</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">            parent </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> t; </span><span style="color:#7B7F8B;">// 将当前节点赋值给parent</span></span>
<span class="line"><span style="color:#F6F6F4;">            cmp </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> cpr.</span><span style="color:#62E884;">compare</span><span style="color:#F6F6F4;">(key, t.key); </span><span style="color:#7B7F8B;">// 使用Comparator比较key和t的键的大小</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (cmp </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">) </span><span style="color:#7B7F8B;">// 如果key小于t的键</span></span>
<span class="line"><span style="color:#F6F6F4;">                t </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> t.left; </span><span style="color:#7B7F8B;">// 在t的左子树中查找</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (cmp </span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">) </span><span style="color:#7B7F8B;">// 如果key大于t的键</span></span>
<span class="line"><span style="color:#F6F6F4;">                t </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> t.right; </span><span style="color:#7B7F8B;">// 在t的右子树中查找</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> </span><span style="color:#7B7F8B;">// 如果key等于t的键</span></span>
<span class="line"><span style="color:#F6F6F4;">                </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> t.</span><span style="color:#62E884;">setValue</span><span style="color:#F6F6F4;">(value); </span><span style="color:#7B7F8B;">// 直接更新t的值</span></span>
<span class="line"><span style="color:#F6F6F4;">        } </span><span style="color:#F286C4;">while</span><span style="color:#F6F6F4;"> (t </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> { </span><span style="color:#7B7F8B;">// 如果没有使用Comparator</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (key </span><span style="color:#F286C4;">==</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">) </span><span style="color:#7B7F8B;">// 如果key为null</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">throw</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">NullPointerException</span><span style="color:#F6F6F4;">(); </span><span style="color:#7B7F8B;">// 抛出NullPointerException异常</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#97E1F1;font-style:italic;">Comparable</span><span style="color:#F6F6F4;">&lt;</span><span style="color:#97E1F1;font-style:italic;">?</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">super</span><span style="color:#F6F6F4;"> K&gt; k </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> (</span><span style="color:#97E1F1;font-style:italic;">Comparable</span><span style="color:#F286C4;">&lt;?</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;font-style:italic;">super</span><span style="color:#F6F6F4;"> K</span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;">) key; </span><span style="color:#7B7F8B;">// 将key强制转换为Comparable类型</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">do</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">            parent </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> t; </span><span style="color:#7B7F8B;">// 将当前节点赋值给parent</span></span>
<span class="line"><span style="color:#F6F6F4;">            cmp </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> k.</span><span style="color:#62E884;">compareTo</span><span style="color:#F6F6F4;">(t.key); </span><span style="color:#7B7F8B;">// 使用Comparable比较key和t的键的大小</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (cmp </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">) </span><span style="color:#7B7F8B;">// 如果key小于t的键</span></span>
<span class="line"><span style="color:#F6F6F4;">                t </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> t.left; </span><span style="color:#7B7F8B;">// 在t的左子树中查找</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (cmp </span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">) </span><span style="color:#7B7F8B;">// 如果key大于t的键</span></span>
<span class="line"><span style="color:#F6F6F4;">                t </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> t.right; </span><span style="color:#7B7F8B;">// 在t的右子树中查找</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">else</span><span style="color:#F6F6F4;"> </span><span style="color:#7B7F8B;">// 如果key等于t的键</span></span>
<span class="line"><span style="color:#F6F6F4;">                </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> t.</span><span style="color:#62E884;">setValue</span><span style="color:#F6F6F4;">(value); </span><span style="color:#7B7F8B;">// 直接更新t的值</span></span>
<span class="line"><span style="color:#F6F6F4;">        } </span><span style="color:#F286C4;">while</span><span style="color:#F6F6F4;"> (t </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 如果没有找到相同的键，需要创建一个新节点插入到TreeMap中</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">&lt;K,V&gt; e </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Entry</span><span style="color:#F6F6F4;">&lt;&gt;(key, value, parent); </span><span style="color:#7B7F8B;">// 创建一个新节点</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (cmp </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">) </span><span style="color:#7B7F8B;">// 如果key小于parent的键</span></span>
<span class="line"><span style="color:#F6F6F4;">        parent.left </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e; </span><span style="color:#7B7F8B;">// 将e作为parent的左子节点</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">else</span></span>
<span class="line"><span style="color:#F6F6F4;">        parent.right </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> e; </span><span style="color:#7B7F8B;">// 将e作为parent的右子节点</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#62E884;">fixAfterInsertion</span><span style="color:#F6F6F4;">(e); </span><span style="color:#7B7F8B;">// 插入节点后需要进行平衡操作</span></span>
<span class="line"><span style="color:#F6F6F4;">    size</span><span style="color:#F286C4;">++</span><span style="color:#F6F6F4;">; </span><span style="color:#7B7F8B;">// size加1</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">null</span><span style="color:#F6F6F4;">; </span><span style="color:#7B7F8B;">// 返回null，表示插入成功</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> V </span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(K key, V value) {</span></span>
<span class="line"><span style="color:#24292E;">    Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root; </span><span style="color:#6A737D;">// 将根节点赋值给变量t</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 如果根节点为null，说明TreeMap为空</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">compare</span><span style="color:#24292E;">(key, key); </span><span style="color:#6A737D;">// type (and possibly null) check，检查key的类型是否合法</span></span>
<span class="line"><span style="color:#24292E;">        root </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Entry&lt;&gt;(key, value, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 创建一个新节点作为根节点</span></span>
<span class="line"><span style="color:#24292E;">        size </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// size设置为1</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 返回null，表示插入成功</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> cmp;</span></span>
<span class="line"><span style="color:#24292E;">    Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; parent;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// split comparator and comparable paths，根据使用的比较方法进行查找</span></span>
<span class="line"><span style="color:#24292E;">    Comparator&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">super</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">K</span><span style="color:#24292E;">&gt; cpr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> comparator; </span><span style="color:#6A737D;">// 获取比较器</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cpr </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 如果使用了Comparator</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">do</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            parent </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t; </span><span style="color:#6A737D;">// 将当前节点赋值给parent</span></span>
<span class="line"><span style="color:#24292E;">            cmp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cpr.</span><span style="color:#6F42C1;">compare</span><span style="color:#24292E;">(key, t.key); </span><span style="color:#6A737D;">// 使用Comparator比较key和t的键的大小</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cmp </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 如果key小于t的键</span></span>
<span class="line"><span style="color:#24292E;">                t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t.left; </span><span style="color:#6A737D;">// 在t的左子树中查找</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cmp </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 如果key大于t的键</span></span>
<span class="line"><span style="color:#24292E;">                t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t.right; </span><span style="color:#6A737D;">// 在t的右子树中查找</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 如果key等于t的键</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> t.</span><span style="color:#6F42C1;">setValue</span><span style="color:#24292E;">(value); </span><span style="color:#6A737D;">// 直接更新t的值</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (t </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 如果没有使用Comparator</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (key </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 如果key为null</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NullPointerException</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 抛出NullPointerException异常</span></span>
<span class="line"><span style="color:#24292E;">            Comparable&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">super</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">K</span><span style="color:#24292E;">&gt; k </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (Comparable</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> K</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">) key; </span><span style="color:#6A737D;">// 将key强制转换为Comparable类型</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">do</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            parent </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t; </span><span style="color:#6A737D;">// 将当前节点赋值给parent</span></span>
<span class="line"><span style="color:#24292E;">            cmp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> k.</span><span style="color:#6F42C1;">compareTo</span><span style="color:#24292E;">(t.key); </span><span style="color:#6A737D;">// 使用Comparable比较key和t的键的大小</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cmp </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 如果key小于t的键</span></span>
<span class="line"><span style="color:#24292E;">                t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t.left; </span><span style="color:#6A737D;">// 在t的左子树中查找</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cmp </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 如果key大于t的键</span></span>
<span class="line"><span style="color:#24292E;">                t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t.right; </span><span style="color:#6A737D;">// 在t的右子树中查找</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 如果key等于t的键</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> t.</span><span style="color:#6F42C1;">setValue</span><span style="color:#24292E;">(value); </span><span style="color:#6A737D;">// 直接更新t的值</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (t </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果没有找到相同的键，需要创建一个新节点插入到TreeMap中</span></span>
<span class="line"><span style="color:#24292E;">    Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Entry&lt;&gt;(key, value, parent); </span><span style="color:#6A737D;">// 创建一个新节点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cmp </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 如果key小于parent的键</span></span>
<span class="line"><span style="color:#24292E;">        parent.left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e; </span><span style="color:#6A737D;">// 将e作为parent的左子节点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">        parent.right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e; </span><span style="color:#6A737D;">// 将e作为parent的右子节点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">fixAfterInsertion</span><span style="color:#24292E;">(e); </span><span style="color:#6A737D;">// 插入节点后需要进行平衡操作</span></span>
<span class="line"><span style="color:#24292E;">    size</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// size加1</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 返回null，表示插入成功</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><ul><li>首先定义一个Entry类型的变量t，用于表示当前的根节点；</li><li>如果t为null，说明TreeMap为空，直接创建一个新的节点作为根节点，并将size设置为1；</li><li>如果t不为null，说明需要在TreeMap中查找键所对应的节点。因为TreeMap中的元素是有序的，所以可以使用二分查找的方式来查找节点；</li><li>如果TreeMap中使用了Comparator来进行排序，则使用Comparator进行比较，否则使用Comparable进行比较。如果查找到了相同的键，则直接更新键所对应的值；</li><li>如果没有查找到相同的键，则创建一个新的节点，并将其插入到TreeMap中。然后使用fixAfterInsertion()方法来修正插入节点后的平衡状态；</li><li>最后将TreeMap的size加1，然后返回null。如果更新了键所对应的值，则返回原先的值。</li></ul><p>注意 <code>cmp = k.compareTo(t.key)</code> 这行代码，就是用来进行 key 比较的，由于此时 key 是 String，所以就会调用 String 类的 <code>compareTo()</code> 方法进行比较。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">public</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">compareTo</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">String</span><span style="color:#F6F6F4;"> anotherString) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 获取当前字符串和另一个字符串的长度</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> len1 </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> value.length;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> len2 </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> anotherString.value.length;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 取两个字符串长度的较短者作为比较的上限</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> lim </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> Math.</span><span style="color:#62E884;">min</span><span style="color:#F6F6F4;">(len1, len2);</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 获取当前字符串和另一个字符串的字符数组</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">char</span><span style="color:#F6F6F4;"> v1[] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> value;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">char</span><span style="color:#F6F6F4;"> v2[] </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> anotherString.value;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> k </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;">0</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 对两个字符串的每个字符进行比较</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">while</span><span style="color:#F6F6F4;"> (k </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> lim) {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#97E1F1;font-style:italic;">char</span><span style="color:#F6F6F4;"> c1 </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> v1[k];</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#97E1F1;font-style:italic;">char</span><span style="color:#F6F6F4;"> c2 </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> v2[k];</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#7B7F8B;">// 如果两个字符不相等，返回它们的差值</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">if</span><span style="color:#F6F6F4;"> (c1 </span><span style="color:#F286C4;">!=</span><span style="color:#F6F6F4;"> c2) {</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> c1 </span><span style="color:#F286C4;">-</span><span style="color:#F6F6F4;"> c2;</span></span>
<span class="line"><span style="color:#F6F6F4;">        }</span></span>
<span class="line"><span style="color:#F6F6F4;">        k</span><span style="color:#F286C4;">++</span><span style="color:#F6F6F4;">;</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 如果两个字符串前面的字符都相等，返回它们长度的差值</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> len1 </span><span style="color:#F286C4;">-</span><span style="color:#F6F6F4;"> len2;</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compareTo</span><span style="color:#24292E;">(String anotherString) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取当前字符串和另一个字符串的长度</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> len1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> value.length;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> len2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> anotherString.value.length;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 取两个字符串长度的较短者作为比较的上限</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> lim </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">min</span><span style="color:#24292E;">(len1, len2);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取当前字符串和另一个字符串的字符数组</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> v1[] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> value;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> v2[] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> anotherString.value;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> k </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 对两个字符串的每个字符进行比较</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (k </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> lim) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> c1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> v1[k];</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> c2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> v2[k];</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果两个字符不相等，返回它们的差值</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (c1 </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> c2) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> c1 </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> c2;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        k</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果两个字符串前面的字符都相等，返回它们长度的差值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> len1 </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> len2;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>来看下面的示例。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">TreeMap</span><span style="color:#F6F6F4;">&lt;String,String&gt; mapString </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">TreeMap</span><span style="color:#F6F6F4;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#F6F6F4;">mapString.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">c</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">mapString.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">b</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">mapString.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">a</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">mapString.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">e</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">mapString.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">d</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(mapString);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">TreeMap&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; mapString </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> TreeMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">mapString.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;c&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">mapString.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;b&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">mapString.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;a&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">mapString.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;e&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">mapString.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;d&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(mapString);</span></span></code></pre></div><p>输出结果如下所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">{a=沉默王二, b=沉默王二, c=沉默王二, d=沉默王二, e=沉默王二}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">{a=沉默王二, b=沉默王二, c=沉默王二, d=沉默王二, e=沉默王二}</span></span></code></pre></div><p>从结果可以看得出，是按照字母的升序进行排序的。</p><h3 id="_02、自定义排序" tabindex="-1">02、自定义排序 <a class="header-anchor" href="#_02、自定义排序" aria-label="Permalink to &quot;02、自定义排序&quot;">​</a></h3><p>如果自然顺序不满足，那就可以在声明 TreeMap 对象的时候指定排序规则。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">TreeMap</span><span style="color:#F6F6F4;">&lt;Integer,String&gt; mapIntReverse </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">TreeMap</span><span style="color:#F6F6F4;">&lt;&gt;(Comparator.</span><span style="color:#62E884;">reverseOrder</span><span style="color:#F6F6F4;">());</span></span>
<span class="line"><span style="color:#F6F6F4;">mapIntReverse.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">3</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">mapIntReverse.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">2</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">mapIntReverse.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">mapIntReverse.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">5</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">mapIntReverse.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">4</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">沉默王二</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(mapIntReverse);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">TreeMap&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; mapIntReverse </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> TreeMap&lt;&gt;(Comparator.</span><span style="color:#6F42C1;">reverseOrder</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">mapIntReverse.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">mapIntReverse.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">mapIntReverse.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">mapIntReverse.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">mapIntReverse.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;沉默王二&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(mapIntReverse);</span></span></code></pre></div><p>TreeMap 提供了可以指定排序规则的构造方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">public</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">TreeMap</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">Comparator</span><span style="color:#F286C4;">&lt;?</span><span style="color:#F6F6F4;"> </span><span style="color:#BF9EEE;font-style:italic;">super</span><span style="color:#F6F6F4;"> K</span><span style="color:#F286C4;">&gt;</span><span style="color:#F6F6F4;"> comparator) {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#BF9EEE;font-style:italic;">this</span><span style="color:#F6F6F4;">.comparator </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> comparator;</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TreeMap</span><span style="color:#24292E;">(Comparator</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> K</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> comparator) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.comparator </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> comparator;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>Comparator.reverseOrder()</code> 返回的是 Collections.ReverseComparator 对象，就是用来反转顺序的，非常方便。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#F286C4;">private</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">static</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">class</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;">ReverseComparator</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">implements</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Comparator</span><span style="color:#F6F6F4;">&lt;</span><span style="color:#97E1F1;font-style:italic;">Comparable</span><span style="color:#F6F6F4;">&lt;Object&gt;&gt;, </span><span style="color:#97E1F1;font-style:italic;">Serializable</span><span style="color:#F6F6F4;"> {</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 单例模式，用于表示逆序比较器</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">static</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;">final</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">ReverseComparator</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">REVERSE_ORDER</span></span>
<span class="line"><span style="color:#F6F6F4;">            </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">ReverseComparator</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 实现比较方法，对两个实现了Comparable接口的对象进行逆序比较</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">public</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">int</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">compare</span><span style="color:#F6F6F4;">(</span><span style="color:#97E1F1;font-style:italic;">Comparable</span><span style="color:#F6F6F4;">&lt;Object&gt; </span><span style="color:#FFB86C;font-style:italic;">c1</span><span style="color:#F6F6F4;">, </span><span style="color:#97E1F1;font-style:italic;">Comparable</span><span style="color:#F6F6F4;">&lt;Object&gt; </span><span style="color:#FFB86C;font-style:italic;">c2</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> c2.</span><span style="color:#62E884;">compareTo</span><span style="color:#F6F6F4;">(c1); </span><span style="color:#7B7F8B;">// 调用c2的compareTo()方法，以c1为参数，实现逆序比较</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 反序列化时，返回Collections.reverseOrder()，保证单例模式</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">private</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Object</span><span style="color:#F6F6F4;"> </span><span style="color:#62E884;">readResolve</span><span style="color:#F6F6F4;">() {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> Collections.</span><span style="color:#62E884;">reverseOrder</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#7B7F8B;">// 返回正序比较器</span></span>
<span class="line"><span style="color:#F6F6F4;">    @</span><span style="color:#97E1F1;font-style:italic;">Override</span></span>
<span class="line"><span style="color:#F6F6F4;">    </span><span style="color:#F286C4;">public</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">Comparator</span><span style="color:#F6F6F4;">&lt;</span><span style="color:#97E1F1;font-style:italic;">Comparable</span><span style="color:#F6F6F4;">&lt;Object&gt;&gt; </span><span style="color:#62E884;">reversed</span><span style="color:#F6F6F4;">() {</span></span>
<span class="line"><span style="color:#F6F6F4;">        </span><span style="color:#F286C4;">return</span><span style="color:#F6F6F4;"> Comparator.</span><span style="color:#62E884;">naturalOrder</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#F6F6F4;">    }</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReverseComparator</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Comparator</span><span style="color:#24292E;">&lt;Comparable&lt;</span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt;&gt;, </span><span style="color:#6F42C1;">Serializable</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 单例模式，用于表示逆序比较器</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReverseComparator REVERSE_ORDER</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReverseComparator</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 实现比较方法，对两个实现了Comparable接口的对象进行逆序比较</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compare</span><span style="color:#24292E;">(Comparable&lt;</span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">c1</span><span style="color:#24292E;">, Comparable&lt;</span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">c2</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> c2.</span><span style="color:#6F42C1;">compareTo</span><span style="color:#24292E;">(c1); </span><span style="color:#6A737D;">// 调用c2的compareTo()方法，以c1为参数，实现逆序比较</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 反序列化时，返回Collections.reverseOrder()，保证单例模式</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">readResolve</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Collections.</span><span style="color:#6F42C1;">reverseOrder</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 返回正序比较器</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Comparator&lt;Comparable&lt;</span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt;&gt; </span><span style="color:#6F42C1;">reversed</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Comparator.</span><span style="color:#6F42C1;">naturalOrder</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>所以，输出结果如下所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">{5=沉默王二, 4=沉默王二, 3=沉默王二, 2=沉默王二, 1=沉默王二}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">{5=沉默王二, 4=沉默王二, 3=沉默王二, 2=沉默王二, 1=沉默王二}</span></span></code></pre></div><p>HashMap 是无序的，插入的顺序随着元素的增加会不停地变动。但 TreeMap 能够至始至终按照指定的顺序排列，这对于需要自定义排序的场景，实在是太有用了！</p><h3 id="_03、排序的好处" tabindex="-1">03、排序的好处 <a class="header-anchor" href="#_03、排序的好处" aria-label="Permalink to &quot;03、排序的好处&quot;">​</a></h3><p>既然 TreeMap 的元素是经过排序的，那找出最大的那个，最小的那个，或者找出所有大于或者小于某个值的键来说，就方便多了。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">Integer</span><span style="color:#F6F6F4;"> highestKey </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> mapInt.</span><span style="color:#62E884;">lastKey</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">Integer</span><span style="color:#F6F6F4;"> lowestKey </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> mapInt.</span><span style="color:#62E884;">firstKey</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">Set</span><span style="color:#F6F6F4;">&lt;Integer&gt; keysLessThan3 </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> mapInt.</span><span style="color:#62E884;">headMap</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">3</span><span style="color:#F6F6F4;">).</span><span style="color:#62E884;">keySet</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">Set</span><span style="color:#F6F6F4;">&lt;Integer&gt; keysGreaterThanEqTo3 </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> mapInt.</span><span style="color:#62E884;">tailMap</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">3</span><span style="color:#F6F6F4;">).</span><span style="color:#62E884;">keySet</span><span style="color:#F6F6F4;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(highestKey);</span></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(lowestKey);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(keysLessThan3);</span></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(keysGreaterThanEqTo3);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Integer highestKey </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mapInt.</span><span style="color:#6F42C1;">lastKey</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">Integer lowestKey </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mapInt.</span><span style="color:#6F42C1;">firstKey</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">Set&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; keysLessThan3 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mapInt.</span><span style="color:#6F42C1;">headMap</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">keySet</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">Set&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; keysGreaterThanEqTo3 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mapInt.</span><span style="color:#6F42C1;">tailMap</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">keySet</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(highestKey);</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(lowestKey);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(keysLessThan3);</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(keysGreaterThanEqTo3);</span></span></code></pre></div><p>TreeMap 考虑得很周全，恰好就提供了 <code>lastKey()</code>、<code>firstKey()</code> 这样获取最后一个 key 和第一个 key 的方法。</p><p><code>headMap()</code> 获取的是到指定 key 之前的 key；<code>tailMap()</code> 获取的是指定 key 之后的 key（包括指定 key）。</p><p>来看一下输出结果：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">5</span></span>
<span class="line"><span style="color:#f6f6f4;">1</span></span>
<span class="line"><span style="color:#f6f6f4;">[1, 2]</span></span>
<span class="line"><span style="color:#f6f6f4;">[3, 4, 5]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">5</span></span>
<span class="line"><span style="color:#24292e;">1</span></span>
<span class="line"><span style="color:#24292e;">[1, 2]</span></span>
<span class="line"><span style="color:#24292e;">[3, 4, 5]</span></span></code></pre></div><p>再来看一下例子：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#97E1F1;font-style:italic;">TreeMap</span><span style="color:#F6F6F4;">&lt;Integer, String&gt; treeMap </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> </span><span style="color:#F286C4;font-weight:bold;">new</span><span style="color:#F6F6F4;"> </span><span style="color:#97E1F1;font-style:italic;">TreeMap</span><span style="color:#F6F6F4;">&lt;&gt;();</span></span>
<span class="line"><span style="color:#F6F6F4;">treeMap.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">1</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">value1</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">treeMap.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">2</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">value2</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">treeMap.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">3</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">value3</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">treeMap.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">4</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">value4</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">treeMap.</span><span style="color:#62E884;">put</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">5</span><span style="color:#F6F6F4;">, </span><span style="color:#DEE492;">&quot;</span><span style="color:#E7EE98;">value5</span><span style="color:#DEE492;">&quot;</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">// headMap示例，获取小于3的键值对</span></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">Map</span><span style="color:#F6F6F4;">&lt;Integer, String&gt; headMap </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> treeMap.</span><span style="color:#62E884;">headMap</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">3</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(headMap); </span><span style="color:#7B7F8B;">// 输出 {1=value1, 2=value2}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">// tailMap示例，获取大于等于4的键值对</span></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">Map</span><span style="color:#F6F6F4;">&lt;Integer, String&gt; tailMap </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> treeMap.</span><span style="color:#62E884;">tailMap</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">4</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(tailMap); </span><span style="color:#7B7F8B;">// 输出 {4=value4, 5=value5}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7B7F8B;">// subMap示例，获取大于等于2且小于4的键值对</span></span>
<span class="line"><span style="color:#97E1F1;font-style:italic;">Map</span><span style="color:#F6F6F4;">&lt;Integer, String&gt; subMap </span><span style="color:#F286C4;">=</span><span style="color:#F6F6F4;"> treeMap.</span><span style="color:#62E884;">subMap</span><span style="color:#F6F6F4;">(</span><span style="color:#BF9EEE;">2</span><span style="color:#F6F6F4;">, </span><span style="color:#BF9EEE;">4</span><span style="color:#F6F6F4;">);</span></span>
<span class="line"><span style="color:#F6F6F4;">System.out.</span><span style="color:#62E884;">println</span><span style="color:#F6F6F4;">(subMap); </span><span style="color:#7B7F8B;">// 输出 {2=value2, 3=value3}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">TreeMap&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; treeMap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> TreeMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">treeMap.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;value1&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">treeMap.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;value2&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">treeMap.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;value3&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">treeMap.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;value4&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">treeMap.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;value5&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// headMap示例，获取小于3的键值对</span></span>
<span class="line"><span style="color:#24292E;">Map&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; headMap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> treeMap.</span><span style="color:#6F42C1;">headMap</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(headMap); </span><span style="color:#6A737D;">// 输出 {1=value1, 2=value2}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// tailMap示例，获取大于等于4的键值对</span></span>
<span class="line"><span style="color:#24292E;">Map&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; tailMap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> treeMap.</span><span style="color:#6F42C1;">tailMap</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(tailMap); </span><span style="color:#6A737D;">// 输出 {4=value4, 5=value5}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// subMap示例，获取大于等于2且小于4的键值对</span></span>
<span class="line"><span style="color:#24292E;">Map&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; subMap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> treeMap.</span><span style="color:#6F42C1;">subMap</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(subMap); </span><span style="color:#6A737D;">// 输出 {2=value2, 3=value3}</span></span></code></pre></div><p>headMap、tailMap、subMap方法分别获取了小于3、大于等于4、大于等于2且小于4的键值对。</p><h3 id="_04、如何选择-map" tabindex="-1">04、如何选择 Map <a class="header-anchor" href="#_04、如何选择-map" aria-label="Permalink to &quot;04、如何选择 Map&quot;">​</a></h3><p>在学习 TreeMap 之前，我们已经学习了 <a href="https://tobebetterjavaer.com/collection/hashmap.html" target="_blank" rel="noreferrer">HashMap</a> 和 <a href="https://tobebetterjavaer.com/collection/linkedhashmap.html" target="_blank" rel="noreferrer">LinkedHashMap</a> ，那如何从它们三个中间选择呢？</p><p>需要考虑以下因素：</p><ul><li>是否需要按照键的自然顺序或者自定义顺序进行排序。如果需要按照键排序，则可以使用 TreeMap；如果不需要排序，则可以使用 HashMap 或 LinkedHashMap。</li><li>是否需要保持插入顺序。如果需要保持插入顺序，则可以使用 LinkedHashMap；如果不需要保持插入顺序，则可以使用 TreeMap 或 HashMap。</li><li>是否需要高效的查找。如果需要高效的查找，则可以使用 LinkedHashMap 或 HashMap，因为它们的查找操作的时间复杂度为 O(1)，而是 TreeMap 是 O(log n)。</li></ul><blockquote><p>LinkedHashMap 内部使用哈希表来存储键值对，并使用一个双向链表来维护插入顺序，但查找操作只需要在哈希表中进行，与链表无关，所以时间复杂度为 O(1)</p></blockquote><p>来个表格吧，一目了然。</p><table><thead><tr><th>特性</th><th>TreeMap</th><th>HashMap</th><th>LinkedHashMap</th></tr></thead><tbody><tr><td>排序</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>插入顺序</td><td>不保证</td><td>不保证</td><td>保证</td></tr><tr><td>查找效率</td><td>O(log n)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>空间占用</td><td>通常较大</td><td>通常较小</td><td>通常较大</td></tr><tr><td>适用场景</td><td>需要排序的场景</td><td>无需排序的场景</td><td>需要保持插入顺序</td></tr></tbody></table><p>好了，下课，关于 TreeMap 我们就讲到这里吧，希望同学们都能对 TreeMap 有一个清晰的认识。我们下节课见~</p><hr>`,88),e=[o];function t(c,r,y,F,i,E){return a(),n("div",null,e)}const C=s(p,[["render",t]]);export{d as __pageData,C as default};
