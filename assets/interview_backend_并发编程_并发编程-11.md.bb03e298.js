import{_ as a,o as e,c as s,V as n}from"./chunks/framework.c6d8cbec.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/并发编程/并发编程-11.md","filePath":"interview/backend/并发编程/并发编程-11.md"}'),l={name:"interview/backend/并发编程/并发编程-11.md"},o=n(`<h3 id="_1、堆的作用是什么" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#1%E5%A0%86%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noreferrer">1、堆的作用是什么？</a> <a class="header-anchor" href="#_1、堆的作用是什么" aria-label="Permalink to &quot;[1、堆的作用是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题及答案，汇总版.md#1堆的作用是什么)&quot;">​</a></h3><p><strong>堆</strong>是虚拟机所管理的内存中最大的一块，被所有线程共享的，在虚拟机启动时创建。堆用来存放对象实例，Java 里几乎所有对象实例都在堆分配内存。堆可以处于物理上不连续的内存空间，逻辑上应该连续，但对于例如数组这样的大对象，多数虚拟机实现出于简单、存储高效的考虑会要求连续的内存空间。</p><p>堆既可以被实现成固定大小，也可以是可扩展的，可通过 <code>-Xms</code> 和 <code>-Xmx</code> 设置堆的最小和最大容量，当前主流 JVM 都按照可扩展实现。如果堆没有内存完成实例分配也无法扩展，抛出 OutOfMemoryError。</p><h3 id="_2、为什么hashtable是线程安全的" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#2%E4%B8%BA%E4%BB%80%E4%B9%88hashtable%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84" target="_blank" rel="noreferrer">2、为什么HashTable是线程安全的？</a> <a class="header-anchor" href="#_2、为什么hashtable是线程安全的" aria-label="Permalink to &quot;[2、为什么HashTable是线程安全的？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题及答案，汇总版.md#2为什么hashtable是线程安全的)&quot;">​</a></h3><p>因为HasTable的内部方法都被synchronized修饰了，所以是线程安全的。其他的都和HashMap一样</p><p><strong>1、</strong> HashMap添加方法的源码 <img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/045/42/87_12.png#alt=87%5C_12.png" alt=""></p><p><strong>2、</strong> HashTable添加方法的源码 <img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/045/42/87_13.png#alt=87%5C_13.png" alt=""></p><h3 id="_3、stackoverflow错误-permgen-space错误" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#3stackoverflow%E9%94%99%E8%AF%AFpermgen-space%E9%94%99%E8%AF%AF" target="_blank" rel="noreferrer">3、stackoverflow错误，permgen space错误</a> <a class="header-anchor" href="#_3、stackoverflow错误-permgen-space错误" aria-label="Permalink to &quot;[3、stackoverflow错误，permgen space错误](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题及答案，汇总版.md#3stackoverflow错误permgen-space错误)&quot;">​</a></h3><p>stackoverflow错误主要出现：</p><p>在虚拟机栈中(线程请求的栈深度大于虚拟机栈锁允许的最大深度)</p><p>permgen space错误(针对jdk之前1.7版本)：</p><p><strong>1、</strong> 大量加载class文件</p><p><strong>2、</strong> 常量池内存溢出</p><h3 id="_4、java-中你怎样唤醒一个阻塞的线程" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#4java-%E4%B8%AD%E4%BD%A0%E6%80%8E%E6%A0%B7%E5%94%A4%E9%86%92%E4%B8%80%E4%B8%AA%E9%98%BB%E5%A1%9E%E7%9A%84%E7%BA%BF%E7%A8%8B" target="_blank" rel="noreferrer">4、Java 中你怎样唤醒一个阻塞的线程？</a> <a class="header-anchor" href="#_4、java-中你怎样唤醒一个阻塞的线程" aria-label="Permalink to &quot;[4、Java 中你怎样唤醒一个阻塞的线程？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题及答案，汇总版.md#4java-中你怎样唤醒一个阻塞的线程)&quot;">​</a></h3><p>首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；</p><p>其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</p><h3 id="_5、jvm中一次完整的gc流程是怎样的-对象如何晋升到老年代" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#5jvm%E4%B8%AD%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84gc%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E6%99%8B%E5%8D%87%E5%88%B0%E8%80%81%E5%B9%B4%E4%BB%A3" target="_blank" rel="noreferrer">5、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？</a> <a class="header-anchor" href="#_5、jvm中一次完整的gc流程是怎样的-对象如何晋升到老年代" aria-label="Permalink to &quot;[5、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题及答案，汇总版.md#5jvm中一次完整的gc流程是怎样的对象如何晋升到老年代)&quot;">​</a></h3><p>当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。</p><h3 id="_6、你熟悉哪些垃圾收集算法" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#6%E4%BD%A0%E7%86%9F%E6%82%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95" target="_blank" rel="noreferrer">6、你熟悉哪些垃圾收集算法？</a> <a class="header-anchor" href="#_6、你熟悉哪些垃圾收集算法" aria-label="Permalink to &quot;[6、你熟悉哪些垃圾收集算法？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题及答案，汇总版.md#6你熟悉哪些垃圾收集算法)&quot;">​</a></h3><p>标记清除（缺点是碎片化） 复制算法（缺点是浪费空间） 标记整理算法（效率比前两者差） 分代收集算法（老年代一般使用“标记-清除”、“标记-整理”算法，年轻代一般用复制算法）</p><h3 id="_7、cms分为哪几个阶段" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#7cms%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5" target="_blank" rel="noreferrer">7、CMS分为哪几个阶段?</a> <a class="header-anchor" href="#_7、cms分为哪几个阶段" aria-label="Permalink to &quot;[7、CMS分为哪几个阶段?](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题及答案，汇总版.md#7cms分为哪几个阶段)&quot;">​</a></h3><p>CMS已经弃用。生活美好，时间有限，不建议再深入研究了。如果碰到问题，直接祭出回收过程即可。</p><p><strong>1、</strong> 初始标记</p><p><strong>2、</strong> 并发标记</p><p><strong>3、</strong> 并发预清理</p><p><strong>4、</strong> 并发可取消的预清理</p><p><strong>5、</strong> 重新标记</p><p><strong>6、</strong> 并发清理</p><p>由于《深入理解java虚拟机》一书的流行，面试时省略3、4步一般也是没问题的。</p><h3 id="_8、创建线程的四种方式" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#8%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F" target="_blank" rel="noreferrer">8、创建线程的四种方式</a> <a class="header-anchor" href="#_8、创建线程的四种方式" aria-label="Permalink to &quot;[8、创建线程的四种方式](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题及答案，汇总版.md#8创建线程的四种方式)&quot;">​</a></h3><p><strong>继承 Thread 类；</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">public class MyThread extends Thread {</span></span>
<span class="line"><span style="color:#f6f6f4;">    @Override</span></span>
<span class="line"><span style="color:#f6f6f4;">    public void run() {</span></span>
<span class="line"><span style="color:#f6f6f4;">        System.out.println(Thread.currentThread().getName() + &quot; run()方法正在执行...&quot;);</span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public class MyThread extends Thread {</span></span>
<span class="line"><span style="color:#24292e;">    @Override</span></span>
<span class="line"><span style="color:#24292e;">    public void run() {</span></span>
<span class="line"><span style="color:#24292e;">        System.out.println(Thread.currentThread().getName() + &quot; run()方法正在执行...&quot;);</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p><strong>实现 Runnable 接口；</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">public class MyRunnable implements Runnable {</span></span>
<span class="line"><span style="color:#f6f6f4;">    @Override</span></span>
<span class="line"><span style="color:#f6f6f4;">    public void run() {</span></span>
<span class="line"><span style="color:#f6f6f4;">        System.out.println(Thread.currentThread().getName() + &quot; run()方法执行中...&quot;);</span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public class MyRunnable implements Runnable {</span></span>
<span class="line"><span style="color:#24292e;">    @Override</span></span>
<span class="line"><span style="color:#24292e;">    public void run() {</span></span>
<span class="line"><span style="color:#24292e;">        System.out.println(Thread.currentThread().getName() + &quot; run()方法执行中...&quot;);</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p><strong>实现 Callable 接口；</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">public class MyCallable implements Callable&lt;Integer&gt; {</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">@Override</span></span>
<span class="line"><span style="color:#f6f6f4;">public Integer call() {</span></span>
<span class="line"><span style="color:#f6f6f4;">    System.out.println(Thread.currentThread().getName() + &quot; call()方法执行中...&quot;);</span></span>
<span class="line"><span style="color:#f6f6f4;">    return 1;</span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public class MyCallable implements Callable&lt;Integer&gt; {</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">@Override</span></span>
<span class="line"><span style="color:#24292e;">public Integer call() {</span></span>
<span class="line"><span style="color:#24292e;">    System.out.println(Thread.currentThread().getName() + &quot; call()方法执行中...&quot;);</span></span>
<span class="line"><span style="color:#24292e;">    return 1;</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p><strong>使用匿名内部类方式</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">public class CreateRunnable {</span></span>
<span class="line"><span style="color:#f6f6f4;">    public static void main(String[] args) {</span></span>
<span class="line"><span style="color:#f6f6f4;">        //创建多线程创建开始</span></span>
<span class="line"><span style="color:#f6f6f4;">        Thread thread = new Thread(new Runnable() {</span></span>
<span class="line"><span style="color:#f6f6f4;">                    public void run() {</span></span>
<span class="line"><span style="color:#f6f6f4;">                    for (int i = 0; i &lt; 10; i++) {</span></span>
<span class="line"><span style="color:#f6f6f4;">                    System.out.println(&quot;i:&quot; + i);</span></span>
<span class="line"><span style="color:#f6f6f4;">                }</span></span>
<span class="line"><span style="color:#f6f6f4;">            }</span></span>
<span class="line"><span style="color:#f6f6f4;">        });</span></span>
<span class="line"><span style="color:#f6f6f4;">        thread.start();</span></span>
<span class="line"><span style="color:#f6f6f4;">    }</span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public class CreateRunnable {</span></span>
<span class="line"><span style="color:#24292e;">    public static void main(String[] args) {</span></span>
<span class="line"><span style="color:#24292e;">        //创建多线程创建开始</span></span>
<span class="line"><span style="color:#24292e;">        Thread thread = new Thread(new Runnable() {</span></span>
<span class="line"><span style="color:#24292e;">                    public void run() {</span></span>
<span class="line"><span style="color:#24292e;">                    for (int i = 0; i &lt; 10; i++) {</span></span>
<span class="line"><span style="color:#24292e;">                    System.out.println(&quot;i:&quot; + i);</span></span>
<span class="line"><span style="color:#24292e;">                }</span></span>
<span class="line"><span style="color:#24292e;">            }</span></span>
<span class="line"><span style="color:#24292e;">        });</span></span>
<span class="line"><span style="color:#24292e;">        thread.start();</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><h3 id="_9、说一下-runnable-和-callable-有什么区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#9%E8%AF%B4%E4%B8%80%E4%B8%8B-runnable-%E5%92%8C-callable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">9、说一下 runnable 和 callable 有什么区别</a> <a class="header-anchor" href="#_9、说一下-runnable-和-callable-有什么区别" aria-label="Permalink to &quot;[9、说一下 runnable 和 callable 有什么区别](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题及答案，汇总版.md#9说一下-runnable-和-callable-有什么区别)&quot;">​</a></h3><p><strong>相同点：</strong></p><p><strong>1、</strong> 都是接口</p><p><strong>2、</strong> 都可以编写多线程程序</p><p><strong>3、</strong> 都采用Thread.start()启动线程</p><p><strong>主要区别：</strong></p><p>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</p><p>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息 注：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p><h3 id="_10、为什么线程通信的方法wait-notify-和notifyall-被定义在object-类里" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#10%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95wait,-notify%E5%92%8Cnotifyall%E8%A2%AB%E5%AE%9A%E4%B9%89%E5%9C%A8object-%E7%B1%BB%E9%87%8C" target="_blank" rel="noreferrer">10、为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object 类里？</a> <a class="header-anchor" href="#_10、为什么线程通信的方法wait-notify-和notifyall-被定义在object-类里" aria-label="Permalink to &quot;[10、为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object 类里？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题及答案，汇总版.md#10为什么线程通信的方法wait,-notify和notifyall被定义在object-类里)&quot;">​</a></h3><p>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。</p><h3 id="_11、什么叫线程安全-servlet是线程安全吗" tabindex="-1">11、什么叫线程安全？servlet是线程安全吗? <a class="header-anchor" href="#_11、什么叫线程安全-servlet是线程安全吗" aria-label="Permalink to &quot;11、什么叫线程安全？servlet是线程安全吗?&quot;">​</a></h3><h3 id="_12、java会存在内存泄漏吗-请简单描述。" tabindex="-1">12、Java会存在内存泄漏吗？请简单描述。 <a class="header-anchor" href="#_12、java会存在内存泄漏吗-请简单描述。" aria-label="Permalink to &quot;12、Java会存在内存泄漏吗？请简单描述。&quot;">​</a></h3><h3 id="_13、jvm-出现-fullgc-很频繁-怎么去线上排查问题" tabindex="-1">13、JVM 出现 fullGC 很频繁，怎么去线上排查问题 <a class="header-anchor" href="#_13、jvm-出现-fullgc-很频繁-怎么去线上排查问题" aria-label="Permalink to &quot;13、JVM 出现 fullGC 很频繁，怎么去线上排查问题&quot;">​</a></h3><h3 id="_14、gc-垃圾收集器" tabindex="-1">14、GC 垃圾收集器 <a class="header-anchor" href="#_14、gc-垃圾收集器" aria-label="Permalink to &quot;14、GC 垃圾收集器&quot;">​</a></h3><h3 id="_15、不可变对象对多线程有什么帮助" tabindex="-1">15、不可变对象对多线程有什么帮助 <a class="header-anchor" href="#_15、不可变对象对多线程有什么帮助" aria-label="Permalink to &quot;15、不可变对象对多线程有什么帮助&quot;">​</a></h3><h3 id="_16、线程之间是如何通信的" tabindex="-1">16、线程之间是如何通信的？ <a class="header-anchor" href="#_16、线程之间是如何通信的" aria-label="Permalink to &quot;16、线程之间是如何通信的？&quot;">​</a></h3><h3 id="_17、为什么需要双亲委派模式" tabindex="-1">17、为什么需要双亲委派模式？ <a class="header-anchor" href="#_17、为什么需要双亲委派模式" aria-label="Permalink to &quot;17、为什么需要双亲委派模式？&quot;">​</a></h3><h3 id="_18、java线程池中submit-和-execute-方法有什么区别" tabindex="-1">18、Java线程池中submit() 和 execute()方法有什么区别？ <a class="header-anchor" href="#_18、java线程池中submit-和-execute-方法有什么区别" aria-label="Permalink to &quot;18、Java线程池中submit() 和 execute()方法有什么区别？&quot;">​</a></h3><h3 id="_19、形成死锁的四个必要条件是什么" tabindex="-1">19、形成死锁的四个必要条件是什么 <a class="header-anchor" href="#_19、形成死锁的四个必要条件是什么" aria-label="Permalink to &quot;19、形成死锁的四个必要条件是什么&quot;">​</a></h3><h3 id="_20、什么是多线程中的上下文切换" tabindex="-1">20、什么是多线程中的上下文切换？ <a class="header-anchor" href="#_20、什么是多线程中的上下文切换" aria-label="Permalink to &quot;20、什么是多线程中的上下文切换？&quot;">​</a></h3><h3 id="_21、标记清除算法-mark-sweep" tabindex="-1">21、标记清除算法（ Mark-Sweep） <a class="header-anchor" href="#_21、标记清除算法-mark-sweep" aria-label="Permalink to &quot;21、标记清除算法（ Mark-Sweep）&quot;">​</a></h3><h3 id="_22、遇到过堆外内存溢出吗" tabindex="-1">22、遇到过堆外内存溢出吗？ <a class="header-anchor" href="#_22、遇到过堆外内存溢出吗" aria-label="Permalink to &quot;22、遇到过堆外内存溢出吗？&quot;">​</a></h3><h3 id="_23、谈谈你知道的垃圾回收算法" tabindex="-1">23、谈谈你知道的垃圾回收算法 <a class="header-anchor" href="#_23、谈谈你知道的垃圾回收算法" aria-label="Permalink to &quot;23、谈谈你知道的垃圾回收算法&quot;">​</a></h3><h3 id="_24、运行时数据区是什么" tabindex="-1">24、运行时数据区是什么？ <a class="header-anchor" href="#_24、运行时数据区是什么" aria-label="Permalink to &quot;24、运行时数据区是什么？&quot;">​</a></h3><h3 id="_25、cyclicbarrier和countdownlatch的区别" tabindex="-1">25、CyclicBarrier和CountDownLatch的区别 <a class="header-anchor" href="#_25、cyclicbarrier和countdownlatch的区别" aria-label="Permalink to &quot;25、CyclicBarrier和CountDownLatch的区别&quot;">​</a></h3><h3 id="_26、java线程具有五中基本状态" tabindex="-1">26、Java线程具有五中基本状态 <a class="header-anchor" href="#_26、java线程具有五中基本状态" aria-label="Permalink to &quot;26、Java线程具有五中基本状态&quot;">​</a></h3><h3 id="_27、什么是原子类" tabindex="-1">27、什么是原子类 <a class="header-anchor" href="#_27、什么是原子类" aria-label="Permalink to &quot;27、什么是原子类&quot;">​</a></h3><h3 id="_28、arraylist和vector有什么不同之处" tabindex="-1">28、ArrayList和Vector有什么不同之处？ <a class="header-anchor" href="#_28、arraylist和vector有什么不同之处" aria-label="Permalink to &quot;28、ArrayList和Vector有什么不同之处？&quot;">​</a></h3><h3 id="_29、什么是方法内联" tabindex="-1">29、什么是方法内联？ <a class="header-anchor" href="#_29、什么是方法内联" aria-label="Permalink to &quot;29、什么是方法内联？&quot;">​</a></h3><h3 id="_30、jvm怎么判断一个对象是不是要回收" tabindex="-1">30、JVM怎么判断一个对象是不是要回收？ <a class="header-anchor" href="#_30、jvm怎么判断一个对象是不是要回收" aria-label="Permalink to &quot;30、JVM怎么判断一个对象是不是要回收？&quot;">​</a></h3><h3 id="_31、调优命令有哪些" tabindex="-1">31、调优命令有哪些？ <a class="header-anchor" href="#_31、调优命令有哪些" aria-label="Permalink to &quot;31、调优命令有哪些？&quot;">​</a></h3><h3 id="_32、java如何实现多线程之间的通讯和协作" tabindex="-1">32、java如何实现多线程之间的通讯和协作？ <a class="header-anchor" href="#_32、java如何实现多线程之间的通讯和协作" aria-label="Permalink to &quot;32、java如何实现多线程之间的通讯和协作？&quot;">​</a></h3>`,70),t=[o];function r(p,c,i,E,u,h){return e(),s("div",null,t)}const b=a(l,[["render",r]]);export{d as __pageData,b as default};
