import{_ as a,o as e,c as o,V as r}from"./chunks/framework.c6d8cbec.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/java/java-03.md","filePath":"interview/backend/java/java-03.md"}'),t={name:"interview/backend/java/java-03.md"},s=r('<h3 id="_1、抽象工厂模式和原型模式之间的区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E6%9C%80%E6%96%B0%E7%89%88.md#1%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">1、抽象工厂模式和原型模式之间的区别？</a> <a class="header-anchor" href="#_1、抽象工厂模式和原型模式之间的区别" aria-label="Permalink to &quot;[1、抽象工厂模式和原型模式之间的区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题及答案汇总，2021年最新版.md#1抽象工厂模式和原型模式之间的区别)&quot;">​</a></h3><p>抽象工厂模式：通常由工厂方法模式来实现。但一个工厂中往往含有多个工厂方法生成一系列的产品。这个模式强调的是客户代码一次保证只使用一个系列的产品。当要切换为另一个系列的产品，换一个工厂类即可。</p><p>原型模式：工厂方法的最大缺点就是，对应一个继承体系的产品类，要有一个同样复杂的工厂类的继承体系。我们可以把工厂类中的工厂方法放到产品类自身之中吗？如果这样的话，就可以将两个继承体系为一个。这也就是原型模式的思想，原型模式中的工厂方法为clone，它会返回一个拷贝（可以是浅拷贝，也可以是深拷贝，由设计者决定）。为了保证用户代码中到时可以通过指针调用clone来动态绑定地生成所需的具体的类。这些原型对象必须事先构造好。</p><p>原型模式想对工厂方法模式的另一个好处是，拷贝的效率一般对构造的效率要高。</p><h3 id="_2、在-java-程序中怎么保证多线程的运行安全" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E6%9C%80%E6%96%B0%E7%89%88.md#2%E5%9C%A8-java-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E5%AE%89%E5%85%A8" target="_blank" rel="noreferrer">2、在 Java 程序中怎么保证多线程的运行安全？</a> <a class="header-anchor" href="#_2、在-java-程序中怎么保证多线程的运行安全" aria-label="Permalink to &quot;[2、在 Java 程序中怎么保证多线程的运行安全？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题及答案汇总，2021年最新版.md#2在-java-程序中怎么保证多线程的运行安全)&quot;">​</a></h3><p>出现线程安全问题的原因一般都是三个原因：</p><p><strong>1、</strong> 线程切换带来的原子性问题 解决办法：使用多线程之间同步synchronized或使用锁(lock)。</p><p><strong>2、</strong> 缓存导致的可见性问题 解决办法：synchronized、volatile、LOCK，可以解决可见性问题</p><p><strong>3、</strong> 编译优化带来的有序性问题 解决办法：Happens-Before 规则可以解决有序性问题</p><h3 id="_3、volatile-修饰符的有过什么实践" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E6%9C%80%E6%96%B0%E7%89%88.md#3volatile-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E6%9C%89%E8%BF%87%E4%BB%80%E4%B9%88%E5%AE%9E%E8%B7%B5" target="_blank" rel="noreferrer">3、volatile 修饰符的有过什么实践？</a> <a class="header-anchor" href="#_3、volatile-修饰符的有过什么实践" aria-label="Permalink to &quot;[3、volatile 修饰符的有过什么实践？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题及答案汇总，2021年最新版.md#3volatile-修饰符的有过什么实践)&quot;">​</a></h3><p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</p><h3 id="_4、java中各种数据默认值" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E6%9C%80%E6%96%B0%E7%89%88.md#4java%E4%B8%AD%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E9%BB%98%E8%AE%A4%E5%80%BC" target="_blank" rel="noreferrer">4、Java中各种数据默认值</a> <a class="header-anchor" href="#_4、java中各种数据默认值" aria-label="Permalink to &quot;[4、Java中各种数据默认值](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题及答案汇总，2021年最新版.md#4java中各种数据默认值)&quot;">​</a></h3><p><strong>1、</strong> Byte,short,int,long默认是都是0</p><p><strong>2、</strong> Boolean默认值是false</p><p><strong>3、</strong> Char类型的默认值是’’</p><p><strong>4、</strong> Float与double类型的默认是0.0</p><p><strong>5、</strong> 对象类型的默认值是null</p><h3 id="_5、说说java-垃圾回收机制" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E6%9C%80%E6%96%B0%E7%89%88.md#5%E8%AF%B4%E8%AF%B4java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6" target="_blank" rel="noreferrer">5、说说Java 垃圾回收机制</a> <a class="header-anchor" href="#_5、说说java-垃圾回收机制" aria-label="Permalink to &quot;[5、说说Java 垃圾回收机制](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题及答案汇总，2021年最新版.md#5说说java-垃圾回收机制)&quot;">​</a></h3><p>在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><h3 id="_6、有没有可能两个不相等的对象有有相同的-hashcode" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E6%9C%80%E6%96%B0%E7%89%88.md#6%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8F%AF%E8%83%BD%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84-hashcode" target="_blank" rel="noreferrer">6、有没有可能两个不相等的对象有有相同的 hashcode？</a> <a class="header-anchor" href="#_6、有没有可能两个不相等的对象有有相同的-hashcode" aria-label="Permalink to &quot;[6、有没有可能两个不相等的对象有有相同的 hashcode？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题及答案汇总，2021年最新版.md#6有没有可能两个不相等的对象有有相同的-hashcode)&quot;">​</a></h3><p>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。</p><h3 id="_7、synchronized-和-lock-有什么区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E6%9C%80%E6%96%B0%E7%89%88.md#7synchronized-%E5%92%8C-lock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">7、synchronized 和 Lock 有什么区别？</a> <a class="header-anchor" href="#_7、synchronized-和-lock-有什么区别" aria-label="Permalink to &quot;[7、synchronized 和 Lock 有什么区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题及答案汇总，2021年最新版.md#7synchronized-和-lock-有什么区别)&quot;">​</a></h3><p><strong>1、</strong> 首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；</p><p><strong>2、</strong> synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</p><p><strong>3、</strong> synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</p><p><strong>4、</strong> 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p><h3 id="_8、什么是vector" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E6%9C%80%E6%96%B0%E7%89%88.md#8%E4%BB%80%E4%B9%88%E6%98%AFvector" target="_blank" rel="noreferrer">8、什么是Vector</a> <a class="header-anchor" href="#_8、什么是vector" aria-label="Permalink to &quot;[8、什么是Vector](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题及答案汇总，2021年最新版.md#8什么是vector)&quot;">​</a></h3><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，访问它比访问ArrayList慢很多</p><p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。ArrayList的缺点是每个元素之间不能有间隔。</p><h3 id="_9、对象的访问定位有哪几种方式" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E6%9C%80%E6%96%B0%E7%89%88.md#9%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F" target="_blank" rel="noreferrer">9、对象的访问定位有哪几种方式?</a> <a class="header-anchor" href="#_9、对象的访问定位有哪几种方式" aria-label="Permalink to &quot;[9、对象的访问定位有哪几种方式?](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题及答案汇总，2021年最新版.md#9对象的访问定位有哪几种方式)&quot;">​</a></h3><p>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针2种：</p><p>句柄：如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><p>直接指针：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</p><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><h3 id="_10、equals-和-的区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%8C2021%E5%B9%B4%E6%9C%80%E6%96%B0%E7%89%88.md#10equals-%E5%92%8C--%E7%9A%84%E5%8C%BA%E5%88%AB#" target="_blank" rel="noreferrer">10、equals 和 == 的区别？#</a> <a class="header-anchor" href="#_10、equals-和-的区别" aria-label="Permalink to &quot;[10、equals 和 == 的区别？#](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java常见面试题及答案汇总，2021年最新版.md#10equals-和--的区别#)&quot;">​</a></h3><p>通俗点讲：是看看左右是不是一个东西。equals是看看左右是不是长得一样。如何记住嘛。如果单纯是想记住，：等于。equals：相同。两个长得一样的人，只能说长的相同(equals)，但是不等于他们俩是一个人。你只要记住equals，==就不用记了。</p><p><strong>术语来讲的区别：</strong></p><p><strong>1、</strong> ==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</p><p><strong>2、</strong> ==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同</p><h3 id="_11、servlet中如何获取用户提交的查询参数或表单数据" tabindex="-1">11、Servlet中如何获取用户提交的查询参数或表单数据？ <a class="header-anchor" href="#_11、servlet中如何获取用户提交的查询参数或表单数据" aria-label="Permalink to &quot;11、Servlet中如何获取用户提交的查询参数或表单数据？&quot;">​</a></h3><h3 id="_12、堆溢出的原因" tabindex="-1">12、堆溢出的原因？ <a class="header-anchor" href="#_12、堆溢出的原因" aria-label="Permalink to &quot;12、堆溢出的原因？&quot;">​</a></h3><h3 id="_13、java-中-怎么获取一个文件中单词出现的最高频率" tabindex="-1">13、Java 中，怎么获取一个文件中单词出现的最高频率？ <a class="header-anchor" href="#_13、java-中-怎么获取一个文件中单词出现的最高频率" aria-label="Permalink to &quot;13、Java 中，怎么获取一个文件中单词出现的最高频率？&quot;">​</a></h3><h3 id="_14、你知道哪些jvm性能调优" tabindex="-1">14、你知道哪些JVM性能调优 <a class="header-anchor" href="#_14、你知道哪些jvm性能调优" aria-label="Permalink to &quot;14、你知道哪些JVM性能调优&quot;">​</a></h3><h3 id="_15、抽象类必须要有抽象方法吗" tabindex="-1">15、抽象类必须要有抽象方法吗？ <a class="header-anchor" href="#_15、抽象类必须要有抽象方法吗" aria-label="Permalink to &quot;15、抽象类必须要有抽象方法吗？&quot;">​</a></h3><h3 id="_16、串行-serial-收集器和吞吐量-throughput-收集器的区别是什么" tabindex="-1">16、串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？ <a class="header-anchor" href="#_16、串行-serial-收集器和吞吐量-throughput-收集器的区别是什么" aria-label="Permalink to &quot;16、串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？&quot;">​</a></h3><h3 id="_17、react的请求应该放在哪个生命周期中" tabindex="-1">17、React的请求应该放在哪个生命周期中? <a class="header-anchor" href="#_17、react的请求应该放在哪个生命周期中" aria-label="Permalink to &quot;17、React的请求应该放在哪个生命周期中?&quot;">​</a></h3><h3 id="_18、volatile关键字的作用" tabindex="-1">18、volatile关键字的作用 <a class="header-anchor" href="#_18、volatile关键字的作用" aria-label="Permalink to &quot;18、volatile关键字的作用&quot;">​</a></h3><h3 id="_19、我们能将-int-强制转换为-byte-类型的变量吗-如果该值大于-byte-类型的范围-将会出现什么现象" tabindex="-1">19、我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？ <a class="header-anchor" href="#_19、我们能将-int-强制转换为-byte-类型的变量吗-如果该值大于-byte-类型的范围-将会出现什么现象" aria-label="Permalink to &quot;19、我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？&quot;">​</a></h3><h3 id="_20、什么是java虚拟机" tabindex="-1">20、什么是Java虚拟机 <a class="header-anchor" href="#_20、什么是java虚拟机" aria-label="Permalink to &quot;20、什么是Java虚拟机&quot;">​</a></h3><h3 id="_21、cms-收集器-多线程标记清除算法" tabindex="-1">21、CMS 收集器（多线程标记清除算法） <a class="header-anchor" href="#_21、cms-收集器-多线程标记清除算法" aria-label="Permalink to &quot;21、CMS 收集器（多线程标记清除算法）&quot;">​</a></h3><h3 id="_22、接口和抽象类的区别是什么" tabindex="-1">22、接口和抽象类的区别是什么？ <a class="header-anchor" href="#_22、接口和抽象类的区别是什么" aria-label="Permalink to &quot;22、接口和抽象类的区别是什么？&quot;">​</a></h3><h3 id="_23、如何合理分配线程池大小" tabindex="-1">23、如何合理分配线程池大小? <a class="header-anchor" href="#_23、如何合理分配线程池大小" aria-label="Permalink to &quot;23、如何合理分配线程池大小?&quot;">​</a></h3><h3 id="_24、什么是线程组-为什么在java中不推荐使用" tabindex="-1">24、什么是线程组，为什么在Java中不推荐使用？ <a class="header-anchor" href="#_24、什么是线程组-为什么在java中不推荐使用" aria-label="Permalink to &quot;24、什么是线程组，为什么在Java中不推荐使用？&quot;">​</a></h3><h3 id="_25、类加载器" tabindex="-1">25、类加载器 <a class="header-anchor" href="#_25、类加载器" aria-label="Permalink to &quot;25、类加载器&quot;">​</a></h3><h3 id="_26、jvm-如何确定垃圾对象" tabindex="-1">26、JVM 如何确定垃圾对象？ <a class="header-anchor" href="#_26、jvm-如何确定垃圾对象" aria-label="Permalink to &quot;26、JVM 如何确定垃圾对象？&quot;">​</a></h3><h3 id="_27、字符型常量和字符串常量的区别" tabindex="-1">27、字符型常量和字符串常量的区别 <a class="header-anchor" href="#_27、字符型常量和字符串常量的区别" aria-label="Permalink to &quot;27、字符型常量和字符串常量的区别&quot;">​</a></h3><h3 id="_28、g1-收集器" tabindex="-1">28、G1 收集器 <a class="header-anchor" href="#_28、g1-收集器" aria-label="Permalink to &quot;28、G1 收集器&quot;">​</a></h3><h3 id="_29、java-中-直接缓冲区与非直接缓冲器有什么区别" tabindex="-1">29、Java 中，直接缓冲区与非直接缓冲器有什么区别？ <a class="header-anchor" href="#_29、java-中-直接缓冲区与非直接缓冲器有什么区别" aria-label="Permalink to &quot;29、Java 中，直接缓冲区与非直接缓冲器有什么区别？&quot;">​</a></h3><h3 id="_30、如何决定使用-hashmap-还是-treemap" tabindex="-1">30、如何决定使用 HashMap 还是 TreeMap？ <a class="header-anchor" href="#_30、如何决定使用-hashmap-还是-treemap" aria-label="Permalink to &quot;30、如何决定使用 HashMap 还是 TreeMap？&quot;">​</a></h3><h3 id="_31、说一下-arraylist-的优缺点" tabindex="-1">31、说一下 ArrayList 的优缺点 <a class="header-anchor" href="#_31、说一下-arraylist-的优缺点" aria-label="Permalink to &quot;31、说一下 ArrayList 的优缺点&quot;">​</a></h3><h3 id="_32、构造方法能不能重写-能不能重载" tabindex="-1">32、构造方法能不能重写？能不能重载？ <a class="header-anchor" href="#_32、构造方法能不能重写-能不能重载" aria-label="Permalink to &quot;32、构造方法能不能重写？能不能重载？&quot;">​</a></h3><h3 id="_33、什么是红黑树" tabindex="-1">33、什么是红黑树 <a class="header-anchor" href="#_33、什么是红黑树" aria-label="Permalink to &quot;33、什么是红黑树&quot;">​</a></h3><h3 id="_34、什么是逃逸分析" tabindex="-1">34、什么是逃逸分析？ <a class="header-anchor" href="#_34、什么是逃逸分析" aria-label="Permalink to &quot;34、什么是逃逸分析？&quot;">​</a></h3><h3 id="_35、栈帧里面包含哪些东西" tabindex="-1">35、栈帧里面包含哪些东西？ <a class="header-anchor" href="#_35、栈帧里面包含哪些东西" aria-label="Permalink to &quot;35、栈帧里面包含哪些东西？&quot;">​</a></h3><h3 id="_36、tomcat是怎么打破双亲委派机制的呢" tabindex="-1">36、Tomcat是怎么打破双亲委派机制的呢？ <a class="header-anchor" href="#_36、tomcat是怎么打破双亲委派机制的呢" aria-label="Permalink to &quot;36、Tomcat是怎么打破双亲委派机制的呢？&quot;">​</a></h3><h3 id="_37、weakhashmap-是怎么工作的" tabindex="-1">37、WeakHashMap 是怎么工作的？ <a class="header-anchor" href="#_37、weakhashmap-是怎么工作的" aria-label="Permalink to &quot;37、WeakHashMap 是怎么工作的？&quot;">​</a></h3><h3 id="_38、java-中操作字符串都有哪些类-它们之间有什么区别" tabindex="-1">38、java 中操作字符串都有哪些类？它们之间有什么区别？ <a class="header-anchor" href="#_38、java-中操作字符串都有哪些类-它们之间有什么区别" aria-label="Permalink to &quot;38、java 中操作字符串都有哪些类？它们之间有什么区别？&quot;">​</a></h3><h3 id="_39、什么是jvm-java虚拟机包括什么" tabindex="-1">39、什么是JVM？java虚拟机包括什么？ <a class="header-anchor" href="#_39、什么是jvm-java虚拟机包括什么" aria-label="Permalink to &quot;39、什么是JVM？java虚拟机包括什么？&quot;">​</a></h3><h3 id="_40、java-的引用有哪些类型" tabindex="-1">40、Java 的引用有哪些类型？ <a class="header-anchor" href="#_40、java-的引用有哪些类型" aria-label="Permalink to &quot;40、Java 的引用有哪些类型？&quot;">​</a></h3>',69),h=[s];function l(E,n,i,d,c,B){return e(),o("div",null,h)}const b=a(t,[["render",l]]);export{v as __pageData,b as default};
