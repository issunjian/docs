import{_ as s,o as a,c as e,V as o}from"./chunks/framework.c6d8cbec.js";const A=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/前端/前端最新面试题，2021年面试题及答案汇总.md","filePath":"interview/backend/前端/前端最新面试题，2021年面试题及答案汇总.md"}'),t={name:"interview/backend/前端/前端最新面试题，2021年面试题及答案汇总.md"},n=o(`<h3 id="_1、如何解决跨域问题" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#1%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98" target="_blank" rel="noreferrer">1、如何解决跨域问题</a> <a class="header-anchor" href="#_1、如何解决跨域问题" aria-label="Permalink to &quot;[1、如何解决跨域问题](https://gitee.com/souyunku/DevBooks/blob/master/docs/前端/前端最新面试题，2021年面试题及答案汇总.md#1如何解决跨域问题)&quot;">​</a></h3><p>跨域的概念：协议、域名、端口都相同才同域，否则都是跨域</p><p><strong>解决跨域问题：</strong></p><p><strong>1、</strong> 使用JSONP（json+padding）把数据内填充起来</p><p><strong>2、</strong> CORS方式（跨域资源共享），在后端上配置可跨域</p><p><strong>3、</strong> 服务器代理，通过服务器的文件能访问第三方资源</p><h3 id="_2、html元素的显示优先级" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#2html%E5%85%83%E7%B4%A0%E7%9A%84%E6%98%BE%E7%A4%BA%E4%BC%98%E5%85%88%E7%BA%A7" target="_blank" rel="noreferrer">2、HTML元素的显示优先级？</a> <a class="header-anchor" href="#_2、html元素的显示优先级" aria-label="Permalink to &quot;[2、HTML元素的显示优先级？](https://gitee.com/souyunku/DevBooks/blob/master/docs/前端/前端最新面试题，2021年面试题及答案汇总.md#2html元素的显示优先级)&quot;">​</a></h3><p>帧元素（frame）&gt;HTML元素优先，表单元素总&gt;非表单元素优先</p><p>常见的非表单元素包括：链接标记（A），DIV标记，SPAN标记，TABLE标记等等。表单元素覆盖样式元素的根本原因在于HTML元素默认的显示优先级规则。</p><p>所有这样HTML元素又可以根据其显示要求分成两类，即有窗口的HTML元素(Windowed Element),无窗口的HTML元素（Windowless Element)。</p><p>有窗口的元素包括：SELECT元素，OBJECT元素，插件，IE5.01以主更早版本中的IFRAME元素。</p><p>无窗口的元素包括：大多数的普通HTML元素，如链接和TABLE标记，除了SELECT元素之外的大多数表单元素。</p><h3 id="_3、sass和less有什么区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#3sass%E5%92%8Cless%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">3、sass和less有什么区别?</a> <a class="header-anchor" href="#_3、sass和less有什么区别" aria-label="Permalink to &quot;[3、sass和less有什么区别?](https://gitee.com/souyunku/DevBooks/blob/master/docs/前端/前端最新面试题，2021年面试题及答案汇总.md#3sass和less有什么区别)&quot;">​</a></h3><p><strong>1、</strong> 编译环境不一样 Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中。</p><p><strong>2、</strong> 变量符不一相，less是@，而scss是$,而且它们的作用域也不一样，less是块级作用域</p><p><strong>3、</strong> 输出设置，Less没有输出设置，sass提供4种输出选项，nested,compact,compressed和expanded nested：嵌套缩进的css代码(默认) expanded：展开的多行css代码 compact：简洁格式的css代码 compressed：压缩后的css代码</p><p><strong>4、</strong> sass支持条件语句，可以使用if{}else{},for{}循环等等，而less不行</p><p><strong>5、</strong> 引用外部css文件，sass引用外部文件必须以_开头，文件名如果以下划线_形状，sass会认为该文件是一个引用文件，不会将其编译为css文件。less引用外部文件和css中的@import没什么差异。</p><p><strong>6、</strong> sass和less的工具库不同。sass有工具库Compass, 简单说，sass和Compass的关系有点像Javascript和jQuery的关系,Compass是sass的工具库。在它的基础上，封装了一系列有用的模块和模板，补充强化了sass的功能。less有UI组件库Bootstrap,Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用less语法编写。</p><p>总结：不管是sass，还是less，都可以视为一种基于CSS之上的高级语言，其目的是使得CSS开发更灵活和更强大，sass的功能比less强大,基本可以说是一种真正的编程语言了，less则相对清晰明了,易于上手,对编译环境要求比较宽松。考虑到编译sass要安装Ruby,而Ruby官网在国内访问不了,个人在实际开发中更倾向于选择less。</p><h3 id="_4、数据持久化技术-ajax-简述ajax流程" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#4%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AFajax%E7%AE%80%E8%BF%B0ajax%E6%B5%81%E7%A8%8B###" target="_blank" rel="noreferrer">4、数据持久化技术(ajax)?简述ajax流程###</a> <a class="header-anchor" href="#_4、数据持久化技术-ajax-简述ajax流程" aria-label="Permalink to &quot;[4、数据持久化技术(ajax)?简述ajax流程###](https://gitee.com/souyunku/DevBooks/blob/master/docs/前端/前端最新面试题，2021年面试题及答案汇总.md#4数据持久化技术ajax简述ajax流程###)&quot;">​</a></h3><p><strong>1、</strong> 客户端产生js的事件</p><p><strong>2、</strong> 创建XMLHttpRequest对象</p><p><strong>3、</strong> 对XMLHttpRequest进行配置</p><p><strong>4、</strong> 通过AJAX引擎发送异步请求</p><p><strong>5、</strong> 服务器端接收请求并且处理请求，返回html或者xml内容</p><p><strong>6、</strong> XML调用一个callback()处理响应回来的内容</p><p><strong>7、</strong> 页面局部刷新</p><h3 id="_5、那些操作会造成内存泄漏" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#5%E9%82%A3%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" target="_blank" rel="noreferrer">5、那些操作会造成内存泄漏？</a> <a class="header-anchor" href="#_5、那些操作会造成内存泄漏" aria-label="Permalink to &quot;[5、那些操作会造成内存泄漏？](https://gitee.com/souyunku/DevBooks/blob/master/docs/前端/前端最新面试题，2021年面试题及答案汇总.md#5那些操作会造成内存泄漏)&quot;">​</a></h3><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</p><p><code>setTimeout</code> 的第一个参数使用字符串而非函数的话，会引发内存泄漏</p><p>闭包使用不当</p><h3 id="_6、ie-各版本和-chrome-可以并行下载多少个资源" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#6ie-%E5%90%84%E7%89%88%E6%9C%AC%E5%92%8C-chrome-%E5%8F%AF%E4%BB%A5%E5%B9%B6%E8%A1%8C%E4%B8%8B%E8%BD%BD%E5%A4%9A%E5%B0%91%E4%B8%AA%E8%B5%84%E6%BA%90" target="_blank" rel="noreferrer">6、IE 各版本和 Chrome 可以并行下载多少个资源？</a> <a class="header-anchor" href="#_6、ie-各版本和-chrome-可以并行下载多少个资源" aria-label="Permalink to &quot;[6、IE 各版本和 Chrome 可以并行下载多少个资源？](https://gitee.com/souyunku/DevBooks/blob/master/docs/前端/前端最新面试题，2021年面试题及答案汇总.md#6ie-各版本和-chrome-可以并行下载多少个资源)&quot;">​</a></h3><p><strong>1、</strong> IE6 2 个并发</p><p><strong>2、</strong> iE7 升级之后的 6 个并发，之后版本也是 6 个</p><p><strong>3、</strong> Firefox，chrome 也是6个</p><h3 id="_7、谈谈你对amd、cmd的理解" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#7%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E7%9A%84%E7%90%86%E8%A7%A3" target="_blank" rel="noreferrer">7、谈谈你对AMD、CMD的理解</a> <a class="header-anchor" href="#_7、谈谈你对amd、cmd的理解" aria-label="Permalink to &quot;[7、谈谈你对AMD、CMD的理解](https://gitee.com/souyunku/DevBooks/blob/master/docs/前端/前端最新面试题，2021年面试题及答案汇总.md#7谈谈你对的理解)&quot;">​</a></h3><p><strong>1、</strong> <code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<code>AMD</code>规范则是非同步加载模块，允许指定回调函数</p><p><strong>2、</strong> <code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的</p><h3 id="_8、谁是c的构造函数" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#8%E8%B0%81%E6%98%AFc%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" target="_blank" rel="noreferrer">8、谁是c的构造函数?</a> <a class="header-anchor" href="#_8、谁是c的构造函数" aria-label="Permalink to &quot;[8、谁是c的构造函数?](https://gitee.com/souyunku/DevBooks/blob/master/docs/前端/前端最新面试题，2021年面试题及答案汇总.md#8谁是c的构造函数)&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">function ab() {</span></span>
<span class="line"><span style="color:#f6f6f4;">         this.say = &quot;&quot;; } </span></span>
<span class="line"><span style="color:#f6f6f4;">ab.constructor = {} ab.name = &#39;&#39;; </span></span>
<span class="line"><span style="color:#f6f6f4;">var c = new ab(); </span></span>
<span class="line"><span style="color:#f6f6f4;">//构造函数默认指向函数本身,ab是一个类,它的构造函数是它本身，</span></span>
<span class="line"><span style="color:#f6f6f4;">//然后ab.constructor={};ab的构造函数就指向{}了，c是ab的实例化对象，c的构造函数就是{}</span></span>
<span class="line"><span style="color:#f6f6f4;">//通过使用new的时候,创建对象发生了那些改变? 当使用new操作时，会马上开辟一个块内存，</span></span>
<span class="line"><span style="color:#f6f6f4;">//创建一个空对象，并将this指向这个对象。接着，执行构造函数ab()，对这个空对象进行构造</span></span>
<span class="line"><span style="color:#f6f6f4;">//（构造函数里有什么属性和方法都一一给这个空白对象装配上去，这就是为何它叫构造函数了）。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">function ab() {</span></span>
<span class="line"><span style="color:#24292e;">         this.say = &quot;&quot;; } </span></span>
<span class="line"><span style="color:#24292e;">ab.constructor = {} ab.name = &#39;&#39;; </span></span>
<span class="line"><span style="color:#24292e;">var c = new ab(); </span></span>
<span class="line"><span style="color:#24292e;">//构造函数默认指向函数本身,ab是一个类,它的构造函数是它本身，</span></span>
<span class="line"><span style="color:#24292e;">//然后ab.constructor={};ab的构造函数就指向{}了，c是ab的实例化对象，c的构造函数就是{}</span></span>
<span class="line"><span style="color:#24292e;">//通过使用new的时候,创建对象发生了那些改变? 当使用new操作时，会马上开辟一个块内存，</span></span>
<span class="line"><span style="color:#24292e;">//创建一个空对象，并将this指向这个对象。接着，执行构造函数ab()，对这个空对象进行构造</span></span>
<span class="line"><span style="color:#24292e;">//（构造函数里有什么属性和方法都一一给这个空白对象装配上去，这就是为何它叫构造函数了）。</span></span></code></pre></div><h3 id="_9、如何清除一个定时器" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#9%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8" target="_blank" rel="noreferrer">9、如何清除一个定时器?</a> <a class="header-anchor" href="#_9、如何清除一个定时器" aria-label="Permalink to &quot;[9、如何清除一个定时器?](https://gitee.com/souyunku/DevBooks/blob/master/docs/前端/前端最新面试题，2021年面试题及答案汇总.md#9如何清除一个定时器)&quot;">​</a></h3><p>window.clearInterval();</p><p>window.clearTimeout();</p><h3 id="_10、less-sass-styus三者的区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#10less,sass,styus%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">10、less,sass,styus三者的区别</a> <a class="header-anchor" href="#_10、less-sass-styus三者的区别" aria-label="Permalink to &quot;[10、less,sass,styus三者的区别](https://gitee.com/souyunku/DevBooks/blob/master/docs/前端/前端最新面试题，2021年面试题及答案汇总.md#10less,sass,styus三者的区别)&quot;">​</a></h3><p><strong>变量</strong></p><p>Sass声明变量必须是『$』开头，后面紧跟变量名和变量值，而且变量名和变量值需要使用冒号：分隔开。</p><p>Less 声明变量用『@』开头，其余等同 Sass。</p><p>Stylus 中声明变量没有任何限定，结尾的分号可有可无，但变量名和变量值之间必须要有『等号』。</p><p><strong>作用域</strong></p><p>Sass：三者最差，不存在全局变量的概念</p><p>Less：最近的一次更新的变量有效，并且会作用于全部的引用！</p><p>Stylus：Sass 的处理方式和 Stylus 相同，变量值输出时根据之前最近的一次定义计算，每次引用最近的定义有效；</p><p><strong>嵌套</strong></p><p>三种 css 预编译器的「选择器嵌套」在使用上来说没有任何区别，甚至连引用父级选择器的标记 &amp; 也相同</p><p><strong>继承</strong></p><p>Sass和Stylus的继承非常像，能把一个选择器的所有样式继承到另一个选择器上。使用『@extend』开始，后面接被继承的选择器。Stylus 的继承方式来自 Sass，两者如出一辙。 Less 则又「独树一帜」地用伪类来描述继承关系；</p><p>**导入<a href="/docs/Import.html">@Import </a> **</p><p>Sass 中只能在使用 url() 表达式引入时进行变量插值</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">$device: mobile;</span></span>
<span class="line"><span style="color:#f6f6f4;">@import url(styles.#{$device}.css);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">$device: mobile;</span></span>
<span class="line"><span style="color:#24292e;">@import url(styles.#{$device}.css);</span></span></code></pre></div><p>Less 中可以在字符串中进行插值</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">@device: mobile;</span></span>
<span class="line"><span style="color:#f6f6f4;">@import &quot;styles.@{device}.css&quot;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">@device: mobile;</span></span>
<span class="line"><span style="color:#24292e;">@import &quot;styles.@{device}.css&quot;;</span></span></code></pre></div><p>Stylus 中在这里插值不管用，但是可以利用其字符串拼接的功能实现</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">device = &quot;mobile&quot;</span></span>
<span class="line"><span style="color:#f6f6f4;">@import &quot;styles.&quot; + device + &quot;.css&quot;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">device = &quot;mobile&quot;</span></span>
<span class="line"><span style="color:#24292e;">@import &quot;styles.&quot; + device + &quot;.css&quot;</span></span></code></pre></div><p><strong>总结</strong></p><p>Sass和Less语法严谨、Stylus相对自由。因为Less长得更像 css，所以它可能学习起来更容易。</p><p>Sass 和 Compass、Stylus 和 Nib 都是好基友。</p><p>Sass 和 Stylus 都具有类语言的逻辑方式处理：条件、循环等，而 Less 需要通过When等关键词模拟这些功能，这方面 Less 比不上 Sass 和 Stylus</p><p>Less 在丰富性以及特色上都不及 Sass 和 Stylus，若不是因为 Bootstrap 引入了 Less，可能它不会像现在这样被广泛应用（个人愚见）</p><h3 id="_11、性能优化" tabindex="-1">11、性能优化？ <a class="header-anchor" href="#_11、性能优化" aria-label="Permalink to &quot;11、性能优化？&quot;">​</a></h3><h3 id="_12、你做的页面在哪些流览器测试过-这些浏览器的内核分别是什么" tabindex="-1">12、你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么? <a class="header-anchor" href="#_12、你做的页面在哪些流览器测试过-这些浏览器的内核分别是什么" aria-label="Permalink to &quot;12、你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?&quot;">​</a></h3><h3 id="_13、25-jq如何判断元素显示隐藏" tabindex="-1">13、25.Jq如何判断元素显示隐藏？ <a class="header-anchor" href="#_13、25-jq如何判断元素显示隐藏" aria-label="Permalink to &quot;13、25.Jq如何判断元素显示隐藏？&quot;">​</a></h3><h3 id="_14、nexttick" tabindex="-1">14、nextTick() <a class="header-anchor" href="#_14、nexttick" aria-label="Permalink to &quot;14、nextTick()&quot;">​</a></h3><h3 id="_15、图片的预加载和懒加载" tabindex="-1">15、图片的预加载和懒加载 <a class="header-anchor" href="#_15、图片的预加载和懒加载" aria-label="Permalink to &quot;15、图片的预加载和懒加载&quot;">​</a></h3><h3 id="_16、常见web安全及防护原理" tabindex="-1">16、常见web安全及防护原理 <a class="header-anchor" href="#_16、常见web安全及防护原理" aria-label="Permalink to &quot;16、常见web安全及防护原理&quot;">​</a></h3><h3 id="_17、什么是对象解构" tabindex="-1">17、什么是对象解构？ <a class="header-anchor" href="#_17、什么是对象解构" aria-label="Permalink to &quot;17、什么是对象解构？&quot;">​</a></h3><h3 id="_18、什么是nan-以及如何检查值是否为nan" tabindex="-1">18、什么是NaN？以及如何检查值是否为NaN？ <a class="header-anchor" href="#_18、什么是nan-以及如何检查值是否为nan" aria-label="Permalink to &quot;18、什么是NaN？以及如何检查值是否为NaN？&quot;">​</a></h3><h3 id="_19、为什么此代码-obj-someprop-x-会引发错误" tabindex="-1">19、为什么此代码 <code>obj.someprop.x</code> 会引发错误? <a class="header-anchor" href="#_19、为什么此代码-obj-someprop-x-会引发错误" aria-label="Permalink to &quot;19、为什么此代码 \`obj.someprop.x\` 会引发错误?&quot;">​</a></h3><h3 id="_20、promise-是什么" tabindex="-1">20、Promise 是什么？ <a class="header-anchor" href="#_20、promise-是什么" aria-label="Permalink to &quot;20、Promise 是什么？&quot;">​</a></h3><h3 id="_21、网页验证码是干嘛的-是为了解决什么安全问题" tabindex="-1">21、网页验证码是干嘛的，是为了解决什么安全问题 <a class="header-anchor" href="#_21、网页验证码是干嘛的-是为了解决什么安全问题" aria-label="Permalink to &quot;21、网页验证码是干嘛的，是为了解决什么安全问题&quot;">​</a></h3><h3 id="_22、什么是-iife-它的用途是什么" tabindex="-1">22、什么是 IIFE，它的用途是什么？ <a class="header-anchor" href="#_22、什么是-iife-它的用途是什么" aria-label="Permalink to &quot;22、什么是 IIFE，它的用途是什么？&quot;">​</a></h3><h3 id="_23、解构赋值" tabindex="-1">23、解构赋值 <a class="header-anchor" href="#_23、解构赋值" aria-label="Permalink to &quot;23、解构赋值&quot;">​</a></h3><h3 id="_24、什么是箭头函数" tabindex="-1">24、什么是箭头函数？ <a class="header-anchor" href="#_24、什么是箭头函数" aria-label="Permalink to &quot;24、什么是箭头函数？&quot;">​</a></h3><h3 id="_25、function-prototype-apply-方法的用途是什么" tabindex="-1">25、Function.prototype.apply 方法的用途是什么？ <a class="header-anchor" href="#_25、function-prototype-apply-方法的用途是什么" aria-label="Permalink to &quot;25、Function.prototype.apply 方法的用途是什么？&quot;">​</a></h3><h3 id="_26、知道什么是微格式吗" tabindex="-1">26、知道什么是微格式吗？ <a class="header-anchor" href="#_26、知道什么是微格式吗" aria-label="Permalink to &quot;26、知道什么是微格式吗？&quot;">​</a></h3><h3 id="_27、css里的visibility属性有个collapse属性值-在不同浏览器下以后什么区别" tabindex="-1">27、CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？ <a class="header-anchor" href="#_27、css里的visibility属性有个collapse属性值-在不同浏览器下以后什么区别" aria-label="Permalink to &quot;27、CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？&quot;">​</a></h3><h3 id="_28、数组的排序方法-sort-排序-汉字排序" tabindex="-1">28、数组的排序方法（sort）？排序？汉字排序？ <a class="header-anchor" href="#_28、数组的排序方法-sort-排序-汉字排序" aria-label="Permalink to &quot;28、数组的排序方法（sort）？排序？汉字排序？&quot;">​</a></h3><h3 id="_29、display有哪些值-说明他们的作用" tabindex="-1">29、display有哪些值？说明他们的作用? <a class="header-anchor" href="#_29、display有哪些值-说明他们的作用" aria-label="Permalink to &quot;29、display有哪些值？说明他们的作用?&quot;">​</a></h3><h3 id="_30、style标签写在body后与body前有什么区别" tabindex="-1">30、style标签写在body后与body前有什么区别？ <a class="header-anchor" href="#_30、style标签写在body后与body前有什么区别" aria-label="Permalink to &quot;30、style标签写在body后与body前有什么区别？&quot;">​</a></h3><h3 id="_31、渐进增强和优雅降级的定义" tabindex="-1">31、渐进增强和优雅降级的定义 <a class="header-anchor" href="#_31、渐进增强和优雅降级的定义" aria-label="Permalink to &quot;31、渐进增强和优雅降级的定义&quot;">​</a></h3>`,90),r=[n];function l(p,c,i,E,d,h){return a(),e("div",null,r)}const b=s(t,[["render",l]]);export{A as __pageData,b as default};
