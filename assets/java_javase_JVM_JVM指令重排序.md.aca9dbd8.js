import{_ as a,o as e,c as o,V as t}from"./chunks/framework.c6d8cbec.js";const f=JSON.parse('{"title":"指令重排序","description":"","frontmatter":{},"headers":[],"relativePath":"java/javase/JVM/JVM指令重排序.md","filePath":"java/javase/JVM/JVM指令重排序.md"}'),r={name:"java/javase/JVM/JVM指令重排序.md"},l=t('<h1 id="指令重排序" tabindex="-1">指令重排序 <a class="header-anchor" href="#指令重排序" aria-label="Permalink to &quot;指令重排序&quot;">​</a></h1><hr><h2 id="指令概念" tabindex="-1">指令概念 <a class="header-anchor" href="#指令概念" aria-label="Permalink to &quot;指令概念&quot;">​</a></h2><p>指令是指示计算机执行某种操作的命令，如：数据传送指令、算术运算指令、位运算指令、程序流程控制指令、串操作指令、处理器控制指令。指令不同于我们所写的代码，一行代码按照操作的逻辑可以分成多条指令。</p><p>举个例子：int a = 1; 这段代码大致可以分为两条指令：1.加载常量1；2.将常量1赋值给变量a。</p><h2 id="指令重排序-1" tabindex="-1">指令重排序 <a class="header-anchor" href="#指令重排序-1" aria-label="Permalink to &quot;指令重排序&quot;">​</a></h2><p>只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做指令的重排序。</p><p>指令重排序的意义：使指令更加符合 CPU 的执行特性，最大限度的发挥机器的性能，提高程序的执行效率。</p><h3 id="指令重排序分类" tabindex="-1">指令重排序分类 <a class="header-anchor" href="#指令重排序分类" aria-label="Permalink to &quot;指令重排序分类&quot;">​</a></h3><p>指令重排序主要分为三种，在这里主要讨论 JVM 中的指令重排序。</p><ol><li>编译器重排序：JVM 中完成</li><li>指令级并行重排序</li><li>处理器重排序：CPU 中完成</li></ol><h3 id="指令重排序原则" tabindex="-1">指令重排序原则 <a class="header-anchor" href="#指令重排序原则" aria-label="Permalink to &quot;指令重排序原则&quot;">​</a></h3><p>如果程序中操作A在操作B之前，那么线程中操作A将在操作B之前执行。（只对指令内部重排序，不在指令间重排序）</p><ul><li><strong>As-If-Serial语义</strong></li></ul><p>不管怎么进行指令重排序，单线程内程序的执行结果不能被改变。</p><p>编译器和处理器对存在依赖关系的操作都不会对其进行重排序。只有不存在依赖关系的操作有可能进行重排序。</p><p><strong>Happens-Before原则</strong></p><p>保证正确同步的多线程程序的执行结果不被改变。</p><p>对于被同步的操作，如果操作 A 先于操作 B，那么 A 操作的执行结果将对 B 操作可见，而且 A 操作的执行顺序排在 B 操作之前。</p><p>管理锁定规则：一个unlock操作happen—before后面（时间上的先后顺序）对同一个锁的lock操作。 （如果线程1解锁了monitor a，接着线程2锁定了a，那么，线程1解锁a之前的写操作都对线程2可见（线程1和线程2可以是同一个线程））</p><h2 id="防止指令重排序" tabindex="-1">防止指令重排序 <a class="header-anchor" href="#防止指令重排序" aria-label="Permalink to &quot;防止指令重排序&quot;">​</a></h2><p>volatile关键字通过“内存屏障”来防止指令被重排序。</p><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p>Java内存模型采取保守策略（见缝就插）</p><p>在每个volatile写操作的前面插入一个StoreStore屏障。 在每个volatile写操作的后面插入一个StoreLoad屏障。 在每个volatile读操作的后面插入一个LoadLoad屏障。 在每个volatile读操作的后面插入一个LoadStore屏障。</p><p>Synchronized 把多线程执行环境改变为单线程执行环境，无需关心指令重排序（单线程执行结果不会改变）。</p>',26),i=[l];function p(n,s,h,d,c,_){return e(),o("div",null,i)}const m=a(r,[["render",p]]);export{f as __pageData,m as default};
