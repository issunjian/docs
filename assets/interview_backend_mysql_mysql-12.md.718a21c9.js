import{_ as a,o as e,c as o,V as r}from"./chunks/framework.c6d8cbec.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/mysql/mysql-12.md","filePath":"interview/backend/mysql/mysql-12.md"}'),t={name:"interview/backend/mysql/mysql-12.md"},s=r(`<h3 id="_1、索引的分类" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#1%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB" target="_blank" rel="noreferrer">1、索引的分类?</a> <a class="header-anchor" href="#_1、索引的分类" aria-label="Permalink to &quot;[1、索引的分类?](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL高级面试题整理及答案.md#1索引的分类)&quot;">​</a></h3><p><strong>1、</strong> 从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，</p><p><strong>2、</strong> 从应用层次来分：普通索引，唯一索引，复合索引</p><p><strong>3、</strong> 根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。</p><p>平时讲的索引类型一般是指在应用层次的划分。</p><p>就像手机分类：安卓手机，IOS手机 与 华为手机，苹果手机，OPPO手机一样。</p><p>普通索引：</p><p>即一个索引只包含单个列，一个表可以有多个单列索引</p><p>唯一索引：</p><p>索引列的值必须唯一，但允许有空值</p><p>复合索引：</p><p>多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</p><p>聚簇索引(聚集索引)：</p><p>并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。</p><p>非聚簇索引：不是聚簇索引，就是非聚簇索引</p><h3 id="_2、索引具体采用那种数据结构呢" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#2%E7%B4%A2%E5%BC%95%E5%85%B7%E4%BD%93%E9%87%87%E7%94%A8%E9%82%A3%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%91%A2" target="_blank" rel="noreferrer">2、索引具体采用那种数据结构呢？</a> <a class="header-anchor" href="#_2、索引具体采用那种数据结构呢" aria-label="Permalink to &quot;[2、索引具体采用那种数据结构呢？](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL高级面试题整理及答案.md#2索引具体采用那种数据结构呢)&quot;">​</a></h3><p>常见的MySQL主要有两种结构：hash索引和B+Tree索引，我们使用的是innodb引擎，默认的是B+树。</p><h3 id="_3、索引算法有哪些" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#3%E7%B4%A2%E5%BC%95%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B" target="_blank" rel="noreferrer">3、索引算法有哪些？</a> <a class="header-anchor" href="#_3、索引算法有哪些" aria-label="Permalink to &quot;[3、索引算法有哪些？](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL高级面试题整理及答案.md#3索引算法有哪些)&quot;">​</a></h3><p>索引算法有 BTree算法和Hash算法</p><p><strong>BTree算法</strong></p><p>BTree是最常用的MySQL数据库索引算法，也是MySQL默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">-- 只要它的查询条件是一个不以通配符开头的常量</span></span>
<span class="line"><span style="color:#f6f6f4;">select * from user where name like &#39;jack%&#39;; </span></span>
<span class="line"><span style="color:#f6f6f4;">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span></span>
<span class="line"><span style="color:#f6f6f4;">select * from user where name like &#39;%jack&#39;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">-- 只要它的查询条件是一个不以通配符开头的常量</span></span>
<span class="line"><span style="color:#24292e;">select * from user where name like &#39;jack%&#39;; </span></span>
<span class="line"><span style="color:#24292e;">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span></span>
<span class="line"><span style="color:#24292e;">select * from user where name like &#39;%jack&#39;;</span></span></code></pre></div><p><strong>Hash算法</strong></p><p>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p><h3 id="_4、备份计划-mysqldump以及xtranbackup的实现原理" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#4%E5%A4%87%E4%BB%BD%E8%AE%A1%E5%88%92mysqldump%E4%BB%A5%E5%8F%8Axtranbackup%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" target="_blank" rel="noreferrer">4、备份计划，MySQLdump以及xtranbackup的实现原理</a> <a class="header-anchor" href="#_4、备份计划-mysqldump以及xtranbackup的实现原理" aria-label="Permalink to &quot;[4、备份计划，MySQLdump以及xtranbackup的实现原理](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL高级面试题整理及答案.md#4备份计划mysqldump以及xtranbackup的实现原理)&quot;">​</a></h3><p><strong>备份计划</strong></p><p><strong>1、</strong> 视库的大小来定，一般来说 100G 内的库，可以考虑使用 MySQLdump 来做，因为 MySQLdump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(MySQLdump 备份出来的文件比较小，压缩之后更小)。</p><p><strong>2、</strong> 100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 MySQLdump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</p><p><strong>备份恢复时间</strong></p><p><strong>1、</strong> 物理备份恢复快，逻辑备份恢复慢</p><p><strong>2、</strong> 这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</p><p><strong>3、</strong> 20G的2分钟（MySQLdump）</p><p><strong>4、</strong> 80G的30分钟(MySQLdump)</p><p><strong>5、</strong> 111G的30分钟（MySQLdump)</p><p><strong>6、</strong> 288G的3小时（xtra)</p><p><strong>7、</strong> 3T的4小时（xtra)</p><p><strong>8、</strong> 逻辑导入时间一般是备份时间的5倍以上</p><p><strong>备份恢复失败如何处理</strong></p><p>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</p><p><strong>MySQLdump和xtrabackup实现原理</strong></p><p><strong>MySQLdump</strong></p><p>MySQLdump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /*!40100 WITH CONSISTENTSNAPSHOT */)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p><p><strong>Xtrabackup:</strong></p><p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p><ul><li>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</li></ul><h3 id="_5、blob和text有什么区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#5blob%E5%92%8Ctext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">5、BLOB和TEXT有什么区别？</a> <a class="header-anchor" href="#_5、blob和text有什么区别" aria-label="Permalink to &quot;[5、BLOB和TEXT有什么区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL高级面试题整理及答案.md#5blob和text有什么区别)&quot;">​</a></h3><p>BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。</p><p>BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。</p><h3 id="_6、百万级别或以上的数据如何删除" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#6%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E6%88%96%E4%BB%A5%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4" target="_blank" rel="noreferrer">6、百万级别或以上的数据如何删除</a> <a class="header-anchor" href="#_6、百万级别或以上的数据如何删除" aria-label="Permalink to &quot;[6、百万级别或以上的数据如何删除](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL高级面试题整理及答案.md#6百万级别或以上的数据如何删除)&quot;">​</a></h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><p><strong>1、</strong> 所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</p><p><strong>2、</strong> 然后删除其中无用数据（此过程需要不到两分钟）</p><p><strong>3、</strong> 删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</p><p><strong>4、</strong> 与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</p><h3 id="_7、乐观锁" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#7%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A" target="_blank" rel="noreferrer">7、乐观锁：</a> <a class="header-anchor" href="#_7、乐观锁" aria-label="Permalink to &quot;[7、乐观锁：](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL高级面试题整理及答案.md#7乐观锁：)&quot;">​</a></h3><p>乐观锁的“乐观情绪”体现在，它认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。</p><h3 id="_8、b树和b-树的区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#8b%E6%A0%91%E5%92%8Cb+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">8、B树和B+树的区别</a> <a class="header-anchor" href="#_8、b树和b-树的区别" aria-label="Permalink to &quot;[8、B树和B+树的区别](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL高级面试题整理及答案.md#8b树和b+树的区别)&quot;">​</a></h3><p><strong>1、</strong> 在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p><p><strong>2、</strong> B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p><p>![99_4.png][99_4.png]</p><h3 id="_9、innodb引擎的4大特性" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#9innodb%E5%BC%95%E6%93%8E%E7%9A%844%E5%A4%A7%E7%89%B9%E6%80%A7" target="_blank" rel="noreferrer">9、InnoDB引擎的4大特性</a> <a class="header-anchor" href="#_9、innodb引擎的4大特性" aria-label="Permalink to &quot;[9、InnoDB引擎的4大特性](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL高级面试题整理及答案.md#9innodb引擎的4大特性)&quot;">​</a></h3><p><strong>1、</strong> 插入缓冲（insert buffer)</p><p><strong>2、</strong> 二次写(double write)</p><p><strong>3、</strong> 自适应哈希索引(ahi)</p><p><strong>4、</strong> 预读(read ahead)</p><h3 id="_10、有多少种日志" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E5%8F%8A%E7%AD%94%E6%A1%88.md#10%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E6%97%A5%E5%BF%97" target="_blank" rel="noreferrer">10、有多少种日志</a> <a class="header-anchor" href="#_10、有多少种日志" aria-label="Permalink to &quot;[10、有多少种日志](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL高级面试题整理及答案.md#10有多少种日志)&quot;">​</a></h3><p>innodb两种日志redo和undo。</p><h3 id="_11、mysql的binlog有几种录入格式-分别有什么区别" tabindex="-1">11、MySQL的binlog有几种录入格式？分别有什么区别？ <a class="header-anchor" href="#_11、mysql的binlog有几种录入格式-分别有什么区别" aria-label="Permalink to &quot;11、MySQL的binlog有几种录入格式？分别有什么区别？&quot;">​</a></h3><h3 id="_12、优化where子句" tabindex="-1">12、优化WHERE子句 <a class="header-anchor" href="#_12、优化where子句" aria-label="Permalink to &quot;12、优化WHERE子句&quot;">​</a></h3><h3 id="_13、什么是内连接、外连接、交叉连接、笛卡尔积呢" tabindex="-1">13、什么是内连接、外连接、交叉连接、笛卡尔积呢？ <a class="header-anchor" href="#_13、什么是内连接、外连接、交叉连接、笛卡尔积呢" aria-label="Permalink to &quot;13、什么是内连接、外连接、交叉连接、笛卡尔积呢？&quot;">​</a></h3><h3 id="_14、聚簇索引和非聚簇索引-在查询数据的时候有区别吗-为什么" tabindex="-1">14、聚簇索引和非聚簇索引，在查询数据的时候有区别吗？为什么？ <a class="header-anchor" href="#_14、聚簇索引和非聚簇索引-在查询数据的时候有区别吗-为什么" aria-label="Permalink to &quot;14、聚簇索引和非聚簇索引，在查询数据的时候有区别吗？为什么？&quot;">​</a></h3><h3 id="_15、sql-约束有哪几种" tabindex="-1">15、SQL 约束有哪几种？ <a class="header-anchor" href="#_15、sql-约束有哪几种" aria-label="Permalink to &quot;15、SQL 约束有哪几种？&quot;">​</a></h3><h3 id="_16、mysql中有哪些不同的表格" tabindex="-1">16、MySQL中有哪些不同的表格？ <a class="header-anchor" href="#_16、mysql中有哪些不同的表格" aria-label="Permalink to &quot;16、MySQL中有哪些不同的表格？&quot;">​</a></h3><h3 id="_17、索引使用场景" tabindex="-1">17、索引使用场景 <a class="header-anchor" href="#_17、索引使用场景" aria-label="Permalink to &quot;17、索引使用场景&quot;">​</a></h3><h3 id="_18、mysql为什么这么设计" tabindex="-1">18、MySQL为什么这么设计 <a class="header-anchor" href="#_18、mysql为什么这么设计" aria-label="Permalink to &quot;18、MySQL为什么这么设计&quot;">​</a></h3><h3 id="_19、drop、delete与truncate的区别" tabindex="-1">19、drop、delete与truncate的区别 <a class="header-anchor" href="#_19、drop、delete与truncate的区别" aria-label="Permalink to &quot;19、drop、delete与truncate的区别&quot;">​</a></h3><h3 id="_20、mysql中text数据类型的最大长度" tabindex="-1">20、MySQL中TEXT数据类型的最大长度 <a class="header-anchor" href="#_20、mysql中text数据类型的最大长度" aria-label="Permalink to &quot;20、MySQL中TEXT数据类型的最大长度&quot;">​</a></h3><h3 id="_21、char和varchar的区别" tabindex="-1">21、CHAR和VARCHAR的区别？ <a class="header-anchor" href="#_21、char和varchar的区别" aria-label="Permalink to &quot;21、CHAR和VARCHAR的区别？&quot;">​</a></h3><h3 id="_22、怎么创建索引的-有什么好处-有哪些分类" tabindex="-1">22、怎么创建索引的，有什么好处，有哪些分类 <a class="header-anchor" href="#_22、怎么创建索引的-有什么好处-有哪些分类" aria-label="Permalink to &quot;22、怎么创建索引的，有什么好处，有哪些分类&quot;">​</a></h3><h3 id="_23、mysql中有哪几种锁" tabindex="-1">23、MySQL中有哪几种锁？ <a class="header-anchor" href="#_23、mysql中有哪几种锁" aria-label="Permalink to &quot;23、MySQL中有哪几种锁？&quot;">​</a></h3><h3 id="_24、你怎么知道sql语句性能是高还是低" tabindex="-1">24、你怎么知道SQL语句性能是高还是低 <a class="header-anchor" href="#_24、你怎么知道sql语句性能是高还是低" aria-label="Permalink to &quot;24、你怎么知道SQL语句性能是高还是低&quot;">​</a></h3><h3 id="_25、innodb引擎的4大特性-了解过吗" tabindex="-1">25、InnoDB引擎的4大特性，了解过吗 <a class="header-anchor" href="#_25、innodb引擎的4大特性-了解过吗" aria-label="Permalink to &quot;25、InnoDB引擎的4大特性，了解过吗&quot;">​</a></h3><h3 id="_26、如何写sql能够有效的使用到复合索引。" tabindex="-1">26、如何写sql能够有效的使用到复合索引。 <a class="header-anchor" href="#_26、如何写sql能够有效的使用到复合索引。" aria-label="Permalink to &quot;26、如何写sql能够有效的使用到复合索引。&quot;">​</a></h3><h3 id="_27、使用悲观锁" tabindex="-1">27、使用悲观锁 <a class="header-anchor" href="#_27、使用悲观锁" aria-label="Permalink to &quot;27、使用悲观锁&quot;">​</a></h3><h3 id="_28、myql中的事务回滚机制概述" tabindex="-1">28、Myql中的事务回滚机制概述 <a class="header-anchor" href="#_28、myql中的事务回滚机制概述" aria-label="Permalink to &quot;28、Myql中的事务回滚机制概述&quot;">​</a></h3><h3 id="_29、说说mysql-的基础架构图" tabindex="-1">29、说说MySQL 的基础架构图 <a class="header-anchor" href="#_29、说说mysql-的基础架构图" aria-label="Permalink to &quot;29、说说MySQL 的基础架构图&quot;">​</a></h3>`,86),n=[s];function l(p,E,h,i,d,c){return e(),o("div",null,n)}const A=a(t,[["render",l]]);export{b as __pageData,A as default};
