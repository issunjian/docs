import{_ as a,o as e,c as r,V as o}from"./chunks/framework.c6d8cbec.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/java/java-07.md","filePath":"interview/backend/java/java-07.md"}'),t={name:"interview/backend/java/java-07.md"},i=o('<h3 id="_1、什么是接口" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%9C%80%E6%96%B0%E7%89%88.md#1%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3" target="_blank" rel="noreferrer">1、什么是接口？</a> <a class="header-anchor" href="#_1、什么是接口" aria-label="Permalink to &quot;[1、什么是接口？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java高级面试题及答案，最新版.md#1什么是接口)&quot;">​</a></h3><p>接口就是某个事物对外提供的一些功能的声明，是一种特殊的java类</p><h3 id="_2、简述正则表达式及其用途。" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%9C%80%E6%96%B0%E7%89%88.md#2%E7%AE%80%E8%BF%B0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%94%A8%E9%80%94%E3%80%82" target="_blank" rel="noreferrer">2、简述正则表达式及其用途。</a> <a class="header-anchor" href="#_2、简述正则表达式及其用途。" aria-label="Permalink to &quot;[2、简述正则表达式及其用途。](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java高级面试题及答案，最新版.md#2简述正则表达式及其用途。)&quot;">​</a></h3><p>在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p><blockquote><p>说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。</p></blockquote><h3 id="_3、生产上如何配置垃圾收集器的" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%9C%80%E6%96%B0%E7%89%88.md#3%E7%94%9F%E4%BA%A7%E4%B8%8A%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84" target="_blank" rel="noreferrer">3、生产上如何配置垃圾收集器的？</a> <a class="header-anchor" href="#_3、生产上如何配置垃圾收集器的" aria-label="Permalink to &quot;[3、生产上如何配置垃圾收集器的？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java高级面试题及答案，最新版.md#3生产上如何配置垃圾收集器的)&quot;">​</a></h3><p>首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。通常，堆空间我会设置成操作系统的<code>2/3</code>（这是想给其他进程和操作系统预留一些时间），超过8GB的堆优先选用G1。</p><p>接下来，我会对JVM进行初步优化。比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例。</p><p>再接下来，就是专项优化，主要判断的依据就是系统容量、访问延迟、吞吐量等。我们的服务是高并发的，所以对STW的时间非常敏感。</p><p>我会通过记录详细的GC日志，来找到这个瓶颈点，借用<code>gceasy</code>（重点）这样的日志分析工具，很容易定位到问题。之所以选择采用工具，是因为gc日志看起来实在是太麻烦了，gceasy号称是AI学习分析问题，可视化做的较好。</p><h3 id="_4、模式的职责" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%9C%80%E6%96%B0%E7%89%88.md#4%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%81%8C%E8%B4%A3" target="_blank" rel="noreferrer">4、模式的职责</a> <a class="header-anchor" href="#_4、模式的职责" aria-label="Permalink to &quot;[4、模式的职责](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java高级面试题及答案，最新版.md#4模式的职责)&quot;">​</a></h3><p>观察者模式主要用于1对N的通知。当一个对象的状态变化时，他需要及时告知一系列对象，令他们做出相应。</p><p><strong>实现有两种方式：</strong></p><p><strong>1、推：</strong></p><p>每次都会把通知以广播的方式发送给所有观察者，所有的观察者只能被动接收。</p><p><strong>2、拉：</strong></p><p>观察者只要知道有情况即可，至于什么时候获取内容，获取什么内容，都可以自主决定。</p><h3 id="_5、jre、jdk、jvm-及-jit-之间有什么不同" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%9C%80%E6%96%B0%E7%89%88.md#5jrejdkjvm-%E5%8F%8A-jit-%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C" target="_blank" rel="noreferrer">5、JRE、JDK、JVM 及 JIT 之间有什么不同？</a> <a class="header-anchor" href="#_5、jre、jdk、jvm-及-jit-之间有什么不同" aria-label="Permalink to &quot;[5、JRE、JDK、JVM 及 JIT 之间有什么不同？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java高级面试题及答案，最新版.md#5jrejdkjvm-及-jit-之间有什么不同)&quot;">​</a></h3><p>JRE 代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。</p><h3 id="_6、java-面试中其他各式各样的问题" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%9C%80%E6%96%B0%E7%89%88.md#6java-%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%85%B6%E4%BB%96%E5%90%84%E5%BC%8F%E5%90%84%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98" target="_blank" rel="noreferrer">6、Java 面试中其他各式各样的问题</a> <a class="header-anchor" href="#_6、java-面试中其他各式各样的问题" aria-label="Permalink to &quot;[6、Java 面试中其他各式各样的问题](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java高级面试题及答案，最新版.md#6java-面试中其他各式各样的问题)&quot;">​</a></h3><p>这部分包含 Java 中关于 XML 的面试题，正则表达式面试题，Java 错误和异常及序列化面试题</p><h3 id="_7、程序计数器是什么" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%9C%80%E6%96%B0%E7%89%88.md#7%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noreferrer">7、程序计数器是什么？</a> <a class="header-anchor" href="#_7、程序计数器是什么" aria-label="Permalink to &quot;[7、程序计数器是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java高级面试题及答案，最新版.md#7程序计数器是什么)&quot;">​</a></h3><p><strong>程序计数器</strong>是一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器。字节码解释器工作时通过改变计数器的值选取下一条执行指令。分支、循环、跳转、线程恢复等功能都需要依赖计数器完成。是唯一在虚拟机规范中没有规定内存溢出情况的区域。</p><p>如果线程正在执行 Java 方法，计数器记录正在执行的虚拟机字节码指令地址。如果是本地方法，计数器值为 Undefined。</p><h3 id="_8、java-内存分配" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%9C%80%E6%96%B0%E7%89%88.md#8java-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D" target="_blank" rel="noreferrer">8、Java 内存分配</a> <a class="header-anchor" href="#_8、java-内存分配" aria-label="Permalink to &quot;[8、Java 内存分配](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java高级面试题及答案，最新版.md#8java-内存分配)&quot;">​</a></h3><p>寄存器：我们无法控制。</p><p>静态域：static定义的静态成员。</p><p>常量池：编译时被确定并保存在 .class 文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符）。</p><p>非 RAM 存储：硬盘等永久存储空间。</p><p>堆内存：new 创建的对象和数组，由 Java 虚拟机自动垃圾回收器管理,存取速度慢。</p><p>栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性。</p><h3 id="_9、新生代与复制算法" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%9C%80%E6%96%B0%E7%89%88.md#9%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95" target="_blank" rel="noreferrer">9、新生代与复制算法</a> <a class="header-anchor" href="#_9、新生代与复制算法" aria-label="Permalink to &quot;[9、新生代与复制算法](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java高级面试题及答案，最新版.md#9新生代与复制算法)&quot;">​</a></h3><p>目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p><h3 id="_10、java-中怎么获取一份线程-dump-文件" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%9C%80%E6%96%B0%E7%89%88.md#10java-%E4%B8%AD%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%B8%80%E4%BB%BD%E7%BA%BF%E7%A8%8B-dump-%E6%96%87%E4%BB%B6" target="_blank" rel="noreferrer">10、Java 中怎么获取一份线程 dump 文件？</a> <a class="header-anchor" href="#_10、java-中怎么获取一份线程-dump-文件" aria-label="Permalink to &quot;[10、Java 中怎么获取一份线程 dump 文件？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java高级面试题及答案，最新版.md#10java-中怎么获取一份线程-dump-文件)&quot;">​</a></h3><p>在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java 应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。如果你使用Tomcat。</p><h3 id="_11、那些地方用到了单例模式" tabindex="-1">11、那些地方用到了单例模式 <a class="header-anchor" href="#_11、那些地方用到了单例模式" aria-label="Permalink to &quot;11、那些地方用到了单例模式&quot;">​</a></h3><h3 id="_12、什么是原子类" tabindex="-1">12、什么是原子类 <a class="header-anchor" href="#_12、什么是原子类" aria-label="Permalink to &quot;12、什么是原子类&quot;">​</a></h3><h3 id="_13、永久代" tabindex="-1">13、永久代 <a class="header-anchor" href="#_13、永久代" aria-label="Permalink to &quot;13、永久代&quot;">​</a></h3><h3 id="_14、semaphore有什么作用" tabindex="-1">14、Semaphore有什么作用 <a class="header-anchor" href="#_14、semaphore有什么作用" aria-label="Permalink to &quot;14、Semaphore有什么作用&quot;">​</a></h3><h3 id="_15、什么是同步任务-什么是异步任务" tabindex="-1">15、什么是同步任务？什么是异步任务？ <a class="header-anchor" href="#_15、什么是同步任务-什么是异步任务" aria-label="Permalink to &quot;15、什么是同步任务？什么是异步任务？&quot;">​</a></h3><h3 id="_16、import-java和javax有什么区别" tabindex="-1">16、import java和javax有什么区别 <a class="header-anchor" href="#_16、import-java和javax有什么区别" aria-label="Permalink to &quot;16、import java和javax有什么区别&quot;">​</a></h3><h3 id="_17、什么是单例" tabindex="-1">17、什么是单例 <a class="header-anchor" href="#_17、什么是单例" aria-label="Permalink to &quot;17、什么是单例&quot;">​</a></h3><h3 id="_18、什么是线程池" tabindex="-1">18、什么是线程池？ <a class="header-anchor" href="#_18、什么是线程池" aria-label="Permalink to &quot;18、什么是线程池？&quot;">​</a></h3><h3 id="_19、程序计数器" tabindex="-1">19、程序计数器 <a class="header-anchor" href="#_19、程序计数器" aria-label="Permalink to &quot;19、程序计数器&quot;">​</a></h3><h3 id="_20、什么是外观模式" tabindex="-1">20、什么是外观模式 <a class="header-anchor" href="#_20、什么是外观模式" aria-label="Permalink to &quot;20、什么是外观模式&quot;">​</a></h3><h3 id="_21、copyonwritearraylist-是什么" tabindex="-1">21、CopyOnWriteArrayList 是什么? <a class="header-anchor" href="#_21、copyonwritearraylist-是什么" aria-label="Permalink to &quot;21、CopyOnWriteArrayList 是什么?&quot;">​</a></h3><h3 id="_22、判断两个对象是否相同-能使用equlas比较吗" tabindex="-1">22、判断两个对象是否相同，能使用equlas比较吗？ <a class="header-anchor" href="#_22、判断两个对象是否相同-能使用equlas比较吗" aria-label="Permalink to &quot;22、判断两个对象是否相同，能使用equlas比较吗？&quot;">​</a></h3><h3 id="_23、遇到过元空间溢出吗" tabindex="-1">23、遇到过元空间溢出吗？ <a class="header-anchor" href="#_23、遇到过元空间溢出吗" aria-label="Permalink to &quot;23、遇到过元空间溢出吗？&quot;">​</a></h3><h3 id="_24、你能保证-gc-执行吗" tabindex="-1">24、你能保证 GC 执行吗？ <a class="header-anchor" href="#_24、你能保证-gc-执行吗" aria-label="Permalink to &quot;24、你能保证 GC 执行吗？&quot;">​</a></h3><h3 id="_25、gc的回收流程是怎样的" tabindex="-1">25、GC的回收流程是怎样的？ <a class="header-anchor" href="#_25、gc的回收流程是怎样的" aria-label="Permalink to &quot;25、GC的回收流程是怎样的？&quot;">​</a></h3><h3 id="_26、collection-和-collections-有什么区别" tabindex="-1">26、Collection 和 Collections 有什么区别？ <a class="header-anchor" href="#_26、collection-和-collections-有什么区别" aria-label="Permalink to &quot;26、Collection 和 Collections 有什么区别？&quot;">​</a></h3><h3 id="_27、并发编程有什么缺点" tabindex="-1">27、并发编程有什么缺点 <a class="header-anchor" href="#_27、并发编程有什么缺点" aria-label="Permalink to &quot;27、并发编程有什么缺点&quot;">​</a></h3><h3 id="_28、内存溢出和内存泄漏的区别" tabindex="-1">28、内存溢出和内存泄漏的区别？ <a class="header-anchor" href="#_28、内存溢出和内存泄漏的区别" aria-label="Permalink to &quot;28、内存溢出和内存泄漏的区别？&quot;">​</a></h3><h3 id="_29、当父类引用指向子类对象的时候-子类重写了父类方法和属性-那么当访问属性的时候-访问是谁的属性-调用方法时-调用的是谁的方法" tabindex="-1">29、当父类引用指向子类对象的时候，子类重写了父类方法和属性，那么当访问属性的时候，访问是谁的属性？调用方法时，调用的是谁的方法？ <a class="header-anchor" href="#_29、当父类引用指向子类对象的时候-子类重写了父类方法和属性-那么当访问属性的时候-访问是谁的属性-调用方法时-调用的是谁的方法" aria-label="Permalink to &quot;29、当父类引用指向子类对象的时候，子类重写了父类方法和属性，那么当访问属性的时候，访问是谁的属性？调用方法时，调用的是谁的方法？&quot;">​</a></h3><h3 id="_30、jre、jdk、jvm-及-jit-之间有什么不同" tabindex="-1">30、JRE、JDK、JVM 及 JIT 之间有什么不同？ <a class="header-anchor" href="#_30、jre、jdk、jvm-及-jit-之间有什么不同" aria-label="Permalink to &quot;30、JRE、JDK、JVM 及 JIT 之间有什么不同？&quot;">​</a></h3><h3 id="_31、解释-java-堆空间及-gc" tabindex="-1">31、解释 Java 堆空间及 GC？ <a class="header-anchor" href="#_31、解释-java-堆空间及-gc" aria-label="Permalink to &quot;31、解释 Java 堆空间及 GC？&quot;">​</a></h3><h3 id="_32、在java中cyclibarriar和countdownlatch有什么区别" tabindex="-1">32、在Java中CycliBarriar和CountdownLatch有什么区别？ <a class="header-anchor" href="#_32、在java中cyclibarriar和countdownlatch有什么区别" aria-label="Permalink to &quot;32、在Java中CycliBarriar和CountdownLatch有什么区别？&quot;">​</a></h3><h3 id="_33、java线程池中submit-和-execute-方法有什么区别" tabindex="-1">33、Java线程池中submit() 和 execute()方法有什么区别？ <a class="header-anchor" href="#_33、java线程池中submit-和-execute-方法有什么区别" aria-label="Permalink to &quot;33、Java线程池中submit() 和 execute()方法有什么区别？&quot;">​</a></h3><h3 id="_34、什么是内存屏障" tabindex="-1">34、什么是内存屏障？ <a class="header-anchor" href="#_34、什么是内存屏障" aria-label="Permalink to &quot;34、什么是内存屏障？&quot;">​</a></h3><h3 id="_35、打印昨天的当前时刻。" tabindex="-1">35、打印昨天的当前时刻。 <a class="header-anchor" href="#_35、打印昨天的当前时刻。" aria-label="Permalink to &quot;35、打印昨天的当前时刻。&quot;">​</a></h3><h3 id="_36、string和stringbuilder、stringbuffer的区别" tabindex="-1">36、String和StringBuilder、StringBuffer的区别？ <a class="header-anchor" href="#_36、string和stringbuilder、stringbuffer的区别" aria-label="Permalink to &quot;36、String和StringBuilder、StringBuffer的区别？&quot;">​</a></h3><h3 id="_37、建造者模式的使用场景" tabindex="-1">37、建造者模式的使用场景 <a class="header-anchor" href="#_37、建造者模式的使用场景" aria-label="Permalink to &quot;37、建造者模式的使用场景&quot;">​</a></h3><h3 id="_38、serial-old-收集器-单线程标记整理算法" tabindex="-1">38、Serial Old 收集器（单线程标记整理算法 ） <a class="header-anchor" href="#_38、serial-old-收集器-单线程标记整理算法" aria-label="Permalink to &quot;38、Serial Old 收集器（单线程标记整理算法 ）&quot;">​</a></h3><h3 id="_39、java-concurrency-api中的lock接口-lock-interface-是什么-对比同步它有什么优势" tabindex="-1">39、Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？ <a class="header-anchor" href="#_39、java-concurrency-api中的lock接口-lock-interface-是什么-对比同步它有什么优势" aria-label="Permalink to &quot;39、Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？&quot;">​</a></h3><h3 id="_40、策略模式应用场景" tabindex="-1">40、策略模式应用场景 <a class="header-anchor" href="#_40、策略模式应用场景" aria-label="Permalink to &quot;40、策略模式应用场景&quot;">​</a></h3>',65),l=[i];function n(h,s,E,c,d,u){return e(),r("div",null,l)}const m=a(t,[["render",n]]);export{b as __pageData,m as default};
