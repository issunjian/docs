import{_ as a,o as t,c as e,V as o}from"./chunks/framework.c6d8cbec.js";const B=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/java/java-25.md","filePath":"interview/backend/java/java-25.md"}'),r={name:"interview/backend/java/java-25.md"},s=o('<h3 id="_1、js如何实现页面刷新呢" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E9%99%84%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#1js%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E5%91%A2" target="_blank" rel="noreferrer">1、js如何实现页面刷新呢？</a> <a class="header-anchor" href="#_1、js如何实现页面刷新呢" aria-label="Permalink to &quot;[1、js如何实现页面刷新呢？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java最新面试题及答案附答案汇总.md#1js如何实现页面刷新呢)&quot;">​</a></h3><p><strong>1、</strong> history.go(0)</p><p><strong>2、</strong> location.reload()</p><h3 id="_2、什么是线程池" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E9%99%84%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#2%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0" target="_blank" rel="noreferrer">2、什么是线程池？</a> <a class="header-anchor" href="#_2、什么是线程池" aria-label="Permalink to &quot;[2、什么是线程池？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java最新面试题及答案附答案汇总.md#2什么是线程池)&quot;">​</a></h3><p>在一个应用程序中初始化一个线程集合，然后在需要执行新的任务时重用线程池中的线程，而不是创建一个新的线程。线程池中的每个线程都有被分配一个任务，一旦任务完成，线程就回到线程池中，等待下一次的任务分配</p><h3 id="_3、如何实现-array-和-list-之间的转换" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E9%99%84%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#3%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-array-%E5%92%8C-list-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2" target="_blank" rel="noreferrer">3、如何实现 Array 和 List 之间的转换？</a> <a class="header-anchor" href="#_3、如何实现-array-和-list-之间的转换" aria-label="Permalink to &quot;[3、如何实现 Array 和 List 之间的转换？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java最新面试题及答案附答案汇总.md#3如何实现-array-和-list-之间的转换)&quot;">​</a></h3><p><strong>1、</strong> Array 转 List： Arrays、asList(array) ；</p><p><strong>2、</strong> List 转 Array：List 的 toArray() 方法。</p><h3 id="_4、普通类和抽象类有哪些区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E9%99%84%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#4%E6%99%AE%E9%80%9A%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">4、普通类和抽象类有哪些区别？</a> <a class="header-anchor" href="#_4、普通类和抽象类有哪些区别" aria-label="Permalink to &quot;[4、普通类和抽象类有哪些区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java最新面试题及答案附答案汇总.md#4普通类和抽象类有哪些区别)&quot;">​</a></h3><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。 抽象类不能直接实例化，普通类可以直接实例化。</p><h3 id="_5、为什么线程通信的方法wait-notify-和notifyall-被定义在object-类里" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E9%99%84%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#5%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95wait,-notify%E5%92%8Cnotifyall%E8%A2%AB%E5%AE%9A%E4%B9%89%E5%9C%A8object-%E7%B1%BB%E9%87%8C" target="_blank" rel="noreferrer">5、为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object 类里？</a> <a class="header-anchor" href="#_5、为什么线程通信的方法wait-notify-和notifyall-被定义在object-类里" aria-label="Permalink to &quot;[5、为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object 类里？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java最新面试题及答案附答案汇总.md#5为什么线程通信的方法wait,-notify和notifyall被定义在object-类里)&quot;">​</a></h3><p>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。</p><h3 id="_6、遍历一个-list-有哪些不同的方式-每种方法的实现原理是什么-java-中-list-遍历的最佳实践是什么" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E9%99%84%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#6%E9%81%8D%E5%8E%86%E4%B8%80%E4%B8%AA-list-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E5%BC%8F%E6%AF%8F%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88java-%E4%B8%AD-list-%E9%81%8D%E5%8E%86%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noreferrer">6、遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</a> <a class="header-anchor" href="#_6、遍历一个-list-有哪些不同的方式-每种方法的实现原理是什么-java-中-list-遍历的最佳实践是什么" aria-label="Permalink to &quot;[6、遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java最新面试题及答案附答案汇总.md#6遍历一个-list-有哪些不同的方式每种方法的实现原理是什么java-中-list-遍历的最佳实践是什么)&quot;">​</a></h3><p><strong>遍历方式有以下几种：</strong></p><p><strong>1、</strong> for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</p><p><strong>2、</strong> 迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</p><p><strong>3、</strong> foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</p><p><strong>最佳实践：</strong></p><p>Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p><p><strong>1、</strong> 如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</p><p><strong>2、</strong> 如果没有实现该接口，表示不支持 Random Access，如LinkedList。</p><p><strong>3、</strong> 推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</p><h3 id="_7、string-str-i-与-string-str-new-string-i-一样吗" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E9%99%84%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#7string-str=%22i%22%E4%B8%8E-string-str=new-string%22i%22%E4%B8%80%E6%A0%B7%E5%90%97" target="_blank" rel="noreferrer">7、String str=&quot;i&quot;与 String str=new String(&quot;i&quot;)一样吗？</a> <a class="header-anchor" href="#_7、string-str-i-与-string-str-new-string-i-一样吗" aria-label="Permalink to &quot;[7、String str=&quot;i&quot;与 String str=new String(&quot;i&quot;)一样吗？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java最新面试题及答案附答案汇总.md#7string-str=&quot;i&quot;与-string-str=new-string&quot;i&quot;一样吗)&quot;">​</a></h3><p>不一样，因为内存的分配方式不一样。String str=&quot;i&quot;的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(&quot;i&quot;) 则会被分到堆内存中。</p><h3 id="_8、用过concurrenthashmap-讲一下他和hashtable的不同之处" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E9%99%84%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#8%E7%94%A8%E8%BF%87concurrenthashmap%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BB%96%E5%92%8Chashtable%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84" target="_blank" rel="noreferrer">8、用过ConcurrentHashMap，讲一下他和HashTable的不同之处？</a> <a class="header-anchor" href="#_8、用过concurrenthashmap-讲一下他和hashtable的不同之处" aria-label="Permalink to &quot;[8、用过ConcurrentHashMap，讲一下他和HashTable的不同之处？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java最新面试题及答案附答案汇总.md#8用过concurrenthashmap讲一下他和hashtable的不同之处)&quot;">​</a></h3><p>ConcurrentHashMap是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组结构和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p><p><strong>看不懂？？？很正常，我也看不懂</strong></p><p><strong>总结：</strong></p><p><strong>1、</strong> HashTable就是实现了HashMap加上了synchronized，而ConcurrentHashMap底层采用分段的数组+链表实现，线程安全</p><p><strong>2、</strong> ConcurrentHashMap通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</p><p><strong>3、</strong> 并且读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。</p><p><strong>4、</strong> Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术</p><p><strong>5、</strong> 扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容</p><h3 id="_9、线程的基本状态以及状态之间的关系" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E9%99%84%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#9%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB" target="_blank" rel="noreferrer">9、线程的基本状态以及状态之间的关系？</a> <a class="header-anchor" href="#_9、线程的基本状态以及状态之间的关系" aria-label="Permalink to &quot;[9、线程的基本状态以及状态之间的关系？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java最新面试题及答案附答案汇总.md#9线程的基本状态以及状态之间的关系)&quot;">​</a></h3><p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2019/08/0816/03/img_2.png#alt=img%5C_2.png" alt=""></p><blockquote><p>说明：其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。</p></blockquote><h3 id="_10、线程池中-submit-和-execute-方法有什么区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E9%99%84%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#10%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD-submit-%E5%92%8C-execute-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">10、线程池中 submit() 和 execute() 方法有什么区别？</a> <a class="header-anchor" href="#_10、线程池中-submit-和-execute-方法有什么区别" aria-label="Permalink to &quot;[10、线程池中 submit() 和 execute() 方法有什么区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java最新面试题及答案附答案汇总.md#10线程池中-submit-和-execute-方法有什么区别)&quot;">​</a></h3><p><strong>相同点：</strong></p><p>相同点就是都可以开启线程执行池中的任务。</p><p><strong>不同点：</strong></p><p><strong>1、</strong> 接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务。</p><p><strong>2、</strong> 返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有</p><p><strong>3、</strong> 异常处理：submit()方便Exception处理</p><h3 id="_11、工厂模式分类" tabindex="-1">11、工厂模式分类 <a class="header-anchor" href="#_11、工厂模式分类" aria-label="Permalink to &quot;11、工厂模式分类&quot;">​</a></h3><h3 id="_12、gc-roots-有哪些" tabindex="-1">12、GC Roots 有哪些？ <a class="header-anchor" href="#_12、gc-roots-有哪些" aria-label="Permalink to &quot;12、GC Roots 有哪些？&quot;">​</a></h3><h3 id="_13、static关键字有什么作用" tabindex="-1">13、Static关键字有什么作用？ <a class="header-anchor" href="#_13、static关键字有什么作用" aria-label="Permalink to &quot;13、Static关键字有什么作用？&quot;">​</a></h3><h3 id="_14、如何部署一个web项目" tabindex="-1">14、如何部署一个web项目？ <a class="header-anchor" href="#_14、如何部署一个web项目" aria-label="Permalink to &quot;14、如何部署一个web项目？&quot;">​</a></h3><h3 id="_15、jsp由哪些内容组成" tabindex="-1">15、Jsp由哪些内容组成？ <a class="header-anchor" href="#_15、jsp由哪些内容组成" aria-label="Permalink to &quot;15、Jsp由哪些内容组成？&quot;">​</a></h3><h3 id="_16、为什么你应该在循环中检查等待条件" tabindex="-1">16、为什么你应该在循环中检查等待条件? <a class="header-anchor" href="#_16、为什么你应该在循环中检查等待条件" aria-label="Permalink to &quot;16、为什么你应该在循环中检查等待条件?&quot;">​</a></h3><h3 id="_17、重载和重写的区别" tabindex="-1">17、重载和重写的区别 <a class="header-anchor" href="#_17、重载和重写的区别" aria-label="Permalink to &quot;17、重载和重写的区别&quot;">​</a></h3><h3 id="_18、什么是future" tabindex="-1">18、什么是Future？ <a class="header-anchor" href="#_18、什么是future" aria-label="Permalink to &quot;18、什么是Future？&quot;">​</a></h3><h3 id="_19、请说明select-from-tab的输出结果是什么" tabindex="-1">19、请说明select * from tab的输出结果是什么? <a class="header-anchor" href="#_19、请说明select-from-tab的输出结果是什么" aria-label="Permalink to &quot;19、请说明select * from tab的输出结果是什么?&quot;">​</a></h3><h3 id="_20、jvm-提供的常用工具" tabindex="-1">20、JVM 提供的常用工具 <a class="header-anchor" href="#_20、jvm-提供的常用工具" aria-label="Permalink to &quot;20、JVM 提供的常用工具&quot;">​</a></h3><h3 id="_21、cyclicbarrier和countdownlatch的区别" tabindex="-1">21、CyclicBarrier和CountDownLatch的区别 <a class="header-anchor" href="#_21、cyclicbarrier和countdownlatch的区别" aria-label="Permalink to &quot;21、CyclicBarrier和CountDownLatch的区别&quot;">​</a></h3><h3 id="_22、collection-和-collections-有什么区别" tabindex="-1">22、Collection 和 Collections 有什么区别？ <a class="header-anchor" href="#_22、collection-和-collections-有什么区别" aria-label="Permalink to &quot;22、Collection 和 Collections 有什么区别？&quot;">​</a></h3><h3 id="_23、safepoint-是什么" tabindex="-1">23、safepoint 是什么？ <a class="header-anchor" href="#_23、safepoint-是什么" aria-label="Permalink to &quot;23、safepoint 是什么？&quot;">​</a></h3><h3 id="_24、list、map、set三个接口存取元素时-各有什么特点" tabindex="-1">24、List、Map、Set三个接口存取元素时，各有什么特点？ <a class="header-anchor" href="#_24、list、map、set三个接口存取元素时-各有什么特点" aria-label="Permalink to &quot;24、List、Map、Set三个接口存取元素时，各有什么特点？&quot;">​</a></h3><h3 id="_25、什么是线程池-thread-pool" tabindex="-1">25、什么是线程池（thread pool）？ <a class="header-anchor" href="#_25、什么是线程池-thread-pool" aria-label="Permalink to &quot;25、什么是线程池（thread pool）？&quot;">​</a></h3><h3 id="_26、什么是executors框架" tabindex="-1">26、什么是Executors框架？ <a class="header-anchor" href="#_26、什么是executors框架" aria-label="Permalink to &quot;26、什么是Executors框架？&quot;">​</a></h3><h3 id="_27、java中synchronized关键字的使用" tabindex="-1">27、Java中Synchronized关键字的使用？ <a class="header-anchor" href="#_27、java中synchronized关键字的使用" aria-label="Permalink to &quot;27、Java中Synchronized关键字的使用？&quot;">​</a></h3><h3 id="_28、对象的内存布局了解吗" tabindex="-1">28、对象的内存布局了解吗？ <a class="header-anchor" href="#_28、对象的内存布局了解吗" aria-label="Permalink to &quot;28、对象的内存布局了解吗？&quot;">​</a></h3><h3 id="_29、什么是链表" tabindex="-1">29、什么是链表 <a class="header-anchor" href="#_29、什么是链表" aria-label="Permalink to &quot;29、什么是链表&quot;">​</a></h3><h3 id="_30、tcp-协议与-udp-协议有什么区别" tabindex="-1">30、TCP 协议与 UDP 协议有什么区别？ <a class="header-anchor" href="#_30、tcp-协议与-udp-协议有什么区别" aria-label="Permalink to &quot;30、TCP 协议与 UDP 协议有什么区别？&quot;">​</a></h3><h3 id="_31、代理模式应用场景" tabindex="-1">31、代理模式应用场景 <a class="header-anchor" href="#_31、代理模式应用场景" aria-label="Permalink to &quot;31、代理模式应用场景&quot;">​</a></h3><h3 id="_32、super与this表示什么" tabindex="-1">32、Super与this表示什么？ <a class="header-anchor" href="#_32、super与this表示什么" aria-label="Permalink to &quot;32、Super与this表示什么？&quot;">​</a></h3><h3 id="_33、volatile-能使得一个非原子操作变成原子操作吗" tabindex="-1">33、volatile 能使得一个非原子操作变成原子操作吗？ <a class="header-anchor" href="#_33、volatile-能使得一个非原子操作变成原子操作吗" aria-label="Permalink to &quot;33、volatile 能使得一个非原子操作变成原子操作吗？&quot;">​</a></h3><h3 id="_34、可以描述一下-class-文件的结构吗" tabindex="-1">34、可以描述一下 class 文件的结构吗？ <a class="header-anchor" href="#_34、可以描述一下-class-文件的结构吗" aria-label="Permalink to &quot;34、可以描述一下 class 文件的结构吗？&quot;">​</a></h3><h3 id="_35、聚集索引与非聚集索引有什么区别" tabindex="-1">35、聚集索引与非聚集索引有什么区别？ <a class="header-anchor" href="#_35、聚集索引与非聚集索引有什么区别" aria-label="Permalink to &quot;35、聚集索引与非聚集索引有什么区别？&quot;">​</a></h3><h3 id="_36、java为什么需要接口" tabindex="-1">36、JAVA为什么需要接口？ <a class="header-anchor" href="#_36、java为什么需要接口" aria-label="Permalink to &quot;36、JAVA为什么需要接口？&quot;">​</a></h3><h3 id="_37、你知道哪些gc类型" tabindex="-1">37、你知道哪些GC类型？ <a class="header-anchor" href="#_37、你知道哪些gc类型" aria-label="Permalink to &quot;37、你知道哪些GC类型？&quot;">​</a></h3><h3 id="_38、62、volatile-变量和-atomic-变量有什么不同" tabindex="-1">38、62、volatile 变量和 atomic 变量有什么不同？ <a class="header-anchor" href="#_38、62、volatile-变量和-atomic-变量有什么不同" aria-label="Permalink to &quot;38、62、volatile 变量和 atomic 变量有什么不同？&quot;">​</a></h3><h3 id="_39、hashset如何检查重复-hashset是如何保证数据不可重复的" tabindex="-1">39、HashSet如何检查重复？HashSet是如何保证数据不可重复的？ <a class="header-anchor" href="#_39、hashset如何检查重复-hashset是如何保证数据不可重复的" aria-label="Permalink to &quot;39、HashSet如何检查重复？HashSet是如何保证数据不可重复的？&quot;">​</a></h3><h3 id="_40、volatile有什么用-能否用一句话说明下volatile的应用场景" tabindex="-1">40、volatile有什么用？能否用一句话说明下volatile的应用场景？ <a class="header-anchor" href="#_40、volatile有什么用-能否用一句话说明下volatile的应用场景" aria-label="Permalink to &quot;40、volatile有什么用？能否用一句话说明下volatile的应用场景？&quot;">​</a></h3><h3 id="_41、异常的处理机制有几种" tabindex="-1">41、异常的处理机制有几种？ <a class="header-anchor" href="#_41、异常的处理机制有几种" aria-label="Permalink to &quot;41、异常的处理机制有几种？&quot;">​</a></h3>',74),n=[s];function i(l,h,E,c,u,d){return t(),e("div",null,n)}const A=a(r,[["render",i]]);export{B as __pageData,A as default};
