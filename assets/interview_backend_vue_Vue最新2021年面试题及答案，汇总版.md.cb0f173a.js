import{_ as e,o as a,c as o,V as s}from"./chunks/framework.c6d8cbec.js";const B=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/vue/Vue最新2021年面试题及答案，汇总版.md","filePath":"interview/backend/vue/Vue最新2021年面试题及答案，汇总版.md"}'),t={name:"interview/backend/vue/Vue最新2021年面试题及答案，汇总版.md"},r=s(`<h3 id="_1、vue的自定义指令" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#1vue%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4" target="_blank" rel="noreferrer">1、vue的自定义指令？</a> <a class="header-anchor" href="#_1、vue的自定义指令" aria-label="Permalink to &quot;[1、vue的自定义指令？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue最新2021年面试题及答案，汇总版.md#1vue的自定义指令)&quot;">​</a></h3><p>自定义指令分为全局指令和组件指令，其中全局指令需要使用directive来进行定义，组件指令需要使用directives来进行定义，具体定义方法同过滤器filter或者其他生命周期，具体使用方法如下：</p><p>全局自定义指令 directive(name,{})，其中name表示定义的指令名称（定义指令的时候不需要带v-，但是在调用的时候需要哦带v-），第二个参数是一个对象，对象中包括五个自定义组件的钩子函数，具体包括：</p><p>**bind函数：**只调用一次，指令第一次绑定在元素上调用，即初始化调用一次，</p><p>**inserted函数：**并绑定元素插入父级元素（即new vue中el绑定的元素）时调用（此时父级元素不一定转化为了dom）</p><p>**update函数：**在元素发生更新时就会调用，可以通过比较新旧的值来进行逻辑处理</p><p>**componentUpdated函数：**元素更新完成后触发一次</p><p>**unbind函数：**在元素所在的模板删除的时候就触发一次</p><p>钩子函数对应的参数el,binding,vnode,oldnode,具体参数讲解如下：</p><p><strong>a、el指令所绑定的元素 可以直接操组dom元素</strong></p><p><strong>b、binding一个对象，具体包括以下属性：</strong></p><p><strong>1、</strong> name：定义的指令名称 不包括v-</p><p><strong>2、</strong> value：指令的绑定值，如果绑定的是一个计算式，value为对应计算结果</p><p><strong>3、</strong> oldvalue：指令绑定元素的前一个值，只对update和componentUpdated钩子函数有值</p><p><strong>4、</strong> expression：指令绑定的原始值 不对值进行任何加工</p><p><strong>5、</strong> arg：传递给指令的参数</p><p><strong>6、</strong> modifiers：指令修饰符，如：v-focus.show.async 则接收的modifiers为｛show：true，async：true｝</p><p><strong>c、vnode：vue编译生成的虚拟dom</strong></p><p><strong>d、oldVnode：上一个vnode，只在update和componentUpdated钩子函数中有效</strong></p><p>如果不需要其他钩子函数，可以直接简写为：directive(“focus”,function(el,binding){})</p><h3 id="_2、你是怎么认识vuex的" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#2%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%A4%E8%AF%86vuex%E7%9A%84" target="_blank" rel="noreferrer">2、你是怎么认识vuex的？</a> <a class="header-anchor" href="#_2、你是怎么认识vuex的" aria-label="Permalink to &quot;[2、你是怎么认识vuex的？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue最新2021年面试题及答案，汇总版.md#2你是怎么认识vuex的)&quot;">​</a></h3><p>vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。</p><p>通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。</p><p>应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。</p><h3 id="_3、vue单页面和传统的多页面区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#3vue%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%92%8C%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">3、vue单页面和传统的多页面区别？</a> <a class="header-anchor" href="#_3、vue单页面和传统的多页面区别" aria-label="Permalink to &quot;[3、vue单页面和传统的多页面区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue最新2021年面试题及答案，汇总版.md#3vue单页面和传统的多页面区别)&quot;">​</a></h3><p><strong>单页面应用（SPA）</strong></p><p>通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。</p><p><strong>多页面（MPA）</strong></p><p>指一个应用中有多个页面，页面跳转时是整页刷新</p><p><strong>单页面的优点：</strong></p><p>用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。</p><p><strong>单页面缺点：</strong></p><p>不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多。</p><h3 id="_4、mint-ui是什么-怎么使用-说出至少三个组件使用方法" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#4mint-ui%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E8%AF%B4%E5%87%BA%E8%87%B3%E5%B0%91%E4%B8%89%E4%B8%AA%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" target="_blank" rel="noreferrer">4、mint-ui是什么？怎么使用？说出至少三个组件使用方法？</a> <a class="header-anchor" href="#_4、mint-ui是什么-怎么使用-说出至少三个组件使用方法" aria-label="Permalink to &quot;[4、mint-ui是什么？怎么使用？说出至少三个组件使用方法？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue最新2021年面试题及答案，汇总版.md#4mint-ui是什么怎么使用说出至少三个组件使用方法)&quot;">​</a></h3><p>基于vue的前端组件库。npm安装，然后import样式和js，vue.use（mintUi）全局引入。在单个组件局部引入：import {Toast} from ‘mint-ui’。</p><p><strong>1、</strong> 组件一：Toast(‘登录成功’)；</p><p><strong>2、</strong> 组件二：mint-header；</p><p><strong>3、</strong> 组件三：mint-swiper</p><h3 id="_5、vue-loader是什么-使用它的用途有哪些" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#5vue-loader%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%AE%83%E7%9A%84%E7%94%A8%E9%80%94%E6%9C%89%E5%93%AA%E4%BA%9B" target="_blank" rel="noreferrer">5、vue-loader是什么？使用它的用途有哪些？</a> <a class="header-anchor" href="#_5、vue-loader是什么-使用它的用途有哪些" aria-label="Permalink to &quot;[5、vue-loader是什么？使用它的用途有哪些？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue最新2021年面试题及答案，汇总版.md#5vue-loader是什么使用它的用途有哪些)&quot;">​</a></h3><p>vue文件的一个加载器，将template/js/style转换成js模块。</p><p>用途：js可以写es6、style样式可以scss或less、template可以加jade等</p><h3 id="_6、-route-和-router-的区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#6$route-%E5%92%8C-$router-%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">6、$route 和 $router 的区别</a> <a class="header-anchor" href="#_6、-route-和-router-的区别" aria-label="Permalink to &quot;[6、$route 和 $router 的区别](https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue最新2021年面试题及答案，汇总版.md#6$route-和-$router-的区别)&quot;">​</a></h3><p>$$router是VueRouter的实例，在script标签中想要导航到不同的URL,使用$$router.push方法。返回上一个历史history用$$router.to(-1) $$route为当前router跳转对象。里面可以获取当前路由的name,path,query,parmas等。</p><h3 id="_7、axios是什么-怎么使用-描述使用它实现登录功能的流程" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#7axios%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E6%8F%8F%E8%BF%B0%E4%BD%BF%E7%94%A8%E5%AE%83%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E7%9A%84%E6%B5%81%E7%A8%8B" target="_blank" rel="noreferrer">7、axios是什么？怎么使用？描述使用它实现登录功能的流程？</a> <a class="header-anchor" href="#_7、axios是什么-怎么使用-描述使用它实现登录功能的流程" aria-label="Permalink to &quot;[7、axios是什么？怎么使用？描述使用它实现登录功能的流程？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue最新2021年面试题及答案，汇总版.md#7axios是什么怎么使用描述使用它实现登录功能的流程)&quot;">​</a></h3><p>请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</p><h3 id="_8、vue的路由模式及区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#8vue%E7%9A%84%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">8、vue的路由模式及区别？</a> <a class="header-anchor" href="#_8、vue的路由模式及区别" aria-label="Permalink to &quot;[8、vue的路由模式及区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue最新2021年面试题及答案，汇总版.md#8vue的路由模式及区别)&quot;">​</a></h3><p>hash模式在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；</p><p>特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。</p><p>history模式：history采用HTML5的新特性；</p><p>提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。history 模式下，前端的 URL必须和实际向后端发起请求的URL一致，否则会报404错误</p><h3 id="_9、route和router的区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#9route%E5%92%8Crouter%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">9、route和router的区别？</a> <a class="header-anchor" href="#_9、route和router的区别" aria-label="Permalink to &quot;[9、route和router的区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue最新2021年面试题及答案，汇总版.md#9route和router的区别)&quot;">​</a></h3><p><strong>$router</strong></p><p>router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性,常见的有：</p><p>1）push：向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">// 字符串</span></span>
<span class="line"><span style="color:#f6f6f4;">   this.$router.push(&#39;home&#39;)</span></span>
<span class="line"><span style="color:#f6f6f4;">// 对象</span></span>
<span class="line"><span style="color:#f6f6f4;">   this.$router.push({ path: &#39;home&#39; })</span></span>
<span class="line"><span style="color:#f6f6f4;">// 命名的路由</span></span>
<span class="line"><span style="color:#f6f6f4;">   this.$router.push({ name: &#39;user&#39;, params: { userId: 123 }})</span></span>
<span class="line"><span style="color:#f6f6f4;">// 带查询参数，变成 /register?plan=123</span></span>
<span class="line"><span style="color:#f6f6f4;">   this.$router.push({ path: &#39;register&#39;, query: { plan: &#39;123&#39; }})</span></span>
<span class="line"><span style="color:#f6f6f4;">2）go：页面路由跳转 前进或者后退</span></span>
<span class="line"><span style="color:#f6f6f4;"></span></span>
<span class="line"><span style="color:#f6f6f4;">// 页面路由跳转 前进或者后退</span></span>
<span class="line"><span style="color:#f6f6f4;">this.$router.go(-1) // 后退</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">// 字符串</span></span>
<span class="line"><span style="color:#24292e;">   this.$router.push(&#39;home&#39;)</span></span>
<span class="line"><span style="color:#24292e;">// 对象</span></span>
<span class="line"><span style="color:#24292e;">   this.$router.push({ path: &#39;home&#39; })</span></span>
<span class="line"><span style="color:#24292e;">// 命名的路由</span></span>
<span class="line"><span style="color:#24292e;">   this.$router.push({ name: &#39;user&#39;, params: { userId: 123 }})</span></span>
<span class="line"><span style="color:#24292e;">// 带查询参数，变成 /register?plan=123</span></span>
<span class="line"><span style="color:#24292e;">   this.$router.push({ path: &#39;register&#39;, query: { plan: &#39;123&#39; }})</span></span>
<span class="line"><span style="color:#24292e;">2）go：页面路由跳转 前进或者后退</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">// 页面路由跳转 前进或者后退</span></span>
<span class="line"><span style="color:#24292e;">this.$router.go(-1) // 后退</span></span></code></pre></div><p>3）replace：push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，不会向 history 栈添加一个新的记录</p><p><strong>$route</strong></p><p><strong>1、</strong> $route对象表示当前的路由信息，包含了当前URL解析得到的信息。包含当前的路径、参数、query对象等。</p><p><strong>2、</strong> $route.path：字符串，对应当前路由的路径，总是解析为绝对路径，如 &quot;/foo/bar&quot;。</p><p><strong>3、</strong> $route.params：一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。</p><p><strong>4、</strong> $route.query：一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。</p><p><strong>5、</strong> $route.hash：当前路由的 hash 值 (不带#) ，如果没有 hash 值，则为空字符串。</p><p><strong>6、</strong> $route.fullPath：完成解析后的 URL，包含查询参数和 hash 的完整路径。</p><p><strong>7、</strong> dollar;route.matched：数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</p><p><strong>8、</strong> $route.name：当前路径名字</p><p><strong>9、</strong> $route.meta：路由元信息</p><h3 id="_10、vue2-x和vue3-x渲染器的diff算法分别说一下" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#10vue2x%E5%92%8Cvue3x%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%88%86%E5%88%AB%E8%AF%B4%E4%B8%80%E4%B8%8B" target="_blank" rel="noreferrer">10、Vue2.x和Vue3.x渲染器的diff算法分别说一下</a> <a class="header-anchor" href="#_10、vue2-x和vue3-x渲染器的diff算法分别说一下" aria-label="Permalink to &quot;[10、Vue2.x和Vue3.x渲染器的diff算法分别说一下](https://gitee.com/souyunku/DevBooks/blob/master/docs/Vue/Vue最新2021年面试题及答案，汇总版.md#10vue2x和vue3x渲染器的diff算法分别说一下)&quot;">​</a></h3><p>简单来说，diff算法有以下过程</p><p><strong>1、</strong> 同级比较，再比较子节点</p><p><strong>2、</strong> 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</p><p><strong>3、</strong> 比较都有子节点的情况(核心diff)</p><p><strong>4、</strong> 递归比较子节点</p><p>正常Diff两个树的时间复杂度是<code>O(n^3)</code>，但实际情况下我们很少会进行<code>跨层级的移动DOM</code>，所以Vue将Diff进行了优化，从<code>O(n^3) -&gt; O(n)</code>，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p><p>Vue2的核心Diff算法采用了<code>双端比较</code>的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p><p>Vue3.x借鉴了 <a href="https://github.com/localvoid/ivi" target="_blank" rel="noreferrer">ivi</a>算法和 <a href="https://github.com/infernojs/inferno" target="_blank" rel="noreferrer">inferno</a>算法</p><p>在创建VNode时就确定其类型，以及在<code>mount/patch</code>的过程中采用<code>位运算</code>来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)</p><p>该算法中还运用了<code>动态规划</code>的思想求解最长递归子序列。</p><p>(看到这你还会发现，框架内无处不蕴藏着数据结构和算法的魅力)</p><h3 id="_11、js-中-和-区别是什么" tabindex="-1">11、JS 中 == 和 === 区别是什么？ <a class="header-anchor" href="#_11、js-中-和-区别是什么" aria-label="Permalink to &quot;11、JS 中 == 和 === 区别是什么？&quot;">​</a></h3><h3 id="_12、iframe的优缺点" tabindex="-1">12、iframe的优缺点？ <a class="header-anchor" href="#_12、iframe的优缺点" aria-label="Permalink to &quot;12、iframe的优缺点？&quot;">​</a></h3><h3 id="_13、绑定-html-类时-该如何连接类-假设存在一个元素-process。我们只希望使用名为-isactive-的数据属性动态地切换-btnactive-类。" tabindex="-1">13、绑定 HTML 类时，该如何连接类？假设存在一个元素：Process。我们只希望使用名为 “isActive” 的数据属性动态地切换 btnActive 类。 <a class="header-anchor" href="#_13、绑定-html-类时-该如何连接类-假设存在一个元素-process。我们只希望使用名为-isactive-的数据属性动态地切换-btnactive-类。" aria-label="Permalink to &quot;13、绑定 HTML 类时，该如何连接类？假设存在一个元素：Process。我们只希望使用名为 “isActive” 的数据属性动态地切换 btnActive 类。&quot;">​</a></h3><h3 id="_14、vue更新数组时触发视图更新的方法" tabindex="-1">14、vue更新数组时触发视图更新的方法？ <a class="header-anchor" href="#_14、vue更新数组时触发视图更新的方法" aria-label="Permalink to &quot;14、vue更新数组时触发视图更新的方法？&quot;">​</a></h3><h3 id="_15、js的作用域链是什么及其作用" tabindex="-1">15、JS的作用域链是什么及其作用 <a class="header-anchor" href="#_15、js的作用域链是什么及其作用" aria-label="Permalink to &quot;15、JS的作用域链是什么及其作用&quot;">​</a></h3><h3 id="_16、子组件更新过程" tabindex="-1">16、子组件更新过程 <a class="header-anchor" href="#_16、子组件更新过程" aria-label="Permalink to &quot;16、子组件更新过程&quot;">​</a></h3><h3 id="_17、assets和static的区别" tabindex="-1">17、assets和static的区别 <a class="header-anchor" href="#_17、assets和static的区别" aria-label="Permalink to &quot;17、assets和static的区别&quot;">​</a></h3><h3 id="_18、vue的双向数据绑定原理是什么" tabindex="-1">18、Vue的双向数据绑定原理是什么？ <a class="header-anchor" href="#_18、vue的双向数据绑定原理是什么" aria-label="Permalink to &quot;18、Vue的双向数据绑定原理是什么？&quot;">​</a></h3><h3 id="_19、那你知道vue3-x响应式数据原理吗" tabindex="-1">19、那你知道Vue3.x响应式数据原理吗？ <a class="header-anchor" href="#_19、那你知道vue3-x响应式数据原理吗" aria-label="Permalink to &quot;19、那你知道Vue3.x响应式数据原理吗？&quot;">​</a></h3><h3 id="_20、computed和watch的用法和区别" tabindex="-1">20、computed和watch的用法和区别？ <a class="header-anchor" href="#_20、computed和watch的用法和区别" aria-label="Permalink to &quot;20、computed和watch的用法和区别？&quot;">​</a></h3><h3 id="_21、什么是插槽-slot" tabindex="-1">21、什么是插槽（slot）？ <a class="header-anchor" href="#_21、什么是插槽-slot" aria-label="Permalink to &quot;21、什么是插槽（slot）？&quot;">​</a></h3><h3 id="_22、hash路由和history路由实现原理说一下" tabindex="-1">22、hash路由和history路由实现原理说一下 <a class="header-anchor" href="#_22、hash路由和history路由实现原理说一下" aria-label="Permalink to &quot;22、hash路由和history路由实现原理说一下&quot;">​</a></h3><h3 id="_23、vue-router实现懒加载的方式" tabindex="-1">23、vue-router实现懒加载的方式？ <a class="header-anchor" href="#_23、vue-router实现懒加载的方式" aria-label="Permalink to &quot;23、vue-router实现懒加载的方式？&quot;">​</a></h3><h3 id="_24、vue-router-是什么-它有哪些组件" tabindex="-1">24、vue-router 是什么?它有哪些组件 <a class="header-anchor" href="#_24、vue-router-是什么-它有哪些组件" aria-label="Permalink to &quot;24、vue-router 是什么?它有哪些组件&quot;">​</a></h3><h3 id="_25、再说一下虚拟dom以及key属性的作用" tabindex="-1">25、再说一下虚拟Dom以及key属性的作用 <a class="header-anchor" href="#_25、再说一下虚拟dom以及key属性的作用" aria-label="Permalink to &quot;25、再说一下虚拟Dom以及key属性的作用&quot;">​</a></h3><h3 id="_26、-root、-refs、-parent的使用" tabindex="-1">26、$$root、$$refs、$parent的使用？ <a class="header-anchor" href="#_26、-root、-refs、-parent的使用" aria-label="Permalink to &quot;26、$$root、$$refs、$parent的使用？&quot;">​</a></h3><h3 id="_27、单页面应用和多页面应用区别及优缺点" tabindex="-1">27、单页面应用和多页面应用区别及优缺点 <a class="header-anchor" href="#_27、单页面应用和多页面应用区别及优缺点" aria-label="Permalink to &quot;27、单页面应用和多页面应用区别及优缺点&quot;">​</a></h3>`,95),n=[r];function u(p,i,l,h,c,E){return a(),o("div",null,n)}const m=e(t,[["render",u]]);export{B as __pageData,m as default};
