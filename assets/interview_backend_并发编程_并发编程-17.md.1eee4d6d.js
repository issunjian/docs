import{_ as a,o as e,c as t,V as o}from"./chunks/framework.c6d8cbec.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/并发编程/并发编程-17.md","filePath":"interview/backend/并发编程/并发编程-17.md"}'),r={name:"interview/backend/并发编程/并发编程-17.md"},E=o('<h3 id="_1、如何判断对象可以被回收" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#1%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6" target="_blank" rel="noreferrer">1、如何判断对象可以被回收</a> <a class="header-anchor" href="#_1、如何判断对象可以被回收" aria-label="Permalink to &quot;[1、如何判断对象可以被回收](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题及答案整理，汇总版.md#1如何判断对象可以被回收)&quot;">​</a></h3><p>判断对象是否存活一般有两种方式：</p><p>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p><p>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。</p><h3 id="_2、sleep方法和wait方法有什么区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#2sleep%E6%96%B9%E6%B3%95%E5%92%8Cwait%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">2、sleep方法和wait方法有什么区别?</a> <a class="header-anchor" href="#_2、sleep方法和wait方法有什么区别" aria-label="Permalink to &quot;[2、sleep方法和wait方法有什么区别?](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题及答案整理，汇总版.md#2sleep方法和wait方法有什么区别)&quot;">​</a></h3><p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p><h3 id="_3、jvm-提供的常用工具" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#3jvm-%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7" target="_blank" rel="noreferrer">3、JVM 提供的常用工具</a> <a class="header-anchor" href="#_3、jvm-提供的常用工具" aria-label="Permalink to &quot;[3、JVM 提供的常用工具](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题及答案整理，汇总版.md#3jvm-提供的常用工具)&quot;">​</a></h3><p><strong>jps：</strong></p><p>用来显示本地的 Java 进程，可以查看本地运行着几个 Java 程序，并显示他们的进程号。 命令格式：jps</p><p><strong>jinfo：</strong></p><p>运行环境参数：Java System 属性和 JVM 命令行参数，Java class path 等信息。 命令格式：jinfo 进程 pid</p><p><strong>jstat：</strong></p><p>监视虚拟机各种运行状态信息的命令行工具。 命令格式：jstat -gc 123 250 20</p><p><strong>jstack：</strong></p><p>可以观察到 JVM 中当前所有线程的运行情况和线程当前状态。 命令格式：jstack 进程 pid</p><p><strong>jmap：</strong></p><p>观察运行中的 JVM 物理内存的占用情况（如：产生哪些对象，及其数量）。 命令格式：jmap [option] pid</p><h3 id="_4、乐观锁和悲观锁的理解及如何实现-有哪些实现方式" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#4%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" target="_blank" rel="noreferrer">4、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</a> <a class="header-anchor" href="#_4、乐观锁和悲观锁的理解及如何实现-有哪些实现方式" aria-label="Permalink to &quot;[4、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题及答案整理，汇总版.md#4乐观锁和悲观锁的理解及如何实现有哪些实现方式)&quot;">​</a></h3><p><strong>悲观锁：</strong></p><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</p><p><strong>乐观锁：</strong></p><p>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p><h3 id="_5、生产环境-cpu-占用过高-你如何解决" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#5%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83-cpu-%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E4%BD%A0%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3" target="_blank" rel="noreferrer">5、生产环境 CPU 占用过高，你如何解决？</a> <a class="header-anchor" href="#_5、生产环境-cpu-占用过高-你如何解决" aria-label="Permalink to &quot;[5、生产环境 CPU 占用过高，你如何解决？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题及答案整理，汇总版.md#5生产环境-cpu-占用过高你如何解决)&quot;">​</a></h3><p><strong>1、</strong> top + H 指令找出占用 CPU 最高的进程的 pid</p><p><strong>2、</strong> top -H -p</p><p>在该进程中找到，哪些线程占用的 CPU 最高的线程，记录下 tid</p><p><strong>3、</strong> jstack -l</p><p>threads.txt，导出进程的线程栈信息到文本，导出出现异常的话，加上 -F 参数</p><p><strong>4、</strong> 将 tid 转换为十六进制，在 threads.txt 中搜索，查到对应的线程代码执行栈，在代码中查找占 CPU 比较高的原因。其中 tid 转十六进制，可以借助 Linux 的 printf &quot;%x&quot; tid 指令</p><p>我用上述方法查到过，jvm 多条线程疯狂 full gc 导致的CPU 100% 的问题和 JDK1.6 HashMap 并发 put 导致线程 CPU 100% 的问题</p><h3 id="_6、如何找到死锁的线程" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#6%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%AD%BB%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8B" target="_blank" rel="noreferrer">6、如何找到死锁的线程？</a> <a class="header-anchor" href="#_6、如何找到死锁的线程" aria-label="Permalink to &quot;[6、如何找到死锁的线程？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题及答案整理，汇总版.md#6如何找到死锁的线程)&quot;">​</a></h3><p><strong>死锁的线程可以使用 jstack 指令 dump 出 JVM 的线程信息。</strong></p><p>jstack -l &lt;pidthreads.txt</p><p><strong>有时候需要dump出现异常，可以加上 -F 指令，强制导出</strong></p><p>jstack -F -l &lt;pidthreads.txt</p><p>如果存在死锁，一般在文件最后会提示找到 deadlock 的数量与线程信息</p><h3 id="_7、多线程的价值" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#7%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%B7%E5%80%BC" target="_blank" rel="noreferrer">7、多线程的价值？</a> <a class="header-anchor" href="#_7、多线程的价值" aria-label="Permalink to &quot;[7、多线程的价值？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题及答案整理，汇总版.md#7多线程的价值)&quot;">​</a></h3><p><strong>1、</strong> 发挥多核CPU的优势</p><p>多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的，采用多线程的方式去同时完成几件事情而不互相干扰。</p><p><strong>2、</strong> 防止阻塞</p><p>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p><p><strong>3、</strong> 便于建模</p><p>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p><h3 id="_8、常用并发列队的介绍" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#8%E5%B8%B8%E7%94%A8%E5%B9%B6%E5%8F%91%E5%88%97%E9%98%9F%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%9A" target="_blank" rel="noreferrer">8、常用并发列队的介绍：</a> <a class="header-anchor" href="#_8、常用并发列队的介绍" aria-label="Permalink to &quot;[8、常用并发列队的介绍：](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题及答案整理，汇总版.md#8常用并发列队的介绍：)&quot;">​</a></h3><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h1><h3 id="_9、线程池的优点" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#9%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E7%82%B9" target="_blank" rel="noreferrer">9、线程池的优点？</a> <a class="header-anchor" href="#_9、线程池的优点" aria-label="Permalink to &quot;[9、线程池的优点？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题及答案整理，汇总版.md#9线程池的优点)&quot;">​</a></h3><p><strong>1、</strong> 重用存在的线程，减少对象创建销毁的开销。</p><p><strong>2、</strong> 可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</p><p><strong>3、</strong> 提供定时执行、定期执行、单线程、并发数控制等功能。</p><h3 id="_10、zgc-了解吗" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86%EF%BC%8C%E6%B1%87%E6%80%BB%E7%89%88.md#10zgc-%E4%BA%86%E8%A7%A3%E5%90%97" target="_blank" rel="noreferrer">10、ZGC 了解吗？</a> <a class="header-anchor" href="#_10、zgc-了解吗" aria-label="Permalink to &quot;[10、ZGC 了解吗？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新面试题及答案整理，汇总版.md#10zgc-了解吗)&quot;">​</a></h3><p>JDK11 中加入的具有实验性质的低延迟垃圾收集器，目标是尽可能在不影响吞吐量的前提下，实现在任意堆内存大小都可以把停顿时间限制在 10ms 以内的低延迟。</p><p>基于 Region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术实现可并发的标记-整理，以低延迟为首要目标。</p><p>ZGC 的 Region 具有动态性，是动态创建和销毁的，并且容量大小也是动态变化的。</p><h3 id="_11、parallel-scavenge-收集器-多线程复制算法、高效" tabindex="-1">11、Parallel Scavenge 收集器（多线程复制算法、高效） <a class="header-anchor" href="#_11、parallel-scavenge-收集器-多线程复制算法、高效" aria-label="Permalink to &quot;11、Parallel Scavenge 收集器（多线程复制算法、高效）&quot;">​</a></h3><h3 id="_12、调优工具" tabindex="-1">12、调优工具 <a class="header-anchor" href="#_12、调优工具" aria-label="Permalink to &quot;12、调优工具&quot;">​</a></h3><h3 id="_13、什么是指令重排序" tabindex="-1">13、什么是指令重排序？ <a class="header-anchor" href="#_13、什么是指令重排序" aria-label="Permalink to &quot;13、什么是指令重排序？&quot;">​</a></h3><h3 id="_14、说一下-jvm-调优的工具" tabindex="-1">14、说一下 JVM 调优的工具？ <a class="header-anchor" href="#_14、说一下-jvm-调优的工具" aria-label="Permalink to &quot;14、说一下 JVM 调优的工具？&quot;">​</a></h3><h3 id="_15、线程池都有哪些状态" tabindex="-1">15、线程池都有哪些状态？ <a class="header-anchor" href="#_15、线程池都有哪些状态" aria-label="Permalink to &quot;15、线程池都有哪些状态？&quot;">​</a></h3><h3 id="_16、有什么堆外内存的排查思路" tabindex="-1">16、有什么堆外内存的排查思路？ <a class="header-anchor" href="#_16、有什么堆外内存的排查思路" aria-label="Permalink to &quot;16、有什么堆外内存的排查思路？&quot;">​</a></h3><h3 id="_17、当一个线程进入一个对象的-synchronized-方法-a-之后-其它线程是否可进入此对象的-synchronized-方法-b" tabindex="-1">17、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？ <a class="header-anchor" href="#_17、当一个线程进入一个对象的-synchronized-方法-a-之后-其它线程是否可进入此对象的-synchronized-方法-b" aria-label="Permalink to &quot;17、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？&quot;">​</a></h3><h3 id="_18、62、volatile-变量和-atomic-变量有什么不同" tabindex="-1">18、62、volatile 变量和 atomic 变量有什么不同？ <a class="header-anchor" href="#_18、62、volatile-变量和-atomic-变量有什么不同" aria-label="Permalink to &quot;18、62、volatile 变量和 atomic 变量有什么不同？&quot;">​</a></h3><h3 id="_19、什么是cpu密集" tabindex="-1">19、什么是CPU密集 <a class="header-anchor" href="#_19、什么是cpu密集" aria-label="Permalink to &quot;19、什么是CPU密集&quot;">​</a></h3><h3 id="_20、用java实现阻塞队列" tabindex="-1">20、用Java实现阻塞队列 <a class="header-anchor" href="#_20、用java实现阻塞队列" aria-label="Permalink to &quot;20、用Java实现阻塞队列&quot;">​</a></h3><h3 id="_21、什么是分布式垃圾回收-dgc-它是如何工作的" tabindex="-1">21、什么是分布式垃圾回收（DGC）？它是如何工作的？ <a class="header-anchor" href="#_21、什么是分布式垃圾回收-dgc-它是如何工作的" aria-label="Permalink to &quot;21、什么是分布式垃圾回收（DGC）？它是如何工作的？&quot;">​</a></h3><h3 id="_22、什么是-futuretask" tabindex="-1">22、什么是 FutureTask <a class="header-anchor" href="#_22、什么是-futuretask" aria-label="Permalink to &quot;22、什么是 FutureTask&quot;">​</a></h3><h3 id="_23、串行-serial-收集器和吞吐量-throughput-收集器的区别是什么" tabindex="-1">23、串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？ <a class="header-anchor" href="#_23、串行-serial-收集器和吞吐量-throughput-收集器的区别是什么" aria-label="Permalink to &quot;23、串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？&quot;">​</a></h3><h3 id="_24、java-内存分配" tabindex="-1">24、Java 内存分配 <a class="header-anchor" href="#_24、java-内存分配" aria-label="Permalink to &quot;24、Java 内存分配&quot;">​</a></h3><h3 id="_25、java-中-concurrenthashmap-的并发度是什么" tabindex="-1">25、Java 中 ConcurrentHashMap 的并发度是什么？ <a class="header-anchor" href="#_25、java-中-concurrenthashmap-的并发度是什么" aria-label="Permalink to &quot;25、Java 中 ConcurrentHashMap 的并发度是什么？&quot;">​</a></h3><h3 id="_26、如何在两个线程间共享数据" tabindex="-1">26、如何在两个线程间共享数据？ <a class="header-anchor" href="#_26、如何在两个线程间共享数据" aria-label="Permalink to &quot;26、如何在两个线程间共享数据？&quot;">​</a></h3><h3 id="_27、jvm新生代中为什么要分为eden和survivor" tabindex="-1">27、JVM新生代中为什么要分为Eden和Survivor？ <a class="header-anchor" href="#_27、jvm新生代中为什么要分为eden和survivor" aria-label="Permalink to &quot;27、JVM新生代中为什么要分为Eden和Survivor？&quot;">​</a></h3><h3 id="_28、有哪些打破了双亲委托机制的案例" tabindex="-1">28、有哪些打破了双亲委托机制的案例？ <a class="header-anchor" href="#_28、有哪些打破了双亲委托机制的案例" aria-label="Permalink to &quot;28、有哪些打破了双亲委托机制的案例？&quot;">​</a></h3><h3 id="_29、gc-是什么-为什么要有-gc" tabindex="-1">29、GC 是什么？为什么要有 GC？ <a class="header-anchor" href="#_29、gc-是什么-为什么要有-gc" aria-label="Permalink to &quot;29、GC 是什么？为什么要有 GC？&quot;">​</a></h3><h3 id="_30、在java中cyclibarriar和countdownlatch有什么区别" tabindex="-1">30、在Java中CycliBarriar和CountdownLatch有什么区别？ <a class="header-anchor" href="#_30、在java中cyclibarriar和countdownlatch有什么区别" aria-label="Permalink to &quot;30、在Java中CycliBarriar和CountdownLatch有什么区别？&quot;">​</a></h3><h3 id="_31、单例模式的线程安全性" tabindex="-1">31、单例模式的线程安全性 <a class="header-anchor" href="#_31、单例模式的线程安全性" aria-label="Permalink to &quot;31、单例模式的线程安全性&quot;">​</a></h3><h3 id="_32、32-位-jvm-和-64-位-jvm-的最大堆内存分别是多数" tabindex="-1">32、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？ <a class="header-anchor" href="#_32、32-位-jvm-和-64-位-jvm-的最大堆内存分别是多数" aria-label="Permalink to &quot;32、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？&quot;">​</a></h3>',75),s=[E];function n(i,B,h,l,c,d){return e(),t("div",null,s)}const A=a(r,[["render",n]]);export{p as __pageData,A as default};
