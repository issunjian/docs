import{_ as a,o as e,c as o,V as r}from"./chunks/framework.c6d8cbec.js";const A=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/并发编程/并发编程-09.md","filePath":"interview/backend/并发编程/并发编程-09.md"}'),t={name:"interview/backend/并发编程/并发编程-09.md"},E=r('<h3 id="_1、阻塞队列和非阻塞队列区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C%E9%99%84%E7%AD%94%E6%A1%88.md#1%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">1、阻塞队列和非阻塞队列区别</a> <a class="header-anchor" href="#_1、阻塞队列和非阻塞队列区别" aria-label="Permalink to &quot;[1、阻塞队列和非阻塞队列区别](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题大汇总，附答案.md#1阻塞队列和非阻塞队列区别)&quot;">​</a></h3><p><strong>1、</strong> 当队列阻塞队列为空的时，从队列中获取元素的操作将会被阻塞。</p><p><strong>2、</strong> 或者当阻塞队列是满时，往队列里添加元素的操作会被阻塞。</p><p><strong>3、</strong> 或者试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。</p><p><strong>4、</strong> 试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来</p><h3 id="_2、类加载有几个过程" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C%E9%99%84%E7%AD%94%E6%A1%88.md#2%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%89%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B" target="_blank" rel="noreferrer">2、类加载有几个过程？</a> <a class="header-anchor" href="#_2、类加载有几个过程" aria-label="Permalink to &quot;[2、类加载有几个过程？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题大汇总，附答案.md#2类加载有几个过程)&quot;">​</a></h3><p>加载、验证、准备、解析、初始化。</p><h3 id="_3、线程-b-怎么知道线程-a-修改了变量" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C%E9%99%84%E7%AD%94%E6%A1%88.md#3%E7%BA%BF%E7%A8%8B-b-%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E7%BA%BF%E7%A8%8B-a-%E4%BF%AE%E6%94%B9%E4%BA%86%E5%8F%98%E9%87%8F" target="_blank" rel="noreferrer">3、线程 B 怎么知道线程 A 修改了变量</a> <a class="header-anchor" href="#_3、线程-b-怎么知道线程-a-修改了变量" aria-label="Permalink to &quot;[3、线程 B 怎么知道线程 A 修改了变量](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题大汇总，附答案.md#3线程-b-怎么知道线程-a-修改了变量)&quot;">​</a></h3><p><strong>1、</strong> volatile 修饰变量</p><p><strong>2、</strong> synchronized 修饰修改变量的方法</p><p><strong>3、</strong> wait/notify</p><p><strong>4、</strong> while 轮询</p><h3 id="_4、如何停止一个正在运行的线程" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C%E9%99%84%E7%AD%94%E6%A1%88.md#4%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B" target="_blank" rel="noreferrer">4、如何停止一个正在运行的线程？</a> <a class="header-anchor" href="#_4、如何停止一个正在运行的线程" aria-label="Permalink to &quot;[4、如何停止一个正在运行的线程？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题大汇总，附答案.md#4如何停止一个正在运行的线程)&quot;">​</a></h3><p>在java中有以下3种方法可以终止正在运行的线程：</p><p><strong>1、</strong> 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</p><p><strong>2、</strong> 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</p><p><strong>3、</strong> 使用interrupt方法中断线程。</p><h3 id="_5、什么是线程死锁" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C%E9%99%84%E7%AD%94%E6%A1%88.md#5%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81" target="_blank" rel="noreferrer">5、什么是线程死锁</a> <a class="header-anchor" href="#_5、什么是线程死锁" aria-label="Permalink to &quot;[5、什么是线程死锁](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题大汇总，附答案.md#5什么是线程死锁)&quot;">​</a></h3><p><strong>1、</strong> 死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p><p><strong>2、</strong> 多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p><strong>3、</strong> 如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p>![87_1.png][87_1.png]</p><h3 id="_6、常用的并发工具类有哪些" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C%E9%99%84%E7%AD%94%E6%A1%88.md#6%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B" target="_blank" rel="noreferrer">6、常用的并发工具类有哪些？</a> <a class="header-anchor" href="#_6、常用的并发工具类有哪些" aria-label="Permalink to &quot;[6、常用的并发工具类有哪些？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题大汇总，附答案.md#6常用的并发工具类有哪些)&quot;">​</a></h3><p><strong>CountDownLatch</strong></p><p>CountDownLatch 类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他3个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。</p><p><strong>CyclicBarrier (回环栅栏) CyclicBarrier它的作用就是会让所有线程都等待完成后才会继续下一步行动。</strong></p><p>CyclicBarrier初始化时规定一个数目，然后计算调用了CyclicBarrier.await()进入等待的线程数。当线程数达到了这个数目时，所有进入等待状态的线程被唤醒并继续。</p><p>CyclicBarrier初始时还可带一个Runnable的参数， 此Runnable任务在CyclicBarrier的数目达到后，所有其它线程被唤醒前被执行。</p><p>Semaphore (信号量) Semaphore 是 synchronized 的加强版，作用是控制线程的并发数量（允许自定义多少线程同时访问）。就这一点而言，单纯的synchronized 关键字是实现不了的。</p><p>Semaphore是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。它的用法如下：</p><h3 id="_7、并发编程三个必要因素是什么" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C%E9%99%84%E7%AD%94%E6%A1%88.md#7%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E4%B8%AA%E5%BF%85%E8%A6%81%E5%9B%A0%E7%B4%A0%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noreferrer">7、并发编程三个必要因素是什么？</a> <a class="header-anchor" href="#_7、并发编程三个必要因素是什么" aria-label="Permalink to &quot;[7、并发编程三个必要因素是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题大汇总，附答案.md#7并发编程三个必要因素是什么)&quot;">​</a></h3><p><strong>原子性：</strong></p><p>原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。</p><p><strong>可见性：</strong></p><p>一个线程对共享变量的修改,另一个线程能够立刻看到。（synchronized,volatile）</p><p><strong>有序性：</strong></p><p>程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）</p><h3 id="_8、safepoint-是什么" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C%E9%99%84%E7%AD%94%E6%A1%88.md#8safepoint-%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noreferrer">8、safepoint 是什么？</a> <a class="header-anchor" href="#_8、safepoint-是什么" aria-label="Permalink to &quot;[8、safepoint 是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题大汇总，附答案.md#8safepoint-是什么)&quot;">​</a></h3><p><strong>1、</strong> 为了减少对象引用的扫描，使用 OopMap 的数据结构在特定的位置记录下栈里和寄存器里哪些位置是引用；</p><p><strong>2、</strong> 但为了避免给每条指令都生成 OopMap 记录占用大量内存的问题，只在特定位置记录这些信息。</p><p><strong>3、</strong> 安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，如方法调用、循环跳转、异常跳转等都属于指令序列复用。</p><h3 id="_9、如何让正在运行的线程暂停一段时间" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C%E9%99%84%E7%AD%94%E6%A1%88.md#9%E5%A6%82%E4%BD%95%E8%AE%A9%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9A%82%E5%81%9C%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4" target="_blank" rel="noreferrer">9、如何让正在运行的线程暂停一段时间？</a> <a class="header-anchor" href="#_9、如何让正在运行的线程暂停一段时间" aria-label="Permalink to &quot;[9、如何让正在运行的线程暂停一段时间？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题大汇总，附答案.md#9如何让正在运行的线程暂停一段时间)&quot;">​</a></h3><p>我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。</p><h3 id="_10、synchronized可重入的原理" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C%E9%99%84%E7%AD%94%E6%A1%88.md#10synchronized%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86" target="_blank" rel="noreferrer">10、synchronized可重入的原理</a> <a class="header-anchor" href="#_10、synchronized可重入的原理" aria-label="Permalink to &quot;[10、synchronized可重入的原理](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题大汇总，附答案.md#10synchronized可重入的原理)&quot;">​</a></h3><p>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p><h3 id="_11、jvm调优命令有哪些" tabindex="-1">11、JVM调优命令有哪些？ <a class="header-anchor" href="#_11、jvm调优命令有哪些" aria-label="Permalink to &quot;11、JVM调优命令有哪些？&quot;">​</a></h3><h3 id="_12、什么是executors框架" tabindex="-1">12、什么是Executors框架？ <a class="header-anchor" href="#_12、什么是executors框架" aria-label="Permalink to &quot;12、什么是Executors框架？&quot;">​</a></h3><h3 id="_13、单例模式了解吗-给我解释一下双重检验锁方式实现单例模式" tabindex="-1">13、单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！” <a class="header-anchor" href="#_13、单例模式了解吗-给我解释一下双重检验锁方式实现单例模式" aria-label="Permalink to &quot;13、单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！”&quot;">​</a></h3><h3 id="_14、parallel-old-收集器-多线程标记整理算法" tabindex="-1">14、Parallel Old 收集器（多线程标记整理算法） <a class="header-anchor" href="#_14、parallel-old-收集器-多线程标记整理算法" aria-label="Permalink to &quot;14、Parallel Old 收集器（多线程标记整理算法）&quot;">​</a></h3><h3 id="_15、什么情况会造成元空间溢出" tabindex="-1">15、什么情况会造成元空间溢出？ <a class="header-anchor" href="#_15、什么情况会造成元空间溢出" aria-label="Permalink to &quot;15、什么情况会造成元空间溢出？&quot;">​</a></h3><h3 id="_16、java对象的布局了解过吗" tabindex="-1">16、Java对象的布局了解过吗？ <a class="header-anchor" href="#_16、java对象的布局了解过吗" aria-label="Permalink to &quot;16、Java对象的布局了解过吗？&quot;">​</a></h3><h3 id="_17、volatile关键字的作用" tabindex="-1">17、volatile关键字的作用 <a class="header-anchor" href="#_17、volatile关键字的作用" aria-label="Permalink to &quot;17、volatile关键字的作用&quot;">​</a></h3><h3 id="_18、程序计数器为什么是私有的" tabindex="-1">18、程序计数器为什么是私有的? <a class="header-anchor" href="#_18、程序计数器为什么是私有的" aria-label="Permalink to &quot;18、程序计数器为什么是私有的?&quot;">​</a></h3><h3 id="_19、如何判断对象是否是垃圾" tabindex="-1">19、如何判断对象是否是垃圾？ <a class="header-anchor" href="#_19、如何判断对象是否是垃圾" aria-label="Permalink to &quot;19、如何判断对象是否是垃圾？&quot;">​</a></h3><h3 id="_20、为什么使用executor框架" tabindex="-1">20、为什么使用Executor框架？ <a class="header-anchor" href="#_20、为什么使用executor框架" aria-label="Permalink to &quot;20、为什么使用Executor框架？&quot;">​</a></h3><h3 id="_21、模块化编程与热插拔" tabindex="-1">21、模块化编程与热插拔 <a class="header-anchor" href="#_21、模块化编程与热插拔" aria-label="Permalink to &quot;21、模块化编程与热插拔&quot;">​</a></h3><h3 id="_22、jvm-年轻代到年老代的晋升过程的判断条件是什么呢" tabindex="-1">22、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？ <a class="header-anchor" href="#_22、jvm-年轻代到年老代的晋升过程的判断条件是什么呢" aria-label="Permalink to &quot;22、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？&quot;">​</a></h3><h3 id="_23、说说你知道的几种主要的jvm参数" tabindex="-1">23、说说你知道的几种主要的JVM参数 <a class="header-anchor" href="#_23、说说你知道的几种主要的jvm参数" aria-label="Permalink to &quot;23、说说你知道的几种主要的JVM参数&quot;">​</a></h3><h3 id="_24、jvm内存模型" tabindex="-1">24、JVM内存模型 <a class="header-anchor" href="#_24、jvm内存模型" aria-label="Permalink to &quot;24、JVM内存模型&quot;">​</a></h3><h3 id="_25、copyonwritearraylist-的缺点" tabindex="-1">25、CopyOnWriteArrayList 的缺点? <a class="header-anchor" href="#_25、copyonwritearraylist-的缺点" aria-label="Permalink to &quot;25、CopyOnWriteArrayList 的缺点?&quot;">​</a></h3><h3 id="_26、双亲委派模型是什么" tabindex="-1">26、双亲委派模型是什么？ <a class="header-anchor" href="#_26、双亲委派模型是什么" aria-label="Permalink to &quot;26、双亲委派模型是什么？&quot;">​</a></h3><h3 id="_27、volatile有什么用-能否用一句话说明下volatile的应用场景" tabindex="-1">27、volatile有什么用？能否用一句话说明下volatile的应用场景？ <a class="header-anchor" href="#_27、volatile有什么用-能否用一句话说明下volatile的应用场景" aria-label="Permalink to &quot;27、volatile有什么用？能否用一句话说明下volatile的应用场景？&quot;">​</a></h3><h3 id="_28、futuretask是什么" tabindex="-1">28、FutureTask是什么 <a class="header-anchor" href="#_28、futuretask是什么" aria-label="Permalink to &quot;28、FutureTask是什么&quot;">​</a></h3><h3 id="_29、线程类的构造方法、静态块是被哪个线程调用的" tabindex="-1">29、线程类的构造方法、静态块是被哪个线程调用的 <a class="header-anchor" href="#_29、线程类的构造方法、静态块是被哪个线程调用的" aria-label="Permalink to &quot;29、线程类的构造方法、静态块是被哪个线程调用的&quot;">​</a></h3><h3 id="_30、如果对象的引用被置为null-垃圾收集器是否会立即释放对象占用的内存" tabindex="-1">30、如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？ <a class="header-anchor" href="#_30、如果对象的引用被置为null-垃圾收集器是否会立即释放对象占用的内存" aria-label="Permalink to &quot;30、如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？&quot;">​</a></h3><h3 id="_31、方法区-永久代-线程共享" tabindex="-1">31、方法区/永久代（线程共享） <a class="header-anchor" href="#_31、方法区-永久代-线程共享" aria-label="Permalink to &quot;31、方法区/永久代（线程共享）&quot;">​</a></h3><h3 id="_32、栈帧里面包含哪些东西" tabindex="-1">32、栈帧里面包含哪些东西？ <a class="header-anchor" href="#_32、栈帧里面包含哪些东西" aria-label="Permalink to &quot;32、栈帧里面包含哪些东西？&quot;">​</a></h3>',67),s=[E];function n(B,l,i,h,d,c){return e(),o("div",null,s)}const p=a(t,[["render",n]]);export{A as __pageData,p as default};
