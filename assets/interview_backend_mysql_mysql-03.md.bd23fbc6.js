import{_ as o,o as t,c as r,V as e}from"./chunks/framework.c6d8cbec.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/mysql/mysql-03.md","filePath":"interview/backend/mysql/mysql-03.md"}'),a={name:"interview/backend/mysql/mysql-03.md"},s=e('<h3 id="_1、隔离级别与锁的关系" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB" target="_blank" rel="noreferrer">1、隔离级别与锁的关系</a> <a class="header-anchor" href="#_1、隔离级别与锁的关系" aria-label="Permalink to &quot;[1、隔离级别与锁的关系](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL最新2021年面试题附答案解析，大汇总.md#1隔离级别与锁的关系)&quot;">​</a></h3><p>回答这个问题，可以先阐述四种隔离级别，再阐述它们的实现原理。隔离级别就是依赖锁和MVCC实现的。</p><h3 id="_2、实践中如何优化mysql" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#2%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96mysql" target="_blank" rel="noreferrer">2、实践中如何优化MySQL</a> <a class="header-anchor" href="#_2、实践中如何优化mysql" aria-label="Permalink to &quot;[2、实践中如何优化MySQL](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL最新2021年面试题附答案解析，大汇总.md#2实践中如何优化mysql)&quot;">​</a></h3><p>最好是按照以下顺序优化：</p><p><strong>1、</strong> SQL语句及索引的优化</p><p><strong>2、</strong> 数据库表结构的优化</p><p><strong>3、</strong> 系统配置的优化</p><p><strong>4、</strong> 硬件的优化</p><p>详细可以查看 <a href="http://youzhixueyuan.com/MySQL-slow-query-optimization-index-optimization.html" target="_blank" rel="noreferrer">阿里P8架构师谈：MySQL慢查询优化、索引优化、以及表等优化总结</a></p><h3 id="_3、优化子查询" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#3%E4%BC%98%E5%8C%96%E5%AD%90%E6%9F%A5%E8%AF%A2" target="_blank" rel="noreferrer">3、优化子查询</a> <a class="header-anchor" href="#_3、优化子查询" aria-label="Permalink to &quot;[3、优化子查询](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL最新2021年面试题附答案解析，大汇总.md#3优化子查询)&quot;">​</a></h3><p><strong>1、</strong> 用关联查询替代</p><p><strong>2、</strong> 优化GROUP BY和DISTINCT</p><p><strong>3、</strong> 这两种查询据可以使用索引来优化，是最有效的优化方法</p><p><strong>4、</strong> 关联查询中，使用标识列分组的效率更高</p><p><strong>5、</strong> 如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</p><p><strong>6、</strong> WITH ROLLUP超级聚合，可以挪到应用程序处理</p><h3 id="_4、前缀索引" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#4%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95" target="_blank" rel="noreferrer">4、前缀索引</a> <a class="header-anchor" href="#_4、前缀索引" aria-label="Permalink to &quot;[4、前缀索引](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL最新2021年面试题附答案解析，大汇总.md#4前缀索引)&quot;">​</a></h3><p><strong>1、</strong> 语法：<code>index(field(10))</code>，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p><p><strong>2、</strong> 前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p><p><strong>3、</strong> 实操的难度：在于前缀截取的长度。</p><p><strong>4、</strong> 我们可以利用<code>select count(*)/count(distinct left(password,prefixLen));</code>，通过从调整<code>prefixLen</code>的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前<code>prefixLen</code>个字符几乎能确定唯一一条记录）</p><h3 id="_5、mysql5-6和mysql5-7对索引做了哪些优化" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#5mysql56%E5%92%8Cmysql57%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96" target="_blank" rel="noreferrer">5、MySQL5.6和MySQL5.7对索引做了哪些优化？</a> <a class="header-anchor" href="#_5、mysql5-6和mysql5-7对索引做了哪些优化" aria-label="Permalink to &quot;[5、MySQL5.6和MySQL5.7对索引做了哪些优化？](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL最新2021年面试题附答案解析，大汇总.md#5mysql56和mysql57对索引做了哪些优化)&quot;">​</a></h3><p><strong>1、</strong> MySQL5.6引入了索引下推优化，默认是开启的。</p><p><strong>2、</strong> 例子：user表中（a,b,c）构成一个索引。</p><p><strong>3、</strong> select * from user where a=&#39;23&#39; and b like &#39;%eqw%&#39; and c like &#39;dasd&#39;。</p><p><strong>4、</strong> 解释：如果没有索引下推原则，则MySQL会通过a=&#39;23&#39; 先查询出一个对应的数据。然后返回到MySQL服务端。MySQL服务端再基于两个like模糊查询来校验and查询出的数据是否符合条件。这个过程就设计到回表操作。</p><p><strong>5、</strong> 如果使用了索引下推技术，则MySQL会首先返回返回条件a=&#39;23&#39;的数据的索引，然后根据模糊查询的条件来校验索引行数据是否符合条件，如果符合条件，则直接根据索引来定位对应的数据，如果不符合直接reject掉。因此，有了索引下推优化，可以在有like条件的情况下，减少回表的次数。</p><h3 id="_6、mysql有关权限的表有哪几个呢" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#6mysql%E6%9C%89%E5%85%B3%E6%9D%83%E9%99%90%E7%9A%84%E8%A1%A8%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%E5%91%A2" target="_blank" rel="noreferrer">6、MySQL有关权限的表有哪几个呢？</a> <a class="header-anchor" href="#_6、mysql有关权限的表有哪几个呢" aria-label="Permalink to &quot;[6、MySQL有关权限的表有哪几个呢？](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL最新2021年面试题附答案解析，大汇总.md#6mysql有关权限的表有哪几个呢)&quot;">​</a></h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在MySQL数据库里，由MySQL_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。</p><p><strong>1、</strong> user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</p><p><strong>2、</strong> db权限表：记录各个帐号在各个数据库上的操作权限。</p><p><strong>3、</strong> table_priv权限表：记录数据表级的操作权限。</p><p><strong>4、</strong> columns_priv权限表：记录数据列级的操作权限。</p><p><strong>5、</strong> host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</p><h3 id="_7、mysql中都有哪些触发器" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#7mysql%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A6%E5%8F%91%E5%99%A8" target="_blank" rel="noreferrer">7、MySQL中都有哪些触发器？</a> <a class="header-anchor" href="#_7、mysql中都有哪些触发器" aria-label="Permalink to &quot;[7、MySQL中都有哪些触发器？](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL最新2021年面试题附答案解析，大汇总.md#7mysql中都有哪些触发器)&quot;">​</a></h3><p>MySQL 数据库中有六种触发器：</p><p><strong>1、</strong> Before Insert</p><p><strong>2、</strong> After Insert</p><p><strong>3、</strong> Before Update</p><p><strong>4、</strong> After Update</p><p><strong>5、</strong> Before Delete</p><p><strong>6、</strong> After Delete</p><h3 id="_8、大表怎么优化-分库分表了是怎么做的-分表分库了有什么问题-有用到中间件么-他们的原理知道么" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#8%E5%A4%A7%E8%A1%A8%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BA%86%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93%E4%BA%86%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E6%9C%89%E7%94%A8%E5%88%B0%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%88%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E4%B9%88" target="_blank" rel="noreferrer">8、大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</a> <a class="header-anchor" href="#_8、大表怎么优化-分库分表了是怎么做的-分表分库了有什么问题-有用到中间件么-他们的原理知道么" aria-label="Permalink to &quot;[8、大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL最新2021年面试题附答案解析，大汇总.md#8大表怎么优化分库分表了是怎么做的分表分库了有什么问题有用到中间件么他们的原理知道么)&quot;">​</a></h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><p><strong>1、</strong> 限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</p><p><strong>2、</strong> 读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；</p><p><strong>3、</strong> 缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</p><p><strong>还有就是通过分库分表的方式进行优化，主要有垂直分区、垂直分表和水平分区、水平分表</strong></p><p><strong>垂直分区</strong></p><p><strong>1、</strong> 根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p><strong>2、</strong> 简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。</p><p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/049/50/99_9.png#alt=99%5C_9.png" alt=""></p><p><strong>垂直拆分的优点：</strong></p><p>可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p><strong>垂直拆分的缺点：</strong></p><p>主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p><p><strong>垂直分表</strong></p><p>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p><p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/049/50/99_10.png#alt=99%5C_10.png" alt=""></p><p><strong>适用场景</strong></p><p><strong>1、</strong> 如果一个表中某些列常用，另外一些列不常用</p><p><strong>2、</strong> 可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数</p><p><strong>缺点</strong></p><p><strong>1、</strong> 有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</p><p><strong>2、</strong> 对于应用层来说，逻辑算法增加开发成本</p><p><strong>3、</strong> 管理冗余列，查询所有数据需要join操作</p><p><strong>水平分区</strong></p><p><strong>1、</strong> 保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</p><p><strong>2、</strong> 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/049/50/99_11.png#alt=99%5C_11.png" alt=""></p><p><strong>1、</strong> 水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p><p><strong>2、</strong> 水平拆分能够支持非常大的数据量存储，应用端改造也少，但 <strong>分片事务难以解决</strong> ，跨界点Join性能较差，逻辑复杂。</p><p>《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p><p><strong>水平分表：</strong></p><p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p><p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/049/50/99_12.png#alt=99%5C_12.png" alt=""></p><p><strong>适用场景</strong></p><p><strong>1、</strong> 表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</p><p><strong>2、</strong> 需要把数据存放在多个介质上。</p><p><strong>水平切分的缺点</strong></p><p><strong>1、</strong> 给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</p><p><strong>2、</strong> 在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</p><p><strong>数据库分片的两种常见方案：</strong></p><p><strong>客户端代理：</strong></p><p>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</p><p><strong>中间件代理：</strong></p><p>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。</p><p><strong>分库分表后面临的问题</strong></p><p><strong>事务支持</strong></p><p>分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p><p><strong>跨库join</strong></p><p>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p><p><strong>跨节点的count,order by,group by以及聚合函数问题</strong></p><p>这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p><p><strong>数据迁移，容量规划，扩容等问题</strong></p><p>来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p><p><strong>ID问题</strong></p><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由、一些常见的主键生成策略</p><p>UUID 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter的分布式自增ID算法Snowflake</strong> 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p><p><strong>跨分片的排序分页问题</strong></p><p>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p><p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/049/50/99_13.png#alt=99%5C_13.png" alt=""></p><h3 id="_9、b-tree索引和hash索引区别" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#9b+-tree%E7%B4%A2%E5%BC%95%E5%92%8Chash%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB" target="_blank" rel="noreferrer">9、B+ Tree索引和Hash索引区别？</a> <a class="header-anchor" href="#_9、b-tree索引和hash索引区别" aria-label="Permalink to &quot;[9、B+ Tree索引和Hash索引区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL最新2021年面试题附答案解析，大汇总.md#9b+-tree索引和hash索引区别)&quot;">​</a></h3><p><strong>1、</strong> hash索引适合等值查询，但是无法进行范围查询。</p><p><strong>2、</strong> hash索引没办法利用索引完成排序。</p><p><strong>3、</strong> hash索引不支持多列联合索引的最左匹配规则。</p><p><strong>4、</strong> 如果有大量重复健值得情况下，hash索引的效率会很低，因为哈希碰撞问题。</p><h3 id="_10、数据库索引的原理-为什么要用-b-树-为什么不用二叉树" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#10%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-b+%E6%A0%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noreferrer">10、数据库索引的原理，为什么要用 B+树，为什么不用二叉树？</a> <a class="header-anchor" href="#_10、数据库索引的原理-为什么要用-b-树-为什么不用二叉树" aria-label="Permalink to &quot;[10、数据库索引的原理，为什么要用 B+树，为什么不用二叉树？](https://gitee.com/souyunku/DevBooks/blob/master/docs/MySQL/MySQL最新2021年面试题附答案解析，大汇总.md#10数据库索引的原理为什么要用-b+树为什么不用二叉树)&quot;">​</a></h3><p>可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？</p><p><strong>为什么不是一般二叉树？</strong></p><p>如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p><p><strong>为什么不是平衡二叉树呢？</strong></p><p>我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。</p><p><strong>那为什么不是B树而是B+树呢？</strong></p><p>1）B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。</p><p>2）B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。</p><h3 id="_11、mysql的binlog有几种录入格式-分别有什么区别" tabindex="-1">11、MySQL的binlog有几种录入格式？分别有什么区别？ <a class="header-anchor" href="#_11、mysql的binlog有几种录入格式-分别有什么区别" aria-label="Permalink to &quot;11、MySQL的binlog有几种录入格式？分别有什么区别？&quot;">​</a></h3><h3 id="_12、字段为什么要求定义为not-null" tabindex="-1">12、字段为什么要求定义为not null？ <a class="header-anchor" href="#_12、字段为什么要求定义为not-null" aria-label="Permalink to &quot;12、字段为什么要求定义为not null？&quot;">​</a></h3><h3 id="_13、一条sql的执行顺序" tabindex="-1">13、一条Sql的执行顺序？ <a class="header-anchor" href="#_13、一条sql的执行顺序" aria-label="Permalink to &quot;13、一条Sql的执行顺序？&quot;">​</a></h3><h3 id="_14、sql注入漏洞产生的原因-如何防止" tabindex="-1">14、SQL注入漏洞产生的原因？如何防止？ <a class="header-anchor" href="#_14、sql注入漏洞产生的原因-如何防止" aria-label="Permalink to &quot;14、SQL注入漏洞产生的原因？如何防止？&quot;">​</a></h3><h3 id="_15、如何选择合适的分布式主键方案呢" tabindex="-1">15、如何选择合适的分布式主键方案呢？ <a class="header-anchor" href="#_15、如何选择合适的分布式主键方案呢" aria-label="Permalink to &quot;15、如何选择合适的分布式主键方案呢？&quot;">​</a></h3><h3 id="_16、b树和b-树的区别-数据库为什么使用b-树而不是b树" tabindex="-1">16、B树和B+树的区别，数据库为什么使用B+树而不是B树？ <a class="header-anchor" href="#_16、b树和b-树的区别-数据库为什么使用b-树而不是b树" aria-label="Permalink to &quot;16、B树和B+树的区别，数据库为什么使用B+树而不是B树？&quot;">​</a></h3><h3 id="_17、何时使用聚簇索引与非聚簇索引" tabindex="-1">17、何时使用聚簇索引与非聚簇索引 <a class="header-anchor" href="#_17、何时使用聚簇索引与非聚簇索引" aria-label="Permalink to &quot;17、何时使用聚簇索引与非聚簇索引&quot;">​</a></h3><h3 id="_18、你可以用什么来确保表格里的字段只接受特定范围里的值" tabindex="-1">18、你可以用什么来确保表格里的字段只接受特定范围里的值? <a class="header-anchor" href="#_18、你可以用什么来确保表格里的字段只接受特定范围里的值" aria-label="Permalink to &quot;18、你可以用什么来确保表格里的字段只接受特定范围里的值?&quot;">​</a></h3><h3 id="_19、百万级别或以上的数据-你是如何删除的" tabindex="-1">19、百万级别或以上的数据，你是如何删除的？ <a class="header-anchor" href="#_19、百万级别或以上的数据-你是如何删除的" aria-label="Permalink to &quot;19、百万级别或以上的数据，你是如何删除的？&quot;">​</a></h3><h3 id="_20、列设置为auto-increment时-如果在表中达到最大值-会发生什么情况" tabindex="-1">20、列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？ <a class="header-anchor" href="#_20、列设置为auto-increment时-如果在表中达到最大值-会发生什么情况" aria-label="Permalink to &quot;20、列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？&quot;">​</a></h3><h3 id="_21、数据库的乐观锁和悲观锁是什么-怎么实现的" tabindex="-1">21、数据库的乐观锁和悲观锁是什么？怎么实现的？ <a class="header-anchor" href="#_21、数据库的乐观锁和悲观锁是什么-怎么实现的" aria-label="Permalink to &quot;21、数据库的乐观锁和悲观锁是什么？怎么实现的？&quot;">​</a></h3><h3 id="_22、什么是最左前缀原则-什么是最左匹配原则" tabindex="-1">22、什么是最左前缀原则？什么是最左匹配原则？ <a class="header-anchor" href="#_22、什么是最左前缀原则-什么是最左匹配原则" aria-label="Permalink to &quot;22、什么是最左前缀原则？什么是最左匹配原则？&quot;">​</a></h3><h3 id="_23、如果一个表有一列定义为timestamp-将发生什么" tabindex="-1">23、如果一个表有一列定义为TIMESTAMP，将发生什么？ <a class="header-anchor" href="#_23、如果一个表有一列定义为timestamp-将发生什么" aria-label="Permalink to &quot;23、如果一个表有一列定义为TIMESTAMP，将发生什么？&quot;">​</a></h3><h3 id="_24、说出一些数据库优化方面的经验" tabindex="-1">24、说出一些数据库优化方面的经验? <a class="header-anchor" href="#_24、说出一些数据库优化方面的经验" aria-label="Permalink to &quot;24、说出一些数据库优化方面的经验?&quot;">​</a></h3><h3 id="_25、select-for-update-含义" tabindex="-1">25、select for update 含义 <a class="header-anchor" href="#_25、select-for-update-含义" aria-label="Permalink to &quot;25、select for update 含义&quot;">​</a></h3><h3 id="_26、myisam索引与innodb索引的区别" tabindex="-1">26、MyISAM索引与InnoDB索引的区别？ <a class="header-anchor" href="#_26、myisam索引与innodb索引的区别" aria-label="Permalink to &quot;26、MyISAM索引与InnoDB索引的区别？&quot;">​</a></h3><h3 id="_27、varchar-50-中50的涵义" tabindex="-1">27、varchar(50)中50的涵义 <a class="header-anchor" href="#_27、varchar-50-中50的涵义" aria-label="Permalink to &quot;27、varchar(50)中50的涵义&quot;">​</a></h3><h3 id="_28、完整性约束包括哪些" tabindex="-1">28、完整性约束包括哪些？ <a class="header-anchor" href="#_28、完整性约束包括哪些" aria-label="Permalink to &quot;28、完整性约束包括哪些？&quot;">​</a></h3><h3 id="_29、索引的底层实现原理和优化" tabindex="-1">29、索引的底层实现原理和优化 <a class="header-anchor" href="#_29、索引的底层实现原理和优化" aria-label="Permalink to &quot;29、索引的底层实现原理和优化&quot;">​</a></h3><h3 id="_30、mysql中int-20-和char-20-以及varchar-20-的区别" tabindex="-1">30、MySQL中int(20)和char(20)以及varchar(20)的区别 <a class="header-anchor" href="#_30、mysql中int-20-和char-20-以及varchar-20-的区别" aria-label="Permalink to &quot;30、MySQL中int(20)和char(20)以及varchar(20)的区别&quot;">​</a></h3>',136),n=[s];function E(p,l,h,i,g,B){return t(),r("div",null,n)}const A=o(a,[["render",E]]);export{d as __pageData,A as default};
