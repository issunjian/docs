import{_ as e,o as s,c as a,V as n}from"./chunks/framework.c6d8cbec.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/react/React最新2021年面试题附答案解析，大汇总.md","filePath":"interview/backend/react/React最新2021年面试题附答案解析，大汇总.md"}'),t={name:"interview/backend/react/React最新2021年面试题附答案解析，大汇总.md"},o=n(`<h3 id="_1、react中的状态是什么-它是如何使用的" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#1react%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9A%84" target="_blank" rel="noreferrer">1、React中的状态是什么？它是如何使用的？</a> <a class="header-anchor" href="#_1、react中的状态是什么-它是如何使用的" aria-label="Permalink to &quot;[1、React中的状态是什么？它是如何使用的？](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新2021年面试题附答案解析，大汇总.md#1react中的状态是什么它是如何使用的)&quot;">​</a></h3><p>状态是 React 组件的核心，是数据的来源，必须尽可能简单。基本上状态是确定组件呈现和行为的对象。与props 不同，它们是可变的，并创建动态和交互式组件。可以通过 <code>this.state()</code> 访问它们。</p><h3 id="_2、connect原理" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#2connect%E5%8E%9F%E7%90%86" target="_blank" rel="noreferrer">2、connect原理</a> <a class="header-anchor" href="#_2、connect原理" aria-label="Permalink to &quot;[2、connect原理](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新2021年面试题附答案解析，大汇总.md#2connect原理)&quot;">​</a></h3><p>首先<code>connect</code>之所以会成功是因为<code>Provider</code>组件在原应用组件上包裹一层使原来整个应用成为<code>Provider</code>的子组件接收<code>Redux</code>的<code>store</code>作为<code>props</code>通过<code>context</code>对象传递给子孙组件上的<code>connect</code>connect做了些什么。它真正连接 <code>Redux</code>和 <code>React</code>它包在我们的容器组件的外一层它接收上面 <code>Provider</code> 提供的 <code>store</code> 里面的<code>state</code> 和 <code>dispatch</code>传给一个构造函数返回一个对象以属性形式传给我们的容器组件</p><p><code>connect</code>是一个高阶函数首先传入mapStateToProps、mapDispatchToProps然后返回一个生产Component的函数(wrapWithConnect)然后再将真正的Component作为参数传入wrapWithConnect这样就生产出一个经过包裹的Connect组件该组件具有如下特点</p><p>通过<code>props.store</code>获取祖先<code>Component</code>的<code>store props</code>包括<code>stateProps</code>、<code>dispatchProps</code>、<code>parentProps</code>,合并在一起得到<code>nextState</code>作为<code>props</code>传给真正的<code>Component componentDidMount</code>时添加事件<code>this.store.subscribe(this.handleChange)</code>实现页面交互<code>shouldComponentUpdate</code>时判断是否有避免进行渲染提升页面性能并得到nextState componentWillUnmount时移除注册的事件<code>this.handleChange</code></p><p>由于connect的源码过长我们只看主要逻辑</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) {</span></span>
<span class="line"><span style="color:#f6f6f4;">  return function wrapWithConnect(WrappedComponent) {</span></span>
<span class="line"><span style="color:#f6f6f4;">    class Connect extends Component {</span></span>
<span class="line"><span style="color:#f6f6f4;">      constructor(props, context) {</span></span>
<span class="line"><span style="color:#f6f6f4;">        // 从祖先Component处获得store</span></span>
<span class="line"><span style="color:#f6f6f4;">        this.store = props.store || context.store</span></span>
<span class="line"><span style="color:#f6f6f4;">        this.stateProps = computeStateProps(this.store, props)</span></span>
<span class="line"><span style="color:#f6f6f4;">        this.dispatchProps = computeDispatchProps(this.store, props)</span></span>
<span class="line"><span style="color:#f6f6f4;">        this.state = { storeState: null }</span></span>
<span class="line"><span style="color:#f6f6f4;">        // 对stateProps、dispatchProps、parentProps进行合并</span></span>
<span class="line"><span style="color:#f6f6f4;">        this.updateState()</span></span>
<span class="line"><span style="color:#f6f6f4;">      }</span></span>
<span class="line"><span style="color:#f6f6f4;">      shouldComponentUpdate(nextProps, nextState) {</span></span>
<span class="line"><span style="color:#f6f6f4;">        // 进行判断当数据发生改变时Component重新渲染</span></span>
<span class="line"><span style="color:#f6f6f4;">        if (propsChanged </span></span>
<span class="line"><span style="color:#f6f6f4;">        || mapStateProducedChange </span></span>
<span class="line"><span style="color:#f6f6f4;">        || dispatchPropsChanged) {</span></span>
<span class="line"><span style="color:#f6f6f4;">          this.updateState(nextProps)</span></span>
<span class="line"><span style="color:#f6f6f4;">            return true</span></span>
<span class="line"><span style="color:#f6f6f4;">          }</span></span>
<span class="line"><span style="color:#f6f6f4;">        }</span></span>
<span class="line"><span style="color:#f6f6f4;">        componentDidMount() {</span></span>
<span class="line"><span style="color:#f6f6f4;">          // 改变Component的state</span></span>
<span class="line"><span style="color:#f6f6f4;">          this.store.subscribe(() = {</span></span>
<span class="line"><span style="color:#f6f6f4;">            this.setState({</span></span>
<span class="line"><span style="color:#f6f6f4;">              storeState: this.store.getState()</span></span>
<span class="line"><span style="color:#f6f6f4;">            })</span></span>
<span class="line"><span style="color:#f6f6f4;">          })</span></span>
<span class="line"><span style="color:#f6f6f4;">        }</span></span>
<span class="line"><span style="color:#f6f6f4;">        render() {</span></span>
<span class="line"><span style="color:#f6f6f4;">          // 生成包裹组件Connect</span></span>
<span class="line"><span style="color:#f6f6f4;">          return (</span></span>
<span class="line"><span style="color:#f6f6f4;">            &lt;WrappedComponent {...this.nextState} /&gt;</span></span>
<span class="line"><span style="color:#f6f6f4;">          )</span></span>
<span class="line"><span style="color:#f6f6f4;">        }</span></span>
<span class="line"><span style="color:#f6f6f4;">      }</span></span>
<span class="line"><span style="color:#f6f6f4;">      Connect.contextTypes = {</span></span>
<span class="line"><span style="color:#f6f6f4;">        store: storeShape</span></span>
<span class="line"><span style="color:#f6f6f4;">      }</span></span>
<span class="line"><span style="color:#f6f6f4;">      return Connect;</span></span>
<span class="line"><span style="color:#f6f6f4;">    }</span></span>
<span class="line"><span style="color:#f6f6f4;">  }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) {</span></span>
<span class="line"><span style="color:#24292e;">  return function wrapWithConnect(WrappedComponent) {</span></span>
<span class="line"><span style="color:#24292e;">    class Connect extends Component {</span></span>
<span class="line"><span style="color:#24292e;">      constructor(props, context) {</span></span>
<span class="line"><span style="color:#24292e;">        // 从祖先Component处获得store</span></span>
<span class="line"><span style="color:#24292e;">        this.store = props.store || context.store</span></span>
<span class="line"><span style="color:#24292e;">        this.stateProps = computeStateProps(this.store, props)</span></span>
<span class="line"><span style="color:#24292e;">        this.dispatchProps = computeDispatchProps(this.store, props)</span></span>
<span class="line"><span style="color:#24292e;">        this.state = { storeState: null }</span></span>
<span class="line"><span style="color:#24292e;">        // 对stateProps、dispatchProps、parentProps进行合并</span></span>
<span class="line"><span style="color:#24292e;">        this.updateState()</span></span>
<span class="line"><span style="color:#24292e;">      }</span></span>
<span class="line"><span style="color:#24292e;">      shouldComponentUpdate(nextProps, nextState) {</span></span>
<span class="line"><span style="color:#24292e;">        // 进行判断当数据发生改变时Component重新渲染</span></span>
<span class="line"><span style="color:#24292e;">        if (propsChanged </span></span>
<span class="line"><span style="color:#24292e;">        || mapStateProducedChange </span></span>
<span class="line"><span style="color:#24292e;">        || dispatchPropsChanged) {</span></span>
<span class="line"><span style="color:#24292e;">          this.updateState(nextProps)</span></span>
<span class="line"><span style="color:#24292e;">            return true</span></span>
<span class="line"><span style="color:#24292e;">          }</span></span>
<span class="line"><span style="color:#24292e;">        }</span></span>
<span class="line"><span style="color:#24292e;">        componentDidMount() {</span></span>
<span class="line"><span style="color:#24292e;">          // 改变Component的state</span></span>
<span class="line"><span style="color:#24292e;">          this.store.subscribe(() = {</span></span>
<span class="line"><span style="color:#24292e;">            this.setState({</span></span>
<span class="line"><span style="color:#24292e;">              storeState: this.store.getState()</span></span>
<span class="line"><span style="color:#24292e;">            })</span></span>
<span class="line"><span style="color:#24292e;">          })</span></span>
<span class="line"><span style="color:#24292e;">        }</span></span>
<span class="line"><span style="color:#24292e;">        render() {</span></span>
<span class="line"><span style="color:#24292e;">          // 生成包裹组件Connect</span></span>
<span class="line"><span style="color:#24292e;">          return (</span></span>
<span class="line"><span style="color:#24292e;">            &lt;WrappedComponent {...this.nextState} /&gt;</span></span>
<span class="line"><span style="color:#24292e;">          )</span></span>
<span class="line"><span style="color:#24292e;">        }</span></span>
<span class="line"><span style="color:#24292e;">      }</span></span>
<span class="line"><span style="color:#24292e;">      Connect.contextTypes = {</span></span>
<span class="line"><span style="color:#24292e;">        store: storeShape</span></span>
<span class="line"><span style="color:#24292e;">      }</span></span>
<span class="line"><span style="color:#24292e;">      return Connect;</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">  }</span></span></code></pre></div><h3 id="_3、react-hooks它带来了那些便利" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#3react-hooks%E5%AE%83%E5%B8%A6%E6%9D%A5%E4%BA%86%E9%82%A3%E4%BA%9B%E4%BE%BF%E5%88%A9" target="_blank" rel="noreferrer">3、react hooks它带来了那些便利</a> <a class="header-anchor" href="#_3、react-hooks它带来了那些便利" aria-label="Permalink to &quot;[3、react hooks它带来了那些便利](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新2021年面试题附答案解析，大汇总.md#3react-hooks它带来了那些便利)&quot;">​</a></h3><p><strong>1、</strong> 代码逻辑聚合逻辑复用</p><p><strong>2、</strong> <code>HOC</code>嵌套地狱</p><p><strong>3、</strong> 代替 <code>class</code></p><p><strong>4、</strong> <code>React</code> 中通常使用 类定义 或者 函数定义 创建组件:</p><p>在类定义中我们可以使用到许多 <code>React</code> 特性例如 <code>state</code>、 各种组件生命周期钩子等但是在函数定义中我们却无能为力因此 <code>React 16.8</code> 版本推出了一个新功能 (<code>React Hooks</code>)通过它可以更好的在函数定义组件中使用 <code>React</code> 特性。</p><p><strong>好处:</strong></p><p><strong>1、</strong> 跨组件复用: 其实 <code>render</code> <code>props</code> / <code>HOC</code> 也是为了复用相比于它们Hooks 作为官方的底层 <code>API</code>最为轻量而且改造成本小不会影响原来的* 组件层次结构和传说中的嵌套地狱</p><p><strong>2、</strong> 类定义更为复杂</p><p><strong>3、</strong> 不同的生命周期会使逻辑变得分散且混乱不易维护和管理</p><p><strong>4、</strong> 时刻需要关注 <code>this</code>的指向问题</p><p><strong>5、</strong> 代码复用代价高高阶组件的使用经常会使整个组件树变得臃肿</p><p><strong>6、</strong> 状态与UI隔离: 正是由于 <code>Hooks</code> 的特性状态逻辑会变成更小的粒度并且极容易被抽象成一个自定义 <code>Hooks</code>组件中的状态和 <code>UI</code> 变得更为清晰和隔离。</p><p>注意:</p><p>避免在 循环/条件判断/嵌套函数 中调用 <code>hooks</code>保证调用顺序的稳定只有 函数定义组件 和 <code>hooks</code> 可以调用 <code>hooks</code>避免在 类组件 或者 普通函数 中调用不能在<code>useEffect</code>中使用<code>useStateReact</code> 会报错提示类组件不会被替换或废弃不需要强制改造类组件两种方式能并存重要钩子</p><p>状态钩子 (<code>useState</code>): 用于定义组件的<code>State</code>其到类定义中<code>this.state</code>的功能</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">// useState 只接受一个参数: 初始状态</span></span>
<span class="line"><span style="color:#f6f6f4;">// 返回的是组件名和更改该组件对应的函数</span></span>
<span class="line"><span style="color:#f6f6f4;">const [flag, setFlag] = useState(true);</span></span>
<span class="line"><span style="color:#f6f6f4;">// 修改状态</span></span>
<span class="line"><span style="color:#f6f6f4;">setFlag(false)</span></span>
<span class="line"><span style="color:#f6f6f4;"> </span></span>
<span class="line"><span style="color:#f6f6f4;">// 上面的代码映射到类定义中:</span></span>
<span class="line"><span style="color:#f6f6f4;">this.state = {</span></span>
<span class="line"><span style="color:#f6f6f4;"> flag: true </span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span>
<span class="line"><span style="color:#f6f6f4;">const flag = this.state.flag</span></span>
<span class="line"><span style="color:#f6f6f4;">const setFlag = (bool) =&gt; {</span></span>
<span class="line"><span style="color:#f6f6f4;">    this.setState({</span></span>
<span class="line"><span style="color:#f6f6f4;">        flag: bool,</span></span>
<span class="line"><span style="color:#f6f6f4;">    })</span></span>
<span class="line"><span style="color:#f6f6f4;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">// useState 只接受一个参数: 初始状态</span></span>
<span class="line"><span style="color:#24292e;">// 返回的是组件名和更改该组件对应的函数</span></span>
<span class="line"><span style="color:#24292e;">const [flag, setFlag] = useState(true);</span></span>
<span class="line"><span style="color:#24292e;">// 修改状态</span></span>
<span class="line"><span style="color:#24292e;">setFlag(false)</span></span>
<span class="line"><span style="color:#24292e;"> </span></span>
<span class="line"><span style="color:#24292e;">// 上面的代码映射到类定义中:</span></span>
<span class="line"><span style="color:#24292e;">this.state = {</span></span>
<span class="line"><span style="color:#24292e;"> flag: true </span></span>
<span class="line"><span style="color:#24292e;">}</span></span>
<span class="line"><span style="color:#24292e;">const flag = this.state.flag</span></span>
<span class="line"><span style="color:#24292e;">const setFlag = (bool) =&gt; {</span></span>
<span class="line"><span style="color:#24292e;">    this.setState({</span></span>
<span class="line"><span style="color:#24292e;">        flag: bool,</span></span>
<span class="line"><span style="color:#24292e;">    })</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><h3 id="_4、setstate到底是异步还是同步" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#4setstate%E5%88%B0%E5%BA%95%E6%98%AF%E5%BC%82%E6%AD%A5%E8%BF%98%E6%98%AF%E5%90%8C%E6%AD%A5" target="_blank" rel="noreferrer">4、setState到底是异步还是同步?</a> <a class="header-anchor" href="#_4、setstate到底是异步还是同步" aria-label="Permalink to &quot;[4、setState到底是异步还是同步?](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新2021年面试题附答案解析，大汇总.md#4setstate到底是异步还是同步)&quot;">​</a></h3><p>先给出答案: 有时表现出异步,有时表现出同步</p><p><strong>1、</strong> <code>setState</code>只在合成事件和钩子函数中是“异步”的在原生事件和<code>setTimeout</code> 中都是同步的</p><p><strong>2、</strong> <code>setState</code> 的“异步”并不是说内部由异步代码实现其实本身执行的过程和代码都是同步的只是合成事件和钩子函数的调用顺序在更新之前导致在合成事件和钩子函数中没法立马拿到更新后的值形成了所谓的“异步”当然可以通过第二个参数<code>setState(partialState, callback)</code>中的<code>callback</code>拿到更新后的结果</p><p><strong>3、</strong> <code>setState</code> 的批量更新优化也是建立在“异步”合成事件、钩子函数之上的在原生事件和<code>setTimeout</code> 中不会批量更新在“异步”中如果对同一个值进行多次<code>setState</code>的批量更新策略会对其进行覆盖取最后一次的执行如果是同时<code>setState</code>多个不同的值在更新时会对其进行合并批量更新</p><h3 id="_5、什么是高阶组件-hoc" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#5%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6hoc" target="_blank" rel="noreferrer">5、什么是高阶组件（HOC）？</a> <a class="header-anchor" href="#_5、什么是高阶组件-hoc" aria-label="Permalink to &quot;[5、什么是高阶组件（HOC）？](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新2021年面试题附答案解析，大汇总.md#5什么是高阶组件hoc)&quot;">​</a></h3><p>高阶组件是重用组件逻辑的高级方法，是一种源于 React 的组件模式。 HOC 是自定义组件，在它之内包含另一个组件。它们可以接受子组件提供的任何动态，但不会修改或复制其输入组件中的任何行为。你可以认为 HOC 是“纯（Pure）”组件。</p><h3 id="_6、setstate到底是异步还是同步" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#6setstate%E5%88%B0%E5%BA%95%E6%98%AF%E5%BC%82%E6%AD%A5%E8%BF%98%E6%98%AF%E5%90%8C%E6%AD%A5" target="_blank" rel="noreferrer">6、setState到底是异步还是同步?</a> <a class="header-anchor" href="#_6、setstate到底是异步还是同步" aria-label="Permalink to &quot;[6、setState到底是异步还是同步?](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新2021年面试题附答案解析，大汇总.md#6setstate到底是异步还是同步)&quot;">​</a></h3><p>先给出答案: 有时表现出异步,有时表现出同步</p><p><strong>1、</strong> <code>setState</code>只在合成事件和钩子函数中是“异步”的，在原生事件和<code>setTimeout</code> 中都是同步的</p><p><strong>2、</strong> <code>setState</code> 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 <code>setState(partialState, callback)</code> 中的<code>callback</code>拿到更新后的结果</p><p><strong>3、</strong> <code>setState</code> 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次<code>setState</code>，<code>setState</code>的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时<code>setState</code>多个不同的值，在更新时会对其进行合并批量更新</p><h3 id="_7、react有哪些限制" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#7react%E6%9C%89%E5%93%AA%E4%BA%9B%E9%99%90%E5%88%B6" target="_blank" rel="noreferrer">7、React有哪些限制？</a> <a class="header-anchor" href="#_7、react有哪些限制" aria-label="Permalink to &quot;[7、React有哪些限制？](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新2021年面试题附答案解析，大汇总.md#7react有哪些限制)&quot;">​</a></h3><p><strong>React的限制如下：</strong></p><p><strong>1、</strong> React 只是一个库，而不是一个完整的框架</p><p><strong>2、</strong> 它的库非常庞大，需要时间来理解</p><p><strong>3、</strong> 新手程序员可能很难理解</p><p><strong>4、</strong> 编码变得复杂，因为它使用内联模板和 JSX</p><h3 id="_8、redux的工作流程" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#8redux%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" target="_blank" rel="noreferrer">8、redux的工作流程?</a> <a class="header-anchor" href="#_8、redux的工作流程" aria-label="Permalink to &quot;[8、redux的工作流程?](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新2021年面试题附答案解析，大汇总.md#8redux的工作流程)&quot;">​</a></h3><p>首先，我们看下几个核心概念：</p><p><strong>1、</strong> Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。</p><p><strong>2、</strong> State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这种时点的数据集合，就叫做State。</p><p><strong>3、</strong> Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应该要发生变化了。</p><p><strong>4、</strong> Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，所以我们定义一个函数来生成Action，这个函数就叫Action Creator。</p><p><strong>5、</strong> Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参数，返回一个新的State。</p><p><strong>6、</strong> dispatch：是View发出Action的唯一方法。</p><p><strong>然后我们过下整个工作流程：</strong></p><p><strong>1、</strong> 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。</p><p><strong>2、</strong> 然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State</p><p><strong>3、</strong> State一旦有变化，Store就会调用监听函数，来更新View。</p><p>到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式保证了流程的清晰。</p><p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/4/30/1939/39/97_11.png#alt=97%5C_11.png" alt=""></p><h3 id="_9、你是如何理解fiber的" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#9%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3fiber%E7%9A%84" target="_blank" rel="noreferrer">9、你是如何理解fiber的?</a> <a class="header-anchor" href="#_9、你是如何理解fiber的" aria-label="Permalink to &quot;[9、你是如何理解fiber的?](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新2021年面试题附答案解析，大汇总.md#9你是如何理解fiber的)&quot;">​</a></h3><p>React Fiber 是一种基于浏览器的<strong>单线程调度算法</strong>.</p><p>React 16之前 ，<code>reconcilation</code> 算法实际上是递归，想要中断递归是很困难的，React 16 开始使用了循环来代替之前的递归.</p><p><code>Fiber</code>：<strong>一种将 <code>recocilation</code> （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。</strong></p><h3 id="_10、diff算法" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%A4%A7%E6%B1%87%E6%80%BB.md#10diff%E7%AE%97%E6%B3%95" target="_blank" rel="noreferrer">10、diff算法?</a> <a class="header-anchor" href="#_10、diff算法" aria-label="Permalink to &quot;[10、diff算法?](https://gitee.com/souyunku/DevBooks/blob/master/docs/React/React最新2021年面试题附答案解析，大汇总.md#10diff算法)&quot;">​</a></h3><p><strong>1、</strong> 把树形结构按照层级分解只比较同级元素。</p><p><strong>2、</strong> 给列表结构的每个单元添加唯一的key属性方便比较。</p><p><strong>3、</strong> <code>React</code> 只会匹配相同 <code>class</code> 的 <code>component</code>这里面的class指的是组件的名字</p><p><strong>4、</strong> 合并操作调用 <code>component</code> 的 <code>setState</code> 方法的时候, React 将其标记为 - <code>dirty</code>.到每一个事件循环结束, <code>React</code> 检查所有标记 <code>dirty</code>的 <code>component</code>重新绘制.</p><p><strong>5、</strong> 选择性子树渲染。开发人员可以重写 <code>shouldComponentUpdate</code>提高 <code>diff</code>的性能</p><h3 id="_11、redux三大原则" tabindex="-1">11、Redux三大原则 <a class="header-anchor" href="#_11、redux三大原则" aria-label="Permalink to &quot;11、Redux三大原则&quot;">​</a></h3><h3 id="_12、你对-time-slice的理解" tabindex="-1">12、你对 Time Slice的理解? <a class="header-anchor" href="#_12、你对-time-slice的理解" aria-label="Permalink to &quot;12、你对 Time Slice的理解?&quot;">​</a></h3><h3 id="_13、react-中的箭头函数是什么-怎么用" tabindex="-1">13、React 中的箭头函数是什么？怎么用？ <a class="header-anchor" href="#_13、react-中的箭头函数是什么-怎么用" aria-label="Permalink to &quot;13、React 中的箭头函数是什么？怎么用？&quot;">​</a></h3><h3 id="_14、为什么要用redux" tabindex="-1">14、为什么要用redux <a class="header-anchor" href="#_14、为什么要用redux" aria-label="Permalink to &quot;14、为什么要用redux&quot;">​</a></h3><h3 id="_15、keep-alive了解吗" tabindex="-1">15、keep-alive了解吗 <a class="header-anchor" href="#_15、keep-alive了解吗" aria-label="Permalink to &quot;15、keep-alive了解吗&quot;">​</a></h3><h3 id="_16、什么是react" tabindex="-1">16、什么是React？ <a class="header-anchor" href="#_16、什么是react" aria-label="Permalink to &quot;16、什么是React？&quot;">​</a></h3><h3 id="_17、详细解释-react-组件的生命周期方法。" tabindex="-1">17、详细解释 React 组件的生命周期方法。 <a class="header-anchor" href="#_17、详细解释-react-组件的生命周期方法。" aria-label="Permalink to &quot;17、详细解释 React 组件的生命周期方法。&quot;">​</a></h3><h3 id="_18、虚拟dom实现原理" tabindex="-1">18、虚拟DOM实现原理? <a class="header-anchor" href="#_18、虚拟dom实现原理" aria-label="Permalink to &quot;18、虚拟DOM实现原理?&quot;">​</a></h3><h3 id="_19、react中的合成事件是什么" tabindex="-1">19、React中的合成事件是什么？ <a class="header-anchor" href="#_19、react中的合成事件是什么" aria-label="Permalink to &quot;19、React中的合成事件是什么？&quot;">​</a></h3><h3 id="_20、列出一些应该使用-refs-的情况。" tabindex="-1">20、列出一些应该使用 Refs 的情况。 <a class="header-anchor" href="#_20、列出一些应该使用-refs-的情况。" aria-label="Permalink to &quot;20、列出一些应该使用 Refs 的情况。&quot;">​</a></h3><h3 id="_21、再说一下虚拟dom以及key属性的作用" tabindex="-1">21、再说一下虚拟Dom以及key属性的作用 <a class="header-anchor" href="#_21、再说一下虚拟dom以及key属性的作用" aria-label="Permalink to &quot;21、再说一下虚拟Dom以及key属性的作用&quot;">​</a></h3><h3 id="_22、react的请求应该放在哪个生命周期中" tabindex="-1">22、React的请求应该放在哪个生命周期中? <a class="header-anchor" href="#_22、react的请求应该放在哪个生命周期中" aria-label="Permalink to &quot;22、React的请求应该放在哪个生命周期中?&quot;">​</a></h3><h3 id="_23、react-中-key-的重要性是什么" tabindex="-1">23、React 中 key 的重要性是什么？ <a class="header-anchor" href="#_23、react-中-key-的重要性是什么" aria-label="Permalink to &quot;23、React 中 key 的重要性是什么？&quot;">​</a></h3><h3 id="_24、react中的事件是什么" tabindex="-1">24、React中的事件是什么？ <a class="header-anchor" href="#_24、react中的事件是什么" aria-label="Permalink to &quot;24、React中的事件是什么？&quot;">​</a></h3><h3 id="_25、redux实现原理解析" tabindex="-1">25、Redux实现原理解析 <a class="header-anchor" href="#_25、redux实现原理解析" aria-label="Permalink to &quot;25、Redux实现原理解析&quot;">​</a></h3><h3 id="_26、hoc-高阶组件" tabindex="-1">26、HOC(高阶组件) <a class="header-anchor" href="#_26、hoc-高阶组件" aria-label="Permalink to &quot;26、HOC(高阶组件)&quot;">​</a></h3><h3 id="_27、在生命周期中的哪一步你应该发起-ajax-请求" tabindex="-1">27、在生命周期中的哪一步你应该发起 AJAX 请求 <a class="header-anchor" href="#_27、在生命周期中的哪一步你应该发起-ajax-请求" aria-label="Permalink to &quot;27、在生命周期中的哪一步你应该发起 AJAX 请求&quot;">​</a></h3><h3 id="_28、ssr了解吗" tabindex="-1">28、SSR了解吗？ <a class="header-anchor" href="#_28、ssr了解吗" aria-label="Permalink to &quot;28、SSR了解吗？&quot;">​</a></h3>`,85),c=[o];function p(l,r,i,d,f,h){return s(),a("div",null,c)}const m=e(t,[["render",p]]);export{u as __pageData,m as default};
