import{_ as e,o,c as r,V as a}from"./chunks/framework.c6d8cbec.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/zookeeper/zookeeper-01.md","filePath":"interview/backend/zookeeper/zookeeper-01.md"}'),t={name:"interview/backend/zookeeper/zookeeper-01.md"},E=a('<h3 id="_1、几种部署方式" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#1%E5%87%A0%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F" target="_blank" rel="noreferrer">1、几种部署方式？</a> <a class="header-anchor" href="#_1、几种部署方式" aria-label="Permalink to &quot;[1、几种部署方式？](https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper最新2021年面试题，高级面试题及附答案解析.md#1几种部署方式)&quot;">​</a></h3><p>单机、伪集群、集群</p><h3 id="_2、发布订阅的两种设计模式" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#2%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noreferrer">2、发布订阅的两种设计模式？</a> <a class="header-anchor" href="#_2、发布订阅的两种设计模式" aria-label="Permalink to &quot;[2、发布订阅的两种设计模式？](https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper最新2021年面试题，高级面试题及附答案解析.md#2发布订阅的两种设计模式)&quot;">​</a></h3><p>推(Push) :服务端主动推数据给所有定于的客户端。</p><p>拉(Pull):客户端主动发请求来获取最新数据。</p><h3 id="_3、服务端处理-watcher-实现" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86-watcher-%E5%AE%9E%E7%8E%B0" target="_blank" rel="noreferrer">3、服务端处理 Watcher 实现</a> <a class="header-anchor" href="#_3、服务端处理-watcher-实现" aria-label="Permalink to &quot;[3、服务端处理 Watcher 实现](https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper最新2021年面试题，高级面试题及附答案解析.md#3服务端处理-watcher-实现)&quot;">​</a></h3><p><strong>1、</strong> 服务端接收 Watcher 并存储 接收到客户端请求，处理请求判断是否需要注册 Watcher，需要的话将数据节点的节点路径和 ServerCnxn（ServerCnxn 代表一个客户端和服务端的连接，实现了 Watcher 的 process 接口，此时可以看成一个 Watcher 对象）存储在WatcherManager 的 WatchTable 和 watch2Paths 中去。</p><p><strong>2、</strong> Watcher 触发 以服务端接收到 setData() 事务请求触发 NodeDataChanged 事件为例：</p><p>2.1 封装 WatchedEvent 将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路径封装成一个 WatchedEvent 对象</p><p>2.2 查询 Watcher 从 WatchTable 中根据节点路径查找 Watcher</p><p>2.3 没找到；说明没有客户端在该数据节点上注册过 Watcher</p><p>2.4 找到；提取并从 WatchTable 和 Watch2Paths 中删除对应 Watcher（从这里可以看出 Watcher 在服务端是一次性的，触发一次就失效了）</p><p><strong>3、</strong> 调用 process 方法来触发 Watcher 这里 process 主要就是通过 ServerCnxn 对应的 TCP 连接发送 Watcher 事件通知。</p><h3 id="_4、zk节点宕机如何处理" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#4zk%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86" target="_blank" rel="noreferrer">4、zk节点宕机如何处理？</a> <a class="header-anchor" href="#_4、zk节点宕机如何处理" aria-label="Permalink to &quot;[4、zk节点宕机如何处理？](https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper最新2021年面试题，高级面试题及附答案解析.md#4zk节点宕机如何处理)&quot;">​</a></h3><p>Zookeeper本身也是集群，推荐配置不少于3个服务器。Zookeeper自身也要保证当一个节点宕机时，其他节点会继续提供服务。</p><p>如果是一个Follower宕机，还有2台服务器提供访问，因为Zookeeper上的数据是有多个副本的，数据并不会丢失；</p><p>如果是一个Leader宕机，Zookeeper会选举出新的Leader。</p><p>ZK集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。</p><p>所以</p><p>3个节点的cluster可以挂掉1个节点(leader可以得到2票&gt;1.5)</p><p>2个节点的cluster就不能挂掉任何1个节点了(leader可以得到1票&lt;=1)</p><h3 id="_5、zookeeper-对节点的-watch-监听通知是永久的吗-为什么不是永久的" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#5zookeeper-%E5%AF%B9%E8%8A%82%E7%82%B9%E7%9A%84-watch-%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%98%AF%E6%B0%B8%E4%B9%85%E7%9A%84%E5%90%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E6%B0%B8%E4%B9%85%E7%9A%84" target="_blank" rel="noreferrer">5、Zookeeper 对节点的 watch 监听通知是永久的吗？为什么不是永久的?</a> <a class="header-anchor" href="#_5、zookeeper-对节点的-watch-监听通知是永久的吗-为什么不是永久的" aria-label="Permalink to &quot;[5、Zookeeper 对节点的 watch 监听通知是永久的吗？为什么不是永久的?](https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper最新2021年面试题，高级面试题及附答案解析.md#5zookeeper-对节点的-watch-监听通知是永久的吗为什么不是永久的)&quot;">​</a></h3><p><strong>1、</strong> 不是。官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。</p><p><strong>2、</strong> 为什么不是永久的，举个例子，如果服务端变动频繁，而监听的客户端很多情况下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。</p><p><strong>3、</strong> 一般是客户端执行 getData(“/节点 A”,true)，如果节点 A 发生了变更或删除，客户端会得到它的 watch 事件，但是在之后节点 A 又发生了变更，而客户端又没有设置 watch 事件，就不再给客户端发送。</p><p><strong>4、</strong> 在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我只要最新的数据即可。</p><h3 id="_6、zookeeper-怎么保证主从节点的状态同步" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#6zookeeper-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5" target="_blank" rel="noreferrer">6、Zookeeper 怎么保证主从节点的状态同步？</a> <a class="header-anchor" href="#_6、zookeeper-怎么保证主从节点的状态同步" aria-label="Permalink to &quot;[6、Zookeeper 怎么保证主从节点的状态同步？](https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper最新2021年面试题，高级面试题及附答案解析.md#6zookeeper-怎么保证主从节点的状态同步)&quot;">​</a></h3><p>Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。</p><h3 id="_7、数据发布-订阅" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#7%E6%95%B0%E6%8D%AE%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85" target="_blank" rel="noreferrer">7、数据发布/订阅</a> <a class="header-anchor" href="#_7、数据发布-订阅" aria-label="Permalink to &quot;[7、数据发布/订阅](https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper最新2021年面试题，高级面试题及附答案解析.md#7数据发布/订阅)&quot;">​</a></h3><p><strong>介绍</strong></p><p>数据发布/订阅系统，即所谓的配置中心，顾名思义就是发布者发布数据供订阅者进行数据订阅。</p><p><strong>目的</strong></p><p><strong>1、</strong> 动态获取数据（配置信息）</p><p><strong>2、</strong> 实现数据（配置信息）的集中式管理和数据的动态更新</p><p><strong>设计模式</strong></p><p><strong>1、</strong> Push 模式</p><p><strong>2、</strong> Pull 模式</p><p><strong>数据（配置信息）特性</strong></p><p><strong>1、</strong> 数据量通常比较小</p><p><strong>2、</strong> 数据内容在运行时会发生动态更新</p><p><strong>3、</strong> 集群中各机器共享，配置一致</p><p>如：机器列表信息、运行时开关配置、数据库配置信息等</p><p><strong>基于 Zookeeper 的实现方式</strong></p><p><strong>1、</strong> 数据存储：将数据（配置信息）存储到 Zookeeper 上的一个数据节点</p><p><strong>2、</strong> 数据获取：应用在启动初始化节点从 Zookeeper 数据节点读取数据，并在该节点上注册一个数据变更 Watcher</p><p><strong>3、</strong> 数据变更：当变更数据时，更新 Zookeeper 对应节点数据，Zookeeper会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即可。</p><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h1><h3 id="_8、同进程组的两个进程消息网络通信有哪两个特性" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#8%E5%90%8C%E8%BF%9B%E7%A8%8B%E7%BB%84%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%80%A7" target="_blank" rel="noreferrer">8、同进程组的两个进程消息网络通信有哪两个特性？</a> <a class="header-anchor" href="#_8、同进程组的两个进程消息网络通信有哪两个特性" aria-label="Permalink to &quot;[8、同进程组的两个进程消息网络通信有哪两个特性？](https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper最新2021年面试题，高级面试题及附答案解析.md#8同进程组的两个进程消息网络通信有哪两个特性)&quot;">​</a></h3><p>完整性： 如果进程a收到进程b的消息msg,那么b一定发送了消息msg。</p><p>前置性：如果msg1是msg2的前置消息，那么当前进程务必先接收到msg1,在接受msg2。</p><h3 id="_9、zookeeper-是如何保证事务的顺序一致性的" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#9zookeeper-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84" target="_blank" rel="noreferrer">9、zookeeper 是如何保证事务的顺序一致性的？</a> <a class="header-anchor" href="#_9、zookeeper-是如何保证事务的顺序一致性的" aria-label="Permalink to &quot;[9、zookeeper 是如何保证事务的顺序一致性的？](https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper最新2021年面试题，高级面试题及附答案解析.md#9zookeeper-是如何保证事务的顺序一致性的)&quot;">​</a></h3><p>zookeeper 采用了全局递增的事务 Id 来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（ 时期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p><h3 id="_10、chroot特性" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper%E6%9C%80%E6%96%B02021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E9%99%84%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md#10chroot%E7%89%B9%E6%80%A7" target="_blank" rel="noreferrer">10、Chroot特性</a> <a class="header-anchor" href="#_10、chroot特性" aria-label="Permalink to &quot;[10、Chroot特性](https://gitee.com/souyunku/DevBooks/blob/master/docs/ZooKeeper/ZooKeeper最新2021年面试题，高级面试题及附答案解析.md#10chroot特性)&quot;">​</a></h3><p>3.2.0版本后，添加了 Chroot特性，该特性允许每个客户端为自己设置一个命名空间。如果一个客户端设置了Chroot，那么该客户端对服务器的任何操作，都将会被限制在其自己的命名空间下。</p><p>通过设置Chroot，能够将一个客户端应用于Zookeeper服务端的一颗子树相对应，在那些多个应用公用一个Zookeeper进群的场景下，对实现不同应用间的相互隔离非常有帮助。</p><h3 id="_11、四种类型的数据节点-znode" tabindex="-1">11、四种类型的数据节点 Znode <a class="header-anchor" href="#_11、四种类型的数据节点-znode" aria-label="Permalink to &quot;11、四种类型的数据节点 Znode&quot;">​</a></h3><h3 id="_12、客户端回调watcher" tabindex="-1">12、客户端回调Watcher <a class="header-anchor" href="#_12、客户端回调watcher" aria-label="Permalink to &quot;12、客户端回调Watcher&quot;">​</a></h3><h3 id="_13、zookeeper-负载均衡和-nginx-负载均衡区别" tabindex="-1">13、zookeeper 负载均衡和 nginx 负载均衡区别 <a class="header-anchor" href="#_13、zookeeper-负载均衡和-nginx-负载均衡区别" aria-label="Permalink to &quot;13、zookeeper 负载均衡和 nginx 负载均衡区别&quot;">​</a></h3><h3 id="_14、acl-权限控制机制" tabindex="-1">14、ACL 权限控制机制 <a class="header-anchor" href="#_14、acl-权限控制机制" aria-label="Permalink to &quot;14、ACL 权限控制机制&quot;">​</a></h3><h3 id="_15、chroot-特性" tabindex="-1">15、Chroot 特性 <a class="header-anchor" href="#_15、chroot-特性" aria-label="Permalink to &quot;15、Chroot 特性&quot;">​</a></h3><h3 id="_16、获取分布式锁的流程" tabindex="-1">16、获取分布式锁的流程 <a class="header-anchor" href="#_16、获取分布式锁的流程" aria-label="Permalink to &quot;16、获取分布式锁的流程&quot;">​</a></h3><h3 id="_17、zookeeper负载均衡和nginx负载均衡区别" tabindex="-1">17、zookeeper负载均衡和nginx负载均衡区别 <a class="header-anchor" href="#_17、zookeeper负载均衡和nginx负载均衡区别" aria-label="Permalink to &quot;17、zookeeper负载均衡和nginx负载均衡区别&quot;">​</a></h3><h3 id="_18、zookeeper通知机制" tabindex="-1">18、Zookeeper通知机制 <a class="header-anchor" href="#_18、zookeeper通知机制" aria-label="Permalink to &quot;18、Zookeeper通知机制&quot;">​</a></h3><h3 id="_19、数据同步" tabindex="-1">19、数据同步 <a class="header-anchor" href="#_19、数据同步" aria-label="Permalink to &quot;19、数据同步&quot;">​</a></h3><h3 id="_20、zookeeper-watch机制" tabindex="-1">20、zookeeper watch机制 <a class="header-anchor" href="#_20、zookeeper-watch机制" aria-label="Permalink to &quot;20、zookeeper watch机制&quot;">​</a></h3><h3 id="_21、zookeeper同步流程" tabindex="-1">21、Zookeeper同步流程 <a class="header-anchor" href="#_21、zookeeper同步流程" aria-label="Permalink to &quot;21、Zookeeper同步流程&quot;">​</a></h3><h3 id="_22、zk-节点宕机如何处理" tabindex="-1">22、zk 节点宕机如何处理？ <a class="header-anchor" href="#_22、zk-节点宕机如何处理" aria-label="Permalink to &quot;22、zk 节点宕机如何处理？&quot;">​</a></h3><h3 id="_23、zookeeper分布式锁-文件系统、通知机制" tabindex="-1">23、Zookeeper分布式锁（文件系统、通知机制） <a class="header-anchor" href="#_23、zookeeper分布式锁-文件系统、通知机制" aria-label="Permalink to &quot;23、Zookeeper分布式锁（文件系统、通知机制）&quot;">​</a></h3><h3 id="_24、机器中为什么会有leader" tabindex="-1">24、机器中为什么会有leader？ <a class="header-anchor" href="#_24、机器中为什么会有leader" aria-label="Permalink to &quot;24、机器中为什么会有leader？&quot;">​</a></h3><h3 id="_25、zk的配置管理-文件系统、通知机制" tabindex="-1">25、zk的配置管理（文件系统、通知机制） <a class="header-anchor" href="#_25、zk的配置管理-文件系统、通知机制" aria-label="Permalink to &quot;25、zk的配置管理（文件系统、通知机制）&quot;">​</a></h3><h3 id="_26、更新指定节点信息" tabindex="-1">26、更新指定节点信息？ <a class="header-anchor" href="#_26、更新指定节点信息" aria-label="Permalink to &quot;26、更新指定节点信息？&quot;">​</a></h3><h3 id="_27、如何创建一个znode" tabindex="-1">27、如何创建一个ZNode? <a class="header-anchor" href="#_27、如何创建一个znode" aria-label="Permalink to &quot;27、如何创建一个ZNode?&quot;">​</a></h3><h3 id="_28、zookeeper数据复制" tabindex="-1">28、Zookeeper数据复制 <a class="header-anchor" href="#_28、zookeeper数据复制" aria-label="Permalink to &quot;28、Zookeeper数据复制&quot;">​</a></h3><h3 id="_29、watcher-特性总结" tabindex="-1">29、Watcher 特性总结 <a class="header-anchor" href="#_29、watcher-特性总结" aria-label="Permalink to &quot;29、Watcher 特性总结&quot;">​</a></h3><h3 id="_30、zookeeper可以实现哪些功能" tabindex="-1">30、ZooKeeper可以实现哪些功能？ <a class="header-anchor" href="#_30、zookeeper可以实现哪些功能" aria-label="Permalink to &quot;30、ZooKeeper可以实现哪些功能？&quot;">​</a></h3><h3 id="_31、zookeeper对节点的watch监听通知是永久的吗-为什么不是永久的" tabindex="-1">31、Zookeeper对节点的watch监听通知是永久的吗？为什么不是永久的? <a class="header-anchor" href="#_31、zookeeper对节点的watch监听通知是永久的吗-为什么不是永久的" aria-label="Permalink to &quot;31、Zookeeper对节点的watch监听通知是永久的吗？为什么不是永久的?&quot;">​</a></h3>',76),h=[E];function s(p,n,A,l,c,d){return o(),r("div",null,h)}const B=e(t,[["render",s]]);export{k as __pageData,B as default};
