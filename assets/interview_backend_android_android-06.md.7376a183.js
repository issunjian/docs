import{_ as e,o as a,c as n,V as s}from"./chunks/framework.c6d8cbec.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/android/android-06.md","filePath":"interview/backend/android/android-06.md"}'),o={name:"interview/backend/android/android-06.md"},r=s(`<h3 id="_1、在-service-的生命周期方法-onstartconmand-可不可以执行网络操作-如何在-service-中执行网络操作" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#1%E5%9C%A8-service-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95-onstartconmand%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%89%A7%E8%A1%8C%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E5%A6%82%E4%BD%95%E5%9C%A8-service-%E4%B8%AD%E6%89%A7%E8%A1%8C%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C" target="_blank" rel="noreferrer">1、在 service 的生命周期方法 onstartConmand()可不可以执行网络操作？如何在 service 中执行网络操作？</a> <a class="header-anchor" href="#_1、在-service-的生命周期方法-onstartconmand-可不可以执行网络操作-如何在-service-中执行网络操作" aria-label="Permalink to &quot;[1、在 service 的生命周期方法 onstartConmand()可不可以执行网络操作？如何在 service 中执行网络操作？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android最新面试题，2021年面试题及答案汇总.md#1在-service-的生命周期方法-onstartconmand可不可以执行网络操作如何在-service-中执行网络操作)&quot;">​</a></h3><p>可以的，就在onstartConmand方法内执行。</p><h3 id="_2、简述tcp-udp-socket" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#2%E7%AE%80%E8%BF%B0tcpudpsocket" target="_blank" rel="noreferrer">2、简述TCP，UDP，Socket</a> <a class="header-anchor" href="#_2、简述tcp-udp-socket" aria-label="Permalink to &quot;[2、简述TCP，UDP，Socket](https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android最新面试题，2021年面试题及答案汇总.md#2简述tcpudpsocket)&quot;">​</a></h3><p>TCP是经过3次握手，4次挥手完成一串数据的传送</p><p>UDP是无连接的，知道IP地址和端口号，向其发送数据即可，不管数据是否发送成功</p><p>Socket是一种不同计算机，实时连接，比如说传送文件，即时通讯</p><h3 id="_3、android-中如何捕获未捕获的异常" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#3android-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E6%9C%AA%E6%8D%95%E8%8E%B7%E7%9A%84%E5%BC%82%E5%B8%B8" target="_blank" rel="noreferrer">3、Android 中如何捕获未捕获的异常</a> <a class="header-anchor" href="#_3、android-中如何捕获未捕获的异常" aria-label="Permalink to &quot;[3、Android 中如何捕获未捕获的异常](https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android最新面试题，2021年面试题及答案汇总.md#3android-中如何捕获未捕获的异常)&quot;">​</a></h3><p><strong>UncaughtExceptionHandler</strong></p><p><strong>1、</strong> 自 定 义 一 个 Application ， 比 如 叫 MyApplication 继 承 Application 实 现UncaughtExceptionHandler。</p><p><strong>2、</strong> 覆写 UncaughtExceptionHandler 的 onCreate 和 uncaughtException 方法。 注意：上面的代码只是简单的将异常打印出来。在 onCreate 方法中我们给 Thread 类设置默认异常处理 handler，如果这句代码不执行则一切都是白搭。在 uncaughtException 方法中我们必须新开辟个线程进行我们异常的收集工作，然后将系统给杀死。</p><p><strong>3、</strong> 在 AndroidManifest 中配置该 Application：&lt;application android:name=&quot;com.example.uncatchexception.MyApplication&quot;</p><p>Bug 收集工具 Crashlytics</p><p>Crashlytics 是专门为移动应用开发者提供的保存和分析应用崩溃的工具。国内主要使用的是友盟做数据统计。</p><p><strong>Crashlytics 的好处：</strong></p><p><strong>1、</strong> Crashlytics 不会漏掉任何应用崩溃信息。</p><p><strong>2、</strong> Crashlytics 可以象 Bug 管理工具那样，管理这些崩溃日志。</p><p><strong>3、</strong> Crashlytics 可以每天和每周将崩溃信息汇总发到你的邮箱，所有信息一目了然。</p><h3 id="_4、android中的动画有哪几类-它们的特点和区别是什么" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#4android%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E6%9C%89%E5%93%AA%E5%87%A0%E7%B1%BB%E5%AE%83%E4%BB%AC%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noreferrer">4、android中的动画有哪几类，它们的特点和区别是什么</a> <a class="header-anchor" href="#_4、android中的动画有哪几类-它们的特点和区别是什么" aria-label="Permalink to &quot;[4、android中的动画有哪几类，它们的特点和区别是什么](https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android最新面试题，2021年面试题及答案汇总.md#4android中的动画有哪几类它们的特点和区别是什么)&quot;">​</a></h3><p>两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。</p><h3 id="_5、android-中的动画有哪几类-它们的特点和区别是什么" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#5android-%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E6%9C%89%E5%93%AA%E5%87%A0%E7%B1%BB%E5%AE%83%E4%BB%AC%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noreferrer">5、Android 中的动画有哪几类，它们的特点和区别是什么</a> <a class="header-anchor" href="#_5、android-中的动画有哪几类-它们的特点和区别是什么" aria-label="Permalink to &quot;[5、Android 中的动画有哪几类，它们的特点和区别是什么](https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android最新面试题，2021年面试题及答案汇总.md#5android-中的动画有哪几类它们的特点和区别是什么)&quot;">​</a></h3><p>Frame Animation(帧动画)主要用于播放一帧帧准备好的图片，类似GIF图片，优点是使用简单方便、缺点是需要事先准备好每一帧图片；</p><p>Tween Animation(补间动画)仅需定义开始与结束的关键帧，而变化的中间帧由系统补上，优点是不用准备每一帧，缺点是只改变了对象绘制，而没有改变View本身属性。因此如果改变了按钮的位置，还是需要点击原来按钮所在位置才有效。</p><p>Property Animation(属性动画)是3.0后推出的动画，优点是使用简单、降低实现的复杂度、直接更改对象的属性、几乎可适用于任何对象而仅非View类，主要包括ValueAnimator和ObjectAnimator</p><h3 id="_6、java中如何引用本地语言" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#6java%E4%B8%AD%E5%A6%82%E4%BD%95%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E8%AF%AD%E8%A8%80" target="_blank" rel="noreferrer">6、java中如何引用本地语言</a> <a class="header-anchor" href="#_6、java中如何引用本地语言" aria-label="Permalink to &quot;[6、java中如何引用本地语言](https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android最新面试题，2021年面试题及答案汇总.md#6java中如何引用本地语言)&quot;">​</a></h3><p>可以用JNI（java native interface java 本地接口）接口 。</p><h3 id="_7、请解释下在单线程模型中message、handler、message-queue、looper之间的关系。" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#7%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%8B%E5%9C%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%ADmessagehandlermessage-queuelooper%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%82" target="_blank" rel="noreferrer">7、请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。</a> <a class="header-anchor" href="#_7、请解释下在单线程模型中message、handler、message-queue、looper之间的关系。" aria-label="Permalink to &quot;[7、请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。](https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android最新面试题，2021年面试题及答案汇总.md#7请解释下在单线程模型中messagehandlermessage-queuelooper之间的关系。)&quot;">​</a></h3><p>简单的说，Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理.</p><p>Message Queue(消息队列)：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列</p><p>Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息</p><p>Looper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的</p><p>Handler：Handler接受到消息后调用handleMessage进行处理</p><p>Message：消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理</p><p>在单线程模型下，为了线程通信问题，Android设计了一个Message Queue(消息队列)， 线程间可以通过该Message Queue并结合Handler和Looper组件进行信息交换。下面将对它们进行分别介绍：</p><p><strong>Message</strong></p><p>Message消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。</p><p><strong>Handler</strong></p><p>Handler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的 Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。</p><p><strong>Message Queue</strong></p><p>Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。</p><p>每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被 Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。</p><p><strong>Looper</strong></p><p>Looper是每条线程里的Message Queue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper() 得到当前线程的Looper就有可能为NULL。对于子线程使用Looper，API Doc提供了正确的使用方法：这个Message机制的大概流程：</p><p><strong>1、</strong> 在Looper.loop()方法运行开始后，循环地按照接收顺序取出Message Queue里面的非NULL的Message。</p><p><strong>2、</strong> 一开始Message Queue里面的Message都是NULL的。当Handler.sendMessage(Message)到Message Queue，该函数里面设置了那个Message对象的target属性是当前的Handler对象。随后Looper取出了那个Message，则调用 该Message的target指向的Hander的dispatchMessage函数对Message进行处理。在dispatchMessage方法里，如何处理Message则由用户指定，三个判断，优先级从高到低：</p><p><strong>1、</strong> Message里面的Callback，一个实现了Runnable接口的对象，其中run函数做处理工作；</p><p><strong>2、</strong> Handler里面的mCallback指向的一个实现了Callback接口的对象，由其handleMessage进行处理；</p><p><strong>3、</strong> 处理消息Handler对象对应的类继承并实现了其中handleMessage函数，通过这个实现的handleMessage函数处理消息。</p><p>由此可见，我们实现的handleMessage方法是优先级最低的！</p><p>3\\、Handler处理完该Message (update UI) 后，Looper则设置该Message为NULL，以便回收！</p><p>在网上有很多文章讲述主线程和其他子线程如何交互，传送信息，最终谁来执行处理信息之类的，个人理解是最简单的方法——判断Handler对象里面的Looper对象是属于哪条线程的，则由该线程来执行！</p><p>1\\、当Handler对象的构造函数的参数为空，则为当前所在线程的Looper；</p><p>2\\、Looper.getMainLooper()得到的是主线程的Looper对象，Looper.myLooper()得到的是当前线程的Looper对象。</p><h3 id="_8、广播注册" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#8%E5%B9%BF%E6%92%AD%E6%B3%A8%E5%86%8C" target="_blank" rel="noreferrer">8、广播注册</a> <a class="header-anchor" href="#_8、广播注册" aria-label="Permalink to &quot;[8、广播注册](https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android最新面试题，2021年面试题及答案汇总.md#8广播注册)&quot;">​</a></h3><p>首先写一个类要继承BroadCastReceiver</p><p>第一种：在清单文件中声明，添加</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">&lt;receive android:name=&quot;.BroadCastReceiverDemo&quot;&gt;</span></span>
<span class="line"><span style="color:#f6f6f4;">&lt;intent-filter&gt;</span></span>
<span class="line"><span style="color:#f6f6f4;">&lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;&gt;</span></span>
<span class="line"><span style="color:#f6f6f4;">&lt;/intent-filter&gt;</span></span>
<span class="line"><span style="color:#f6f6f4;">&lt;/receiver&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;receive android:name=&quot;.BroadCastReceiverDemo&quot;&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;intent-filter&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;/intent-filter&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;/receiver&gt;</span></span></code></pre></div><p>第二种：使用代码进行注册如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">IntentFilter filter = new IntentFilter(&quot;android.provider.Telephony.SMS_RECEIVED&quot;);</span></span>
<span class="line"><span style="color:#f6f6f4;">BroadCastReceiverDemo receiver = new BroadCastReceiver();</span></span>
<span class="line"><span style="color:#f6f6f4;">registerReceiver(receiver, filter);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">IntentFilter filter = new IntentFilter(&quot;android.provider.Telephony.SMS_RECEIVED&quot;);</span></span>
<span class="line"><span style="color:#24292e;">BroadCastReceiverDemo receiver = new BroadCastReceiver();</span></span>
<span class="line"><span style="color:#24292e;">registerReceiver(receiver, filter);</span></span></code></pre></div><p>两种注册类型的区别是：</p><p>a.第一种是常驻型广播，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</p><p>b.第二种不是常驻广播，也就是说广播跟随程序的生命周期。</p><h3 id="_9、service生命周期" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#9service%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noreferrer">9、Service生命周期</a> <a class="header-anchor" href="#_9、service生命周期" aria-label="Permalink to &quot;[9、Service生命周期](https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android最新面试题，2021年面试题及答案汇总.md#9service生命周期)&quot;">​</a></h3><p>在Service的生命周期里，常用的有：</p><p>4个手动调用的方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">startService()    启动服务</span></span>
<span class="line"><span style="color:#f6f6f4;">stopService()    关闭服务</span></span>
<span class="line"><span style="color:#f6f6f4;">bindService()    绑定服务</span></span>
<span class="line"><span style="color:#f6f6f4;">unbindService()    解绑服务</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">startService()    启动服务</span></span>
<span class="line"><span style="color:#24292e;">stopService()    关闭服务</span></span>
<span class="line"><span style="color:#24292e;">bindService()    绑定服务</span></span>
<span class="line"><span style="color:#24292e;">unbindService()    解绑服务</span></span></code></pre></div><p>5个内部自动调用的方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki dracula-soft vp-code-dark"><code><span class="line"><span style="color:#f6f6f4;">onCreat()            创建服务</span></span>
<span class="line"><span style="color:#f6f6f4;">onStartCommand()    开始服务</span></span>
<span class="line"><span style="color:#f6f6f4;">onDestroy()            销毁服务</span></span>
<span class="line"><span style="color:#f6f6f4;">onBind()            绑定服务</span></span>
<span class="line"><span style="color:#f6f6f4;">onUnbind()            解绑服务</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">onCreat()            创建服务</span></span>
<span class="line"><span style="color:#24292e;">onStartCommand()    开始服务</span></span>
<span class="line"><span style="color:#24292e;">onDestroy()            销毁服务</span></span>
<span class="line"><span style="color:#24292e;">onBind()            绑定服务</span></span>
<span class="line"><span style="color:#24292e;">onUnbind()            解绑服务</span></span></code></pre></div><p><strong>1、</strong> 手动调用startService()启动服务，自动调用内部方法：onCreate()、onStartCommand()，如果一个Service被startService()多次启动，那么onCreate()也只会调用一次。</p><p><strong>2、</strong> 手动调用stopService()关闭服务，自动调用内部方法：onDestory()，如果一个Service被启动且被绑定，如果在没有解绑的前提下使用stopService()关闭服务是无法停止服务的。</p><p><strong>3、</strong> 手动调用bindService()后，自动调用内部方法：onCreate()、onBind()。</p><p><strong>4、</strong> 手动调用unbindService()后，自动调用内部方法：onUnbind()、onDestory()。</p><p><strong>5、</strong> startService()和stopService()只能开启和关闭Service，无法操作Service，调用者退出后Service仍然存在；bindService()和unbindService()可以操作Service，调用者退出后，Service随着调用者销毁。</p><h3 id="_10、请介绍下-asynctask-的内部实现和适用的场景" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C2021%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#10%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%8B-asynctask-%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%92%8C%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF" target="_blank" rel="noreferrer">10、请介绍下 AsyncTask 的内部实现和适用的场景</a> <a class="header-anchor" href="#_10、请介绍下-asynctask-的内部实现和适用的场景" aria-label="Permalink to &quot;[10、请介绍下 AsyncTask 的内部实现和适用的场景](https://gitee.com/souyunku/DevBooks/blob/master/docs/Android/Android最新面试题，2021年面试题及答案汇总.md#10请介绍下-asynctask-的内部实现和适用的场景)&quot;">​</a></h3><p>AsyncTask 内部也是 Handler 机制来完成的，只不过 Android 提供了执行框架来提供线程池来执行相应地任务，因为线程池的大小问题，所以 AsyncTask 只应该用来执行耗时时间较短的任务，比如 HTTP 请求，大规模的下载和数据库的更改不适用于 AsyncTask，因为会导致线程池堵塞，没有线程来执行其他的任务，导致的情形是会发生 AsyncTask 根本执行不了的问题</p><h3 id="_11、说下activity-的四种启动模式、应用场景" tabindex="-1">11、说下Activity 的四种启动模式、应用场景 ？ <a class="header-anchor" href="#_11、说下activity-的四种启动模式、应用场景" aria-label="Permalink to &quot;11、说下Activity 的四种启动模式、应用场景 ？&quot;">​</a></h3><h3 id="_12、ndk是什么" tabindex="-1">12、NDK是什么 <a class="header-anchor" href="#_12、ndk是什么" aria-label="Permalink to &quot;12、NDK是什么&quot;">​</a></h3><h3 id="_13、请介绍下android中常用的五种布局。" tabindex="-1">13、请介绍下Android中常用的五种布局。 <a class="header-anchor" href="#_13、请介绍下android中常用的五种布局。" aria-label="Permalink to &quot;13、请介绍下Android中常用的五种布局。&quot;">​</a></h3><h3 id="_14、activity在屏幕旋转时的生命周期" tabindex="-1">14、activity在屏幕旋转时的生命周期 <a class="header-anchor" href="#_14、activity在屏幕旋转时的生命周期" aria-label="Permalink to &quot;14、activity在屏幕旋转时的生命周期&quot;">​</a></h3><h3 id="_15、android中4大组件" tabindex="-1">15、Android中4大组件 <a class="header-anchor" href="#_15、android中4大组件" aria-label="Permalink to &quot;15、Android中4大组件&quot;">​</a></h3><h3 id="_16、如何对-android-应用进行性能分析" tabindex="-1">16、如何对 Android 应用进行性能分析 <a class="header-anchor" href="#_16、如何对-android-应用进行性能分析" aria-label="Permalink to &quot;16、如何对 Android 应用进行性能分析&quot;">​</a></h3><h3 id="_17、listview-中图片错位的问题是如何产生的" tabindex="-1">17、ListView 中图片错位的问题是如何产生的 <a class="header-anchor" href="#_17、listview-中图片错位的问题是如何产生的" aria-label="Permalink to &quot;17、ListView 中图片错位的问题是如何产生的&quot;">​</a></h3><h3 id="_18、fragment与activity如何传值和交互" tabindex="-1">18、Fragment与activity如何传值和交互？ <a class="header-anchor" href="#_18、fragment与activity如何传值和交互" aria-label="Permalink to &quot;18、Fragment与activity如何传值和交互？&quot;">​</a></h3><h3 id="_19、android本身的api并未声明会抛出异常-则其在运行时有无可能抛出runtime异常-你遇到过吗-诺有的话会导致什么问题-如何解决" tabindex="-1">19、Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗？诺有的话会导致什么问题？如何解决？ <a class="header-anchor" href="#_19、android本身的api并未声明会抛出异常-则其在运行时有无可能抛出runtime异常-你遇到过吗-诺有的话会导致什么问题-如何解决" aria-label="Permalink to &quot;19、Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗？诺有的话会导致什么问题？如何解决？&quot;">​</a></h3><h3 id="_20、说说-lrucache-底层原理" tabindex="-1">20、说说 LruCache 底层原理 <a class="header-anchor" href="#_20、说说-lrucache-底层原理" aria-label="Permalink to &quot;20、说说 LruCache 底层原理&quot;">​</a></h3><h3 id="_21、android数字签名" tabindex="-1">21、Android数字签名 <a class="header-anchor" href="#_21、android数字签名" aria-label="Permalink to &quot;21、Android数字签名&quot;">​</a></h3><h3 id="_22、activity的状态有几种" tabindex="-1">22、Activity的状态有几种？ <a class="header-anchor" href="#_22、activity的状态有几种" aria-label="Permalink to &quot;22、Activity的状态有几种？&quot;">​</a></h3><h3 id="_23、android的数据存储" tabindex="-1">23、android的数据存储 <a class="header-anchor" href="#_23、android的数据存储" aria-label="Permalink to &quot;23、android的数据存储&quot;">​</a></h3><h3 id="_24、一条最长的短信息约占多少byte" tabindex="-1">24、一条最长的短信息约占多少byte? <a class="header-anchor" href="#_24、一条最长的短信息约占多少byte" aria-label="Permalink to &quot;24、一条最长的短信息约占多少byte?&quot;">​</a></h3><h3 id="_25、fragment-的-replace-和-add-方法的区别" tabindex="-1">25、Fragment 的 replace 和 add 方法的区别 <a class="header-anchor" href="#_25、fragment-的-replace-和-add-方法的区别" aria-label="Permalink to &quot;25、Fragment 的 replace 和 add 方法的区别&quot;">​</a></h3><h3 id="_26、为什么android引入广播机制" tabindex="-1">26、为什么Android引入广播机制? <a class="header-anchor" href="#_26、为什么android引入广播机制" aria-label="Permalink to &quot;26、为什么Android引入广播机制?&quot;">​</a></h3><h3 id="_27、如何退出activity-如何安全退出已调用多个activity的application" tabindex="-1">27、如何退出Activity？如何安全退出已调用多个Activity的Application？ <a class="header-anchor" href="#_27、如何退出activity-如何安全退出已调用多个activity的application" aria-label="Permalink to &quot;27、如何退出Activity？如何安全退出已调用多个Activity的Application？&quot;">​</a></h3><h3 id="_28、系统上安装了多种浏览器-能否指定某浏览器访问指定页面-请说明原由。" tabindex="-1">28、系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由。 <a class="header-anchor" href="#_28、系统上安装了多种浏览器-能否指定某浏览器访问指定页面-请说明原由。" aria-label="Permalink to &quot;28、系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由。&quot;">​</a></h3><h3 id="_29、说说-contentprovider、contentresolver、contentobserver-之间的关系" tabindex="-1">29、说说 ContentProvider、ContentResolver、ContentObserver 之间的关系 <a class="header-anchor" href="#_29、说说-contentprovider、contentresolver、contentobserver-之间的关系" aria-label="Permalink to &quot;29、说说 ContentProvider、ContentResolver、ContentObserver 之间的关系&quot;">​</a></h3>`,93),t=[r];function i(d,l,p,c,E,A){return a(),n("div",null,t)}const g=e(o,[["render",i]]);export{u as __pageData,g as default};
