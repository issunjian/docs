import{_ as a,o as e,c as o,V as r}from"./chunks/framework.c6d8cbec.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/backend/jvm/jvm-06.md","filePath":"interview/backend/jvm/jvm-06.md"}'),t={name:"interview/backend/jvm/jvm-06.md"},E=r('<h3 id="_1、类加载有几个过程" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#1%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%89%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B" target="_blank" rel="noreferrer">1、类加载有几个过程？</a> <a class="header-anchor" href="#_1、类加载有几个过程" aria-label="Permalink to &quot;[1、类加载有几个过程？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#1类加载有几个过程)&quot;">​</a></h3><p>加载、验证、准备、解析、初始化。</p><h3 id="_2、简述java的对象结构" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#2%E7%AE%80%E8%BF%B0java%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84" target="_blank" rel="noreferrer">2、简述Java的对象结构</a> <a class="header-anchor" href="#_2、简述java的对象结构" aria-label="Permalink to &quot;[2、简述Java的对象结构](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#2简述java的对象结构)&quot;">​</a></h3><p>Java对象由三个部分组成：对象头、实例数据、对齐填充。</p><p>对象头由两部分组成，第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32/64 bit）。第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。</p><p>实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）</p><p>对齐填充：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐 )</p><h3 id="_3、怎么查看服务器默认的垃圾回收器是哪一个" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#3%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%98%AF%E5%93%AA%E4%B8%80%E4%B8%AA" target="_blank" rel="noreferrer">3、怎么查看服务器默认的垃圾回收器是哪一个？</a> <a class="header-anchor" href="#_3、怎么查看服务器默认的垃圾回收器是哪一个" aria-label="Permalink to &quot;[3、怎么查看服务器默认的垃圾回收器是哪一个？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#3怎么查看服务器默认的垃圾回收器是哪一个)&quot;">​</a></h3><p>这通常会使用另外一个参数：<code>-XX:+PrintCommandLineFlags</code>可以打印所有的参数，包括使用的垃圾回收器。</p><h3 id="_4、java-强引用" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#4java-%E5%BC%BA%E5%BC%95%E7%94%A8" target="_blank" rel="noreferrer">4、JAVA 强引用</a> <a class="header-anchor" href="#_4、java-强引用" aria-label="Permalink to &quot;[4、JAVA 强引用](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#4java-强引用)&quot;">​</a></h3><p>在 Java 中最常见的就是强引用， 把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。</p><h3 id="_5、详细介绍一下jvm内存模型" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#5%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bjvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B" target="_blank" rel="noreferrer">5、详细介绍一下JVM内存模型</a> <a class="header-anchor" href="#_5、详细介绍一下jvm内存模型" aria-label="Permalink to &quot;[5、详细介绍一下JVM内存模型](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#5详细介绍一下jvm内存模型)&quot;">​</a></h3><p>根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。</p><p>具体可能会聊聊jdk1.7以前的PermGen（永久代），替换成Metaspace（元空间）</p><p><strong>1、</strong> 原本永久代存储的数据：符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap</p><p><strong>2、</strong> Metaspace（元空间）存储的是类的元数据信息（metadata）</p><p><strong>3、</strong> 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p><p><strong>4、</strong> 替换的好处：一、字符串存在永久代中，容易出现性能问题和内存溢出。二、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p><h3 id="_6、32-位-jvm-和-64-位-jvm-的最大堆内存分别是多数" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#632-%E4%BD%8D-jvm-%E5%92%8C-64-%E4%BD%8D-jvm-%E7%9A%84%E6%9C%80%E5%A4%A7%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E5%88%AB%E6%98%AF%E5%A4%9A%E6%95%B0" target="_blank" rel="noreferrer">6、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</a> <a class="header-anchor" href="#_6、32-位-jvm-和-64-位-jvm-的最大堆内存分别是多数" aria-label="Permalink to &quot;[6、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#632-位-jvm-和-64-位-jvm-的最大堆内存分别是多数)&quot;">​</a></h3><p>理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5GB，Solaris 大约3GB。64 位 JVM 允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。</p><h3 id="_7、hashmap中的key-可以是普通对象么-需要什么注意的地方" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#7hashmap%E4%B8%AD%E7%9A%84key%E5%8F%AF%E4%BB%A5%E6%98%AF%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E4%B9%88%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9" target="_blank" rel="noreferrer">7、HashMap中的key，可以是普通对象么？需要什么注意的地方？</a> <a class="header-anchor" href="#_7、hashmap中的key-可以是普通对象么-需要什么注意的地方" aria-label="Permalink to &quot;[7、HashMap中的key，可以是普通对象么？需要什么注意的地方？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#7hashmap中的key可以是普通对象么需要什么注意的地方)&quot;">​</a></h3><p>Map的key和value都可以是任何类型。但要注意的是，一定要重写它的equals和hashCode方法，否则容易发生内存泄漏。</p><h3 id="_8、你熟悉哪些垃圾收集算法" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#8%E4%BD%A0%E7%86%9F%E6%82%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95" target="_blank" rel="noreferrer">8、你熟悉哪些垃圾收集算法？</a> <a class="header-anchor" href="#_8、你熟悉哪些垃圾收集算法" aria-label="Permalink to &quot;[8、你熟悉哪些垃圾收集算法？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#8你熟悉哪些垃圾收集算法)&quot;">​</a></h3><p>标记清除（缺点是碎片化） 复制算法（缺点是浪费空间） 标记整理算法（效率比前两者差） 分代收集算法（老年代一般使用“标记-清除”、“标记-整理”算法，年轻代一般用复制算法）</p><h3 id="_9、gc-垃圾收集器" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#9gc-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8" target="_blank" rel="noreferrer">9、GC 垃圾收集器</a> <a class="header-anchor" href="#_9、gc-垃圾收集器" aria-label="Permalink to &quot;[9、GC 垃圾收集器](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#9gc-垃圾收集器)&quot;">​</a></h3><p>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器， JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器</p><h3 id="_10、什么情况发生栈溢出" tabindex="-1"><a href="https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB.md#10%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E5%8F%91%E7%94%9F%E6%A0%88%E6%BA%A2%E5%87%BA" target="_blank" rel="noreferrer">10、什么情况发生栈溢出？</a> <a class="header-anchor" href="#_10、什么情况发生栈溢出" aria-label="Permalink to &quot;[10、什么情况发生栈溢出？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#10什么情况发生栈溢出)&quot;">​</a></h3><p>-Xss可以设置线程栈的大小，当线程方法递归调用层次太深或者栈帧中的局部变量过多时，会出现栈溢出错误 java.lang.StackOverflowError</p><h3 id="_11、java软引用" tabindex="-1">11、JAVA软引用 <a class="header-anchor" href="#_11、java软引用" aria-label="Permalink to &quot;11、JAVA软引用&quot;">​</a></h3><h3 id="_12、jvm内存模型" tabindex="-1">12、JVM内存模型 <a class="header-anchor" href="#_12、jvm内存模型" aria-label="Permalink to &quot;12、JVM内存模型&quot;">​</a></h3><h3 id="_13、如何判断对象是否是垃圾" tabindex="-1">13、如何判断对象是否是垃圾？ <a class="header-anchor" href="#_13、如何判断对象是否是垃圾" aria-label="Permalink to &quot;13、如何判断对象是否是垃圾？&quot;">​</a></h3><h3 id="_14、程序计数器-线程私有" tabindex="-1">14、程序计数器(线程私有) <a class="header-anchor" href="#_14、程序计数器-线程私有" aria-label="Permalink to &quot;14、程序计数器(线程私有)&quot;">​</a></h3><h3 id="_15、java-中垃圾收集的方法有哪些" tabindex="-1">15、Java 中垃圾收集的方法有哪些 <a class="header-anchor" href="#_15、java-中垃圾收集的方法有哪些" aria-label="Permalink to &quot;15、Java 中垃圾收集的方法有哪些&quot;">​</a></h3><h3 id="_16、java对象创建过程" tabindex="-1">16、Java对象创建过程 <a class="header-anchor" href="#_16、java对象创建过程" aria-label="Permalink to &quot;16、Java对象创建过程&quot;">​</a></h3><h3 id="_17、简单描述一下-分代-垃圾回收的过程" tabindex="-1">17、简单描述一下（分代）垃圾回收的过程 <a class="header-anchor" href="#_17、简单描述一下-分代-垃圾回收的过程" aria-label="Permalink to &quot;17、简单描述一下（分代）垃圾回收的过程&quot;">​</a></h3><h3 id="_18、被引用的对象就一定能存活吗" tabindex="-1">18、被引用的对象就一定能存活吗？ <a class="header-anchor" href="#_18、被引用的对象就一定能存活吗" aria-label="Permalink to &quot;18、被引用的对象就一定能存活吗？&quot;">​</a></h3><h3 id="_19、serial-old-收集器-单线程标记整理算法" tabindex="-1">19、Serial Old 收集器（单线程标记整理算法 ） <a class="header-anchor" href="#_19、serial-old-收集器-单线程标记整理算法" aria-label="Permalink to &quot;19、Serial Old 收集器（单线程标记整理算法 ）&quot;">​</a></h3><h3 id="_20、本地方法栈" tabindex="-1">20、本地方法栈 <a class="header-anchor" href="#_20、本地方法栈" aria-label="Permalink to &quot;20、本地方法栈&quot;">​</a></h3><h3 id="_21、什么是方法内联" tabindex="-1">21、什么是方法内联？ <a class="header-anchor" href="#_21、什么是方法内联" aria-label="Permalink to &quot;21、什么是方法内联？&quot;">​</a></h3><h3 id="_22、双亲委派机制可以被违背吗-请举例说明。" tabindex="-1">22、双亲委派机制可以被违背吗？请举例说明。 <a class="header-anchor" href="#_22、双亲委派机制可以被违背吗-请举例说明。" aria-label="Permalink to &quot;22、双亲委派机制可以被违背吗？请举例说明。&quot;">​</a></h3><h3 id="_23、标记整理算法-mark-compact" tabindex="-1">23、标记整理算法(Mark-Compact) <a class="header-anchor" href="#_23、标记整理算法-mark-compact" aria-label="Permalink to &quot;23、标记整理算法(Mark-Compact)&quot;">​</a></h3><h3 id="_24、哪些是-gc-roots" tabindex="-1">24、哪些是 GC Roots？ <a class="header-anchor" href="#_24、哪些是-gc-roots" aria-label="Permalink to &quot;24、哪些是 GC Roots？&quot;">​</a></h3><h3 id="_25、说一下堆内存中对象的分配的基本策略" tabindex="-1">25、说一下堆内存中对象的分配的基本策略 <a class="header-anchor" href="#_25、说一下堆内存中对象的分配的基本策略" aria-label="Permalink to &quot;25、说一下堆内存中对象的分配的基本策略&quot;">​</a></h3><h3 id="_26、jre、jdk、jvm-及-jit-之间有什么不同" tabindex="-1">26、JRE、JDK、JVM 及 JIT 之间有什么不同？ <a class="header-anchor" href="#_26、jre、jdk、jvm-及-jit-之间有什么不同" aria-label="Permalink to &quot;26、JRE、JDK、JVM 及 JIT 之间有什么不同？&quot;">​</a></h3><h3 id="_27、java-内存分配与回收策率以及-minor-gc-和-major-gc" tabindex="-1">27、Java 内存分配与回收策率以及 Minor GC 和 Major GC <a class="header-anchor" href="#_27、java-内存分配与回收策率以及-minor-gc-和-major-gc" aria-label="Permalink to &quot;27、Java 内存分配与回收策率以及 Minor GC 和 Major GC&quot;">​</a></h3><h3 id="_28、如何判断两个类是否相等" tabindex="-1">28、如何判断两个类是否相等？ <a class="header-anchor" href="#_28、如何判断两个类是否相等" aria-label="Permalink to &quot;28、如何判断两个类是否相等？&quot;">​</a></h3><h3 id="_29、java-虚拟机栈的作用" tabindex="-1">29、Java 虚拟机栈的作用？ <a class="header-anchor" href="#_29、java-虚拟机栈的作用" aria-label="Permalink to &quot;29、Java 虚拟机栈的作用？&quot;">​</a></h3><h3 id="_30、能够找到-reference-chain-的对象-就一定会存活么" tabindex="-1">30、能够找到 Reference Chain 的对象，就一定会存活么？ <a class="header-anchor" href="#_30、能够找到-reference-chain-的对象-就一定会存活么" aria-label="Permalink to &quot;30、能够找到 Reference Chain 的对象，就一定会存活么？&quot;">​</a></h3>',48),s=[E];function h(l,n,i,m,A,B){return e(),o("div",null,s)}const u=a(t,[["render",h]]);export{c as __pageData,u as default};
